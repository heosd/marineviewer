const MarineParser=(()=>{const e=(()=>{const e={U1:["getUint8",1],U2:["getUint16",2],U4:["getUint32",4],U8:["getBigUint64",8],I1:["getInt8",1],I2:["getInt16",2],I4:["getInt32",4],I8:["getBigInt64",8],F4:["getFloat32",4],F8:["getFloat64",8]};function t(t){if(e[t])return e[t][1];if("A"===t[0]){const e=t.match(/^A(\d+)$/);if(!e)return-1;const a=parseInt(e[1]);return isNaN(a)?-1:a}return-1}function a(e,t,a){return{v:e,type:t,size:a}}const s={TypeMap:e,GetTypeSize:t,CreateReader:function(s){const r={};let i=0;return s.forEach(((a,s)=>{const n=e[a],o=i;if(n){const e=n[0];r[s]=(t,a,s)=>t[e](a+o,!1!==s),i+=n[1]}else if("A"===a[0]){const e=t(a);if(-1===e)return void console.error("Invalid Ascii type, that should have number after A like A16");r[s]=(t,a)=>{const s=t.byteOffset+a+o,r=t.buffer.slice(s,s+e);return String.fromCharCode.apply(null,new Uint8Array(r))},i+=e}})),r._size=i,r._toObject=(e,t,a,s,i)=>{a.forEach((a=>{s[a]=r[a](e,t,i)}))},r._toDescribeMap=(e,i,n,o)=>{s.forEach(((s,c)=>{const l=a(r[c](e,i,o),s,t(s));n.set(c,l)}))},r},ParseAscii:function(e,t,a){const s=e.buffer.slice(e.byteOffset+t,e.byteOffset+a);return String.fromCharCode.apply(null,new Uint8Array(s))},Describe:a,Undescribe:function(e){const t={};for(const[a,s]of e.entries())t[a]=s.v;return t},UndescribeMap:function(e){for(const[t,a]of e.entries())e.set(t,a.v);return e},ParseBit:function(e,t){const a=[];return e.forEach((e=>{0<(e[0]&t)&&a.push(e)})),a},ParseBitEqual:function(e,t){const a=[];return e.forEach((e=>{(t&e[0])===e[1]&&a.push(e)})),a},ParsedBitJoin:function(e){return e.map((e=>e.at(-1))).join(", ")},Project:function(e){for(const[t,a]of Object.entries(s))e[t]=a}};return s})(),t=(()=>{class a extends DataView{#e=!0;static STX=2;static ETX=3;static BYTE_LENGTH=4;static DATAGRAM_TYPES={73:{title:"Install Start",cls:null},105:{title:"Install Stop",cls:null},112:{title:"Install Remote",cls:null},82:{title:"Runtime",cls:null},88:{title:"XYZ88",cls:null},75:{title:"Central Beams",cls:null},70:{title:"Raw range and Beam angle",cls:null},102:{title:"Raw range and Beam angle F",cls:null},78:{title:"Raw range and angle 78",cls:null},83:{title:"Seabed image",cls:null},89:{title:"Seabed image 89",cls:null},107:{title:"Water column",cls:null},79:{title:"Quality factor 79",cls:null},65:{title:"Attitude",cls:null},110:{title:"Network attitude velocity",cls:null},67:{title:"Clock",cls:null},104:{title:"Depth or height",cls:null},72:{title:"Heading",cls:null},80:{title:"Position",cls:null},69:{title:"Single beam echo sounder depth",cls:null},84:{title:"Tide",cls:null},71:{title:"Surface sound speed",cls:null},85:{title:"Sound speed profile",cls:null},87:{title:"Kongberg Maritime SSP output",cls:null},74:{title:"Mechanical transducer tilt",cls:null},51:{title:"Extra parameters 3",cls:null},48:{title:"PU ID output",cls:null},49:{title:"PU Status output",cls:null},66:{title:"PU BIST result output",cls:null},68:{title:"Depth datagram",cls:null}};static DescType(e){return a.DATAGRAM_TYPES[e]?.title??void 0}set littleEndian(e){this.#e=e}parseBrief(){const e=[];let t=0;for(;t<this.byteLength;){const s=this.parseSection(t);e.push(s),t=t+s.len+a.BYTE_LENGTH}return e}parseSection(e){const t=this.getUint32(e,this.#e),s=this.getUint8(e+4,this.#e),r={type:this.getUint8(e+5,this.#e),offset:e,len:t,valid:!1};return a.STX===s&&(r.valid=!0),r}}class s{static TYPES=[88,136];static IsMyType(e){return-1<s.TYPES.findIndex((t=>t===e))}static STRUCT_XYZ_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["heading","U2"],["ss","U2"],["txTRDepth","F4"],["numBeams","U2"],["numValid","U2"],["freq","F4"],["info","U1"],["spare01","U1"],["spare02","U1"],["spare03","U1"]]);static STRUCT_XYZ_BODY=new Map([["z","F4"],["y","F4"],["x","F4"],["windowLen","U2"],["QFac","U1"],["angAdj","I1"],["dInfo","U1"],["cInfo","I1"],["reflectivity","I2"]]);static STRUCT_XYZ_TAIL=new Map([["spare04","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(s.STRUCT_XYZ_HEAD);static ReadBody=e.CreateReader(s.STRUCT_XYZ_BODY);static ReadTail=e.CreateReader(s.STRUCT_XYZ_TAIL);static ParseSection(e,t,r){const i={},n=s,o=n.ReadHead.numBeams(e,t,r),c=m(n.ReadHead.date(e,t,r),n.ReadHead.time(e,t,r));i.dt=c,i.numBeams=o;const l=n.ReadHead._size+t,d=[];for(let t=0;t<o;t++){const a=l+t*n.ReadBody._size,s=n.ReadBody.x(e,a,r),i=n.ReadBody.y(e,a,r),o=n.ReadBody.z(e,a,r);d.push([s,i,o])}i.body=d;const u=l+o*n.ReadBody._size,p=n.ReadTail.etx(e,u,r);return i.etxValid=a.ETX===p,i}static ParseSectionMinimum(e,t,a){const r=[s.ReadHead.date(e,t,a),s.ReadHead.time(e,t,a),s.ReadHead.numBeams(e,t,a),s.ReadHead.txTRDepth(e,t,a)],i=s.ReadHead._size+t,n=[];for(let t=0;t<r[2];t++){const r=i+t*s.ReadBody._size,o=s.ReadBody.x(e,r,a),c=s.ReadBody.y(e,r,a),l=s.ReadBody.z(e,r,a);n.push([o,c,l])}return r.push(n),r}static ParseSectionDescribe(e,t,a){const r=new Map;s.ReadHead._toDescribeMap(e,t,r,a);let i=s.ReadHead._size;const n=r.get("numBeams").v;for(let t=0;t<n;t++){const n=i+s.ReadBody._size*t,o=new Map;s.ReadBody._toDescribeMap(e,n,o,a);for(const[e,a]of o.entries())r.set(`e${t+1}_`+e,a)}return i+=s.ReadBody._size*n,s.ReadTail._toDescribeMap(e,i,r,a),r}}class r{static TYPES=[73,105,112];static IsMyType(e){return-1<r.TYPES.findIndex((t=>t===e))}static STRUCT_INSTALL=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["lineNo","U2"],["serial","U2"],["serial2ndSonar","U2"]]);static ReadInstall=e.CreateReader(r.STRUCT_INSTALL);static ParseSection(t,s,i){const n={};r.ReadInstall._toObject(t,s,["length","type","model","serial"],n,i);const o=r.ReadInstall._size,c=s+o,l=c+n.length-o,d=e.ParseAscii(t,c,l);n.ascii=d,n.etxValid=!1;const u=t.getUint8(l,i);if(0===u){const e=t.getUint8(l+1,i);a.ETX===e&&(n.etxValid=!0)}else a.ETX===u&&(n.etxValid=!0);return n}static ParseSectionDescribe(t,a,s){const i=new Map;r.ReadInstall._toDescribeMap(t,a,i,s);const n=r.ReadInstall._size,o=a+n,c=o+i.get("length").v-n,l=e.ParseAscii(t,o,c),d=e.Describe(l,"ASCII",c-o);return i.set("ascii",d),D(t,c,i,s),i}}class i{static TYPES=[82];static IsMyType(e){return-1<i.TYPES.findIndex((t=>t===e))}static STRUCT_RUNTIME=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["operatorStationStatus","U1"],["PUStatus","U1"],["BSPStatus","U1"],["SHTStatus","U1"],["mode","U1"],["filterID","U1"],["minDepth","U2"],["maxDepth","U2"],["absorpCoeff","U2"],["txPulseLen","U2"],["txBeamWidth","U2"],["txPower","I1"],["rxBeamWidth","U1"],["rxBandwidth","U1"],["rxGain","U1"],["TVGLawAng","U1"],["srcSS","U1"],["maxPortSwath","U2"],["beamSpacing","U1"],["maxPortCoverage","U1"],["yawPitchStable","U1"],["maxSTBDCoverage","U1"],["maxSTBDSwath","U2"],["txTiltValue","I2"],["filterID2","U1"],["etx","U1"],["checksum","U2"]]);static ReadRuntime=e.CreateReader(i.STRUCT_RUNTIME);static ParseSectionDescribe(e,t,a){const s=new Map;return i.ReadRuntime._toDescribeMap(e,t,s,a),s}static BitPUStatus=[[1,"Communication error With BSP (or CBMF) : All models except ME70BO"],[2,"Communication error with Sonar Head or Transceiver : All models except EM 2040 and ME70BO, Communication error with slave PU : EM 2040/EM 2040C, Problem with communication with ME70 : ME70BO"],[4,"Attitude not valid for this ping : All models"],[8,"Heading not valid for this ping : All models"],[16,"System clock has not been set since power up : All models"],[32,"External trigger signal not detected : All models except ME70BO"],[64,"CPU temperature warning : All models except EM 1002, Hull Unit not responding : EM 1002"],[128,"Attitude velocity data not valid for this ping : EM 122 EM 302 EM 710 EM 2040 EM 2040C"]];static BitBSPStatusA=[[1,"Error on R0 data received by BSP 1 (May be a bad high speed link) : EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[2,"Too much seabed image data on BSP1 : EM 3000, EM 3000D"],[4,"Invalid command received by BSP1 : EM 3000, EM 3000D"],[8,"Errors on BSP1 : EM 3002, EM 3002D"],[16,"Error on R0 data received by BSP 2 (May be a bad high speed link) : EM 3000D, EM 3002D"],[32,"Too much seabed image data on BSP2 : EM 3000D"],[64,"Invalid command received by BSP2 : EM 3000D"],[128,"Errors on BSP2 : EM 3002, EM 3002D"]];static BitBSPStatusB=[[1,"Sample number error in RX data received from SPRX"]];static BitBSPStatusC=[[1,"Sample number error in R0 data received from SPRX"],[2,"Missing R0 header data from SPRX"],[4,"Missing sample data from SPTX"],[8,"Missing second R0 header data from SPTX"],[16,"Bad sync TRU - PU - BSP"],[32,"Bad parameters received from PU"],[64,"Internal sync problem in BSP"],[128,"Checksum error in header from SPTX"]];static BitBSPStatusD=[[1,"Error on RX data received by BSP 1"],[2,"Error on RX data received by BSP 3"],[4,"Errors on BSP 3"],[8,"Errors on BSP 1"],[16,"Error on RX data received by BSP 2"],[32,"Error on RX data received by BSP 4"],[64,"Errors on BSP 4"],[128,"Errors on BSP2"]];static BitBSPStatusE=[[1,"Error on data from BSP 1 - master PU"],[2,"Error on data from BSP 2 - master PU"],[4,"Error on data from BSP 3 - master PU"],[8,"Error on data from BSP 4 - master PU"],[16,"Error on data from BSP 1 - slave PU"],[32,"Error on data from BSP 2 - slave PU"],[64,"Error on data from BSP 3 - slave PU"],[128,"Error on data from BSP 4 - slave PU"]];static BitCRMFStatus=[[1,"Error on data from CBMF 1 - master PU"],[2,"Error on data from CBMF 2 - master PU"],[4,"Error on data from CBMF 3 - slave PU"],[8,"Error on data from CBMF 4 - slave PU"]];static ModelBSPStatus=new Map([[2e3,[i.BitBSPStatusA]],[3e3,[i.BitBSPStatusA]],[3002,[i.BitBSPStatusA]],[1002,[i.BitBSPStatusB]],[102,[i.BitBSPStatusC]],[300,[i.BitBSPStatusC]],[122,[i.BitBSPStatusD]],[302,[i.BitBSPStatusD]],[710,[i.BitBSPStatusD]],[2040,[i.BitBSPStatusE]]]);static BitTransceiverStatusA=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Timeout error (SPRX waits for SPTX)"],[8,"Receive channel DC offset(s) out of range"],[16,"Illegal parameter received from PU"],[32,"Internal communication error (SPTX - SPRX sync)"],[64,"Timeout error (SPTX waits for SPRX)"],[128,"Defective fuse(s) in transmitter"]];static BitTransceiverStatusB=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Error on Transmitter"],[8,"Error on Receiver"],[16,"Not implemented"],[32,"Not implemented"],[64,"Not implemented"],[128,"Not implemented"]];static BitTransceiverStatusC=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Transmit voltage (HV) to high"],[8,"Error in command from PU (Illegal parameter)"],[16,"Error in command from PU (Bad checksum)"],[32,"Error in command from PU (Bad datagram length)"]];static BitTransceiverStatusD=[[1,"Transmit power (HV) out of range"],[2,"Communication error with TX"],[4,"Communication error with RX 1 (port)"],[8,"Communication error with RX 2 (starboard)"],[16,"Communication error with IO2040 - master PU"],[32,"Communication error with IO2040 - slave PU"],[64,"Spare"],[128,"Spare"]];static BitSonarHeadStatusA=[[1,"Temperature to high on Sonar Head 1 EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[2,"Data link failure on Sonar Head 1 EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[4,"DC Supply Voltages in Sonar Head 1 is out of range EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[8,"Spare"],[16,"Temperature to high on Sonar Head 2 EM 3000D, EM 3002D"],[32,"Data link failure on Sonar Head 2 EM 3000D, EM 3002D"],[64,"DC Supply Voltages in Sonar Head 2 is out of range EM 3000D, EM 3002D"],[128,"Spare"]];static BitSonarHeadStatusB=[[1,"Transmit power (HV) out of range SH1"],[2,"Communication error with TX SH1"],[4,"Communication error with RX SH1"],[8,"Temperature to high SH1"],[16,"Transmit power (HV) out of range SH2"],[32,"Communication error with TX SH2"],[64,"Communication error with RX SH2"],[128,"Temperature to high SH2"]];static ModelSHTStatus=new Map([[102,[i.BitTransceiverStatusA]],[300,[i.BitTransceiverStatusA]],[122,[i.BitTransceiverStatusB]],[302,[i.BitTransceiverStatusB]],[710,[i.BitTransceiverStatusB]],[1002,[i.BitTransceiverStatusC]],[2e3,[i.BitSonarHeadStatusA]],[3e3,[i.BitSonarHeadStatusA]],[3002,[i.BitSonarHeadStatusA]],[2040,[i.BitTransceiverStatusD,i.BitSonarHeadStatusB]]]);static BitEqualPingModeA=[[15,0,"Nearfield (4º)"],[15,1,"Normal (1.5º)"],[15,2,"Target detect"]];static BitEqualPingModeB=[[15,0,"Wide Tx beamwidth (4°)"],[15,1,"Normal Tx beamwidth (1.5°)"]];static BitEqualPingModeC=[[15,0,"Very Shallow"],[15,1,"Shallow"],[15,2,"Medium"],[15,3,"Deep"],[15,4,"Very deep"],[15,5,"Extra deep"]];static BitEqualPingModeD=[[15,0,"200 kHz"],[15,1,"300 kHz"],[15,2,"400 kHz"]];static BitEqualTXPulseFormA=[[48,0,"CW"],[48,16,"Mixed"],[48,32,"FM"]];static BitEqualFrequency=[[31,0,"180 kHz"],[31,1,"190 kHz"],[31,22,"400 kHz"]];static BitEqualTXPulseFormB=[[32,0,"CW"],[32,32,"FM"]];static BitEqualDualSwathMode=[[192,0,"Dual swath = Off"],[192,64,"Dual swath = Fixed"],[192,128,"Dual swath = Dynamic"]];static ModelMode=new Map([[3e3,[i.BitEqualPingModeA]],[3002,[i.BitEqualPingModeB]],[2e3,[i.BitEqualPingModeC]],[710,[i.BitEqualPingModeC,i.BitEqualTXPulseFormA,i.BitEqualDualSwathMode]],[1002,[i.BitEqualPingModeC]],[300,[i.BitEqualPingModeC]],[302,[i.BitEqualPingModeC,i.BitEqualTXPulseFormA,i.BitEqualDualSwathMode]],[120,[i.BitEqualPingModeC]],[122,[i.BitEqualPingModeC,i.BitEqualTXPulseFormA,i.BitEqualDualSwathMode]],[2040,[i.BitEqualPingModeD,i.BitEqualTXPulseFormA,i.BitEqualFrequency,i.BitEqualTXPulseFormB,i.BitEqualDualSwathMode]]]);static BitEqualFilterID=[[3,0,"Spike filter set to Off"],[3,1,"Spike filter is set to Weak"],[3,2,"Spike filter is set to Medium"],[3,3,"Spike filter is set to Strong"],[4,4,"Slope filter is on"],[8,8,"Sector tracking or Robust Bottom Detection (EM 3000) is on"],[144,0,"Range gates have Normal size"],[144,16,"Range gates are Large"],[144,128,"Range gates are Small"],[32,32,"Aeration filter is on"],[64,64,"Interference filter is on"]];static BitEqualFilterID2=[[3,0,"Penetration filter = Off"],[3,1,"Penetration filter = Weak"],[3,2,"Penetration filter = Medium"],[3,3,"Penetration filter = Strong"],[12,0,"Detect mode: Normal"],[12,4,"Detect mode: Waterway"],[12,8,"Detect mode: Tracking"],[12,12,"Detected mode: Minimum depth"],[48,0,"Short phase ramp"],[48,16,"Normal phase ramp"],[48,32,"Long phase ramp"],[64,0,"Normal TVG"],[64,64,"Special TVG"],[128,0,"Normal amp detect"],[128,128,"Special amp detect or soft sediments (EM 3002)"]];static BitEqualSoundSpeed=[[3,0,"From real time sensor"],[3,1,"Manually entered by operator"],[3,2,"Interpolated from currently used sound speed profile"],[3,3,"Calculated by ME70BO TRU"],[16,16,"Extra detections enabled"],[32,32,"Sonar mode enabled"],[64,64,"Passive mode enabled"],[128,128,"3D scanning enabled"]];static BitEqualBeamspacing=[[3,0,"Determined by beamwidth (FFT beamformer of EM 3000)"],[3,1,"Equidistant (Inbetween for EM 122 and EM 302)"],[3,2,"Equiangle"],[3,3,"High density equidistant (In between for EM 2000, EM 120, EM 300, EM 1002)"]];static BitEqualBeamspacing3002Only=[[128,0,"Only one sonar head is connected. If two heads are connected, both have the same beam spacing."],[128,128,"Two sonar heads are connected. Individual beam spacing is possible."],[112,0,"No head 2"],[112,16,"h2 equidistant"],[112,32,"h2 equiangle"],[112,48,"h2 high density"],[15,1,"h1 equidistant"],[15,2,"h1 equiangle"],[15,3,"h1 high density"]];static BitEqualYawPitchStable=[[3,0,"No yaw stabilization"],[3,1,"Yaw stabilization to survey line heading (Not used)"],[3,2,"Yaw stabilization to mean vessel heading"],[3,3,"Yaw stabilization to manually entered heading"],[12,0,"Heading filter, hard"],[12,4,"Heading filter, medium"],[12,8,"Heading filter, weak"],[128,128,"Pitch stabilization is on."]];static BitEqualRXFixedGain20040Only=[[3,0,"Off (RX inactive)"],[3,1,"port active"],[3,2,"starboard active"],[3,3,"Both active"],[12,0,"Short CW"],[12,4,"Medium CW"],[12,8,"Long CW"],[12,12,"FM"],[112,0,"Very Short CW"],[112,16,"Short CW"],[112,32,"Medium CW"],[112,48,"Long CW"],[112,64,"Very Long CW"],[112,80,"Extra Long CW"],[112,96,"Short FM"],[112,112,"Long FM"]];static ParseOperatorStationStatus(e){return[]}static ParsePUStatus(t){return e.ParseBit(i.BitPUStatus,t)}static ParseBSPStatus(t,a){const s=i.ModelBSPStatus.get(a);return s?e.ParseBit(s,t):[[t,`No model found for ${a}`]]}static ParseSHTStatus(t,a){const s=i.ModelSHTStatus.get(a);return s?[].concat(...s.map((a=>e.ParseBit(a,t)))):[[t,`No model found for ${a}`]]}static ParseMode(t,a){const s=i.ModelMode.get(a);return s?[].concat(...s.map((a=>e.ParseBitEqual(a,t)))):[[t,`No model found for ${a}`]]}static ParseFilterID(t){return e.ParseBitEqual(i.BitEqualFilterID,t)}static ParseFilterID2(t){return e.ParseBitEqual(i.BitEqualFilterID2,t)}static ParseSrcSS(t){return e.ParseBitEqual(i.BitEqualSoundSpeed,t)}static ParseBeamSpacing(t,a){return 3002===a?e.ParseBitEqual(i.BitEqualBeamspacing3002Only,t):e.ParseBitEqual(i.BitEqualBeamspacing,t)}static ParseYawPitchStable(t){return e.ParseBitEqual(i.BitEqualYawPitchStable,t)}static ParseRXGain(t,a){return 2040!==a?[[0,0,t]]:e.ParseBitEqual(i.BitEqualRXFixedGain20040Only,t)}}class n{static TYPES=[80];static IsMyType(e){return-1<n.TYPES.findIndex((t=>t===e))}static STRUCT_POSITION=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["positionCounter","U2"],["serial","U2"],["lat","I4"],["lng","I4"],["measurePosFixQ","U2"],["speed","U2"],["course","U2"],["heading","U2"],["posSysDesc","U1"],["numInput","U1"]]);static ReadPosition=e.CreateReader(n.STRUCT_POSITION);static ParseLatDegree=e=>e/2e7;static ParseLngDegree=e=>e/1e7;static ParseSpeedMpS=e=>e/100;static ParseCourseDegree=e=>e/100;static ParseHeadingDegree=e=>e/100;static ParseSection(e,t,a){const s={},r={},i=n;i.ReadPosition._toObject(e,t,["date","time","lat","lng","speed","course","heading"],r,a);const o=m(r.date,r.time);return s.dt=o,s.lat=i.ParseLatDegree(r.lat),s.lng=i.ParseLngDegree(r.lng),s.speed=i.ParseSpeedMpS(r.speed),s.course=i.ParseCourseDegree(r.course),s.heading=i.ParseHeadingDegree(r.heading),s}static ParseSectionMinimum(e,t,a){const s=n;return[s.ReadPosition.date(e,t,a),s.ReadPosition.time(e,t,a),n.ParseLatDegree(s.ReadPosition.lat(e,t,a)),n.ParseLngDegree(s.ReadPosition.lng(e,t,a)),n.ParseHeadingDegree(s.ReadPosition.heading(e,t,a))]}static ParseSectionDescribe(t,a,s){const r=new Map;n.ReadPosition._toDescribeMap(t,a,r,s);const i=a+n.ReadPosition._size,o=r.get("numInput").v,c=i+o,l=e.ParseAscii(t,i,c);return r.set("input",e.Describe(l,"A"+o,o)),D(t,c,r,s),r}}class o{static TYPES=[68];static IsMyType(e){return-1<o.TYPES.findIndex((t=>t===e))}static STRUCT_DD_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["heading","U2"],["ss","U2"],["txTRDepth","U2"],["maxNumBeams","U1"],["numValid","U1"],["zRes","U1"],["xyRes","U1"],["freq","U2"]]);static STRUCT_DD_BODY=new Map([["z","U2"],["y","I2"],["x","I2"],["beamDeprAng","I2"],["beamAzimAng","U2"],["range","U2"],["QFac","U1"],["len","U1"],["reflectivity","I1"],["beamNum","U1"]]);static STRUCT_DD_BODY_SIGN=new Map([["z","I2"],["y","I2"],["x","I2"],["beamDeprAng","I2"],["beamAzimAng","U2"],["range","U2"],["QFac","U1"],["len","U1"],["reflectivity","I1"],["beamNum","U1"]]);static STRUCT_DD_TAIL=new Map([["depthOffsetM","I1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(o.STRUCT_DD_HEAD);static ReadBody=e.CreateReader(o.STRUCT_DD_BODY);static ReadBodySign=e.CreateReader(o.STRUCT_DD_BODY_SIGN);static ReadTail=e.CreateReader(o.STRUCT_DD_TAIL);static ParseSectionMinimum(e,t,a){const s=o.ReadHead.model(e,t,a),r=[o.ReadHead.date(e,t,a),o.ReadHead.time(e,t,a),o.ReadHead.numValid(e,t,a),o.ReadHead.txTRDepth(e,t,a)/100],i=o.ReadHead._size+t,n=[];let c=o.ReadBody;120!==s&&300!==s||(c=o.ReadBodySign);for(let t=0;t<r[2];t++){const s=i+t*c._size,r=c.x(e,s,a),o=c.y(e,s,a),l=c.z(e,s,a);n.push([r/100,o/100,l/100])}return r.push(n),r}static ParseSectionDescribe(e,t,a){const s=new Map;o.ReadHead._toDescribeMap(e,t,s,a);const r=s.get("model").v,i=s.get("numValid").v;let n=o.ReadHead._size,c=o.ReadBody;120!==r&&300!==r||(c=o.ReadBodySign);for(let t=0;t<i;t++){const r=n+c._size*t,i=new Map;c._toDescribeMap(e,r,i,a);for(const[e,a]of i.entries())s.set(`e${t+1}_`+e,a)}return n+=c._size*i,o.ReadTail._toDescribeMap(e,n,s,a),s}}class c{static TYPES=[85];static IsMyType(e){return-1<c.TYPES.findIndex((t=>t===e))}static STRUCT_SS_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["date2","U4"],["time2","U4"],["numEntries","U2"],["depthRes","U2"]]);static STRUCT_SS_ENTRY=new Map([["depth","U4"],["ss","U4"]]);static STRUCT_SS_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(c.STRUCT_SS_HEAD);static ReadEntry=e.CreateReader(c.STRUCT_SS_ENTRY);static ReadTail=e.CreateReader(c.STRUCT_SS_TAIL);static ParseSectionDescribe(t,a,s){const r=new Map,i=!1!==s;c.ReadHead._toDescribeMap(t,a,r,s);const n=r.get("numEntries").v;let o=a+c.ReadHead._size;for(let a=0;a<n;a++){const s=o+8*a,n=c.ReadEntry.depth(t,s,i),l=c.ReadEntry.ss(t,s+4,i);r.set(`depth_${a+1}`,e.Describe(n,"U4",4)),r.set(`ss_${a+1}`,e.Describe(l,"U4",4))}return o+=8*n,c.ReadTail._toDescribeMap(t,o,r,s),r}}class l{static TYPES=[48];static IsMyType(e){return-1<l.TYPES.findIndex((t=>t===e))}static STRUCT_PU_ID=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["byteOrder","U2"],["serial","U2"],["UDP1","U2"],["UDP2","U2"],["UDP3","U2"],["UDP4","U2"],["sysDesc","U4"],["PUVer","A16"],["BSPVer","A16"],["sonarHead1Ver","A16"],["sonarHead2Ver","A16"],["IPAddr","U4"],["txOpenAng","U1"],["rxOpenAng","U1"],["spare1","U4"],["spare2","U2"],["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadPUID=e.CreateReader(l.STRUCT_PU_ID);static ParseSectionDescribe(e,t,a){const s=new Map;return l.ReadPUID._toDescribeMap(e,t,s,a),s}}class d{static TYPES=[49];static IsMyType(e){return-1<d.TYPES.findIndex((t=>t===e))}static STRUCT_PU_STATUS=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["statusCounter","U2"],["serial","U2"],["pingRate","U2"],["pingCounter","U2"],["distSwath10","U4"],["UDP2","U4"],["serial1","U4"],["serial2","U4"],["serial3","U4"],["serial4","U4"],["pps","I1"],["posStat","I1"],["attStat","I1"],["clockStat","I1"],["headingStat","I1"],["puStat","U1"],["lastHeading","U2"],["lastRoll","I2"],["lastPitch","I2"],["lastHeave","U2"],["ssTrans","U2"],["lastDepth","U4"],["velocity","I2"],["attVelocity","U1"],["mammalRamp","U1"],["backObliqueAngle","I1"],["backIncidence","I1"],["fixedGain","I1"],["depthIncidence","U1"],["rangeIncidence","U2"],["portCoverage","U1"],["stbdCoverage","U1"],["ssTransProfile","U2"],["yawStabAngle","I2"],["portCoverage2","I2"],["stbdCoverage2","I2"],["tempCPU","I1"],["etx","U1"],["checksum","U2"]]);static ReadPUStatus=e.CreateReader(d.STRUCT_PU_STATUS);static ParseSectionDescribe(e,t,a){const s=new Map;return d.ReadPUStatus._toDescribeMap(e,t,s,a),s}}class u{static TYPES=[110];static IsMyType(e){return-1<u.TYPES.findIndex((t=>t===e))}static STRUCT_NATTV=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["netAttCounter","U2"],["serial","U2"],["numEntries","U2"],["senSysDesc","I1"],["spare1","U1"]]);static STRUCT_NATTV_ENTRY=new Map([["time","U2"],["roll","I2"],["pitch","I2"],["heave","I2"],["heading","U2"],["numBytes","U1"]]);static ReadHead=e.CreateReader(u.STRUCT_NATTV);static ReadEntry=e.CreateReader(u.STRUCT_NATTV_ENTRY);static ParseSectionDescribe(t,a,s){const r=new Map;u.ReadHead._toDescribeMap(t,a,r,s);const i=r.get("numEntries").v;let n=a+u.ReadHead._size;for(let a=0;a<i;a++){const i=new Map;u.ReadEntry._toDescribeMap(t,n,i,s),n+=u.ReadEntry._size;const o=i.get("numBytes").v,c=e.ParseAscii(t,n,n+o);n+=o,i.set("inputs",e.Describe(c,"A"+o,o));for(const[e,t]of i.entries())r.set(`e${a+1}_`+e,t)}return D(t,n,r,s),r}}class p{static TYPES=[67];static IsMyType(e){return-1<p.TYPES.findIndex((t=>t===e))}static STRUCT_CLOCK=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["clockCounter","U2"],["serial","U2"],["date2","U4"],["time2","U4"],["ppsUsed","U1"],["etx","U1"],["checksum","U2"]]);static ReadClock=e.CreateReader(p.STRUCT_CLOCK);static ParseSectionDescribe(e,t,a){const s=new Map;return p.ReadClock._toDescribeMap(e,t,s,a),s}}class h{static TYPES=[65];static IsMyType(e){return-1<h.TYPES.findIndex((t=>t===e))}static STRUCT_ATT_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["attCounter","U2"],["serial","U2"],["numEntries","U2"]]);static STRUCT_ATT_ENTRY=new Map([["time","U2"],["senStatus","U2"],["roll","I2"],["pitch","I2"],["heave","I2"],["heading","U2"]]);static STRUCT_ATT_TAIL=new Map([["senSysDesc","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(h.STRUCT_ATT_HEAD);static ReadEntry=e.CreateReader(h.STRUCT_ATT_ENTRY);static ReadTail=e.CreateReader(h.STRUCT_ATT_TAIL);static ParseSectionDescribe(e,t,a){const s=new Map;h.ReadHead._toDescribeMap(e,t,s,a);const r=s.get("numEntries").v;let i=t+h.ReadHead._size;for(let t=0;t<r;t++){const r=new Map;h.ReadEntry._toDescribeMap(e,i,r,a),i+=h.ReadEntry._size;for(const[e,a]of r.entries())s.set(`e${t+1}_`+e,a)}return h.ReadTail._toDescribeMap(e,i,s,a),s}}class U{static TYPES=[83];static IsMyType(e){return-1<U.TYPES.findIndex((t=>t===e))}static STRUCT_SEABED_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["meanAbsorpCoeff","U2"],["pulseLen","U2"],["rangeIncience","U2"],["startTVG","U2"],["stoptTVG","U2"],["BSN","I1"],["BSO","I1"],["txBeamWidth","U2"],["tvgLaw","U1"],["numValidBeams","U1"]]);static STRUCT_SEABED_ENTRY=new Map([["idx","U1"],["direction","I1"],["Ns","U2"],["centreSampleNum","U2"]]);static ReadHead=e.CreateReader(U.STRUCT_SEABED_HEAD);static ReadEntry=e.CreateReader(U.STRUCT_SEABED_ENTRY);static ParseSectionDescribe(e,t,a){const s=new Map;U.ReadHead._toDescribeMap(e,t,s,a);const r=s.get("numValidBeams").v;let i=t+U.ReadHead._size;for(let t=0;t<r;t++){const r=new Map;U.ReadEntry._toDescribeMap(e,i,r,a),i+=U.ReadEntry._size;for(const[e,a]of r.entries())s.set(`e${t+1}_`+e,a)}return s}}class S{static TYPES=[89,137];static IsMyType(e){return-1<S.TYPES.findIndex((t=>t===e))}static STRUCT_SEABED89_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["sampleFreq","F4"],["rangeIncience","U2"],["BSN","I2"],["BSO","I2"],["txBeamWidth","U2"],["tvgLaw","U2"],["numValidBeams","U2"]]);static STRUCT_SEABED89_ENTRY=new Map([["direction","I1"],["dInfo","U1"],["Ns","U2"],["centreSampleNum","U2"]]);static STRUCT_SEABED89_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(S.STRUCT_SEABED89_HEAD);static ReadEntry=e.CreateReader(S.STRUCT_SEABED89_ENTRY);static ReadTail=e.CreateReader(S.STRUCT_SEABED89_TAIL);static ParseSectionDescribe(t,a,s){const r=new Map,i=!1!==s;S.ReadHead._toDescribeMap(t,a,r,s);const n=r.get("numValidBeams").v;let o=a+S.ReadHead._size,c=0;for(let e=0;e<n;e++){const a=new Map;S.ReadEntry._toDescribeMap(t,o,a,s),o+=S.ReadEntry._size;c+=a.get("Ns").v;for(const[t,s]of a.entries())r.set(`e${e+1}_`+t,s)}for(let a=0;a<c;a++){const s=o+2*a,n=t.getInt16(s,i);r.set(`amplitudes${a+1}`,e.Describe(n,"I2",2))}return o+=2*c,S.ReadTail._toDescribeMap(t,o,r,s),r}}class T{static TYPES=[78,120];static IsMyType(e){return-1<T.TYPES.findIndex((t=>t===e))}static STRUCT_RAW78_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["ssTrans","U2"],["Ntx","U2"],["Nrx","U2"],["numValidDetect","U2"],["sampleFreq","F4"],["dScale","U4"]]);static STRUCT_RAW78_ENTRY_NTX=new Map([["tiltAngle","I2"],["focusRange","U2"],["sigLen","F4"],["secTransDelay","F4"],["centreFreq","F4"],["meanAbsorpCoeff","U2"],["sigId","U1"],["transSecNum","U1"],["sigBandwidth","F4"]]);static STRUCT_RAW78_ENTRY_RTX=new Map([["beamAngle","I2"],["transSecNum","U1"],["dInfo","U1"],["windowLen","U2"],["qFac","U1"],["dCorr","I1"],["twoTT","F4"],["BS","I2"],["cInfo","I1"],["spare","U1"]]);static STRUCT_RAW78_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(T.STRUCT_RAW78_HEAD);static ReadEntryTX=e.CreateReader(T.STRUCT_RAW78_ENTRY_NTX);static ReadEntryRX=e.CreateReader(T.STRUCT_RAW78_ENTRY_RTX);static ReadTail=e.CreateReader(T.STRUCT_RAW78_TAIL);static ParseSectionDescribe(e,t,a){const s=new Map;T.ReadHead._toDescribeMap(e,t,s,a);const r=s.get("Ntx").v;let i=t+T.ReadHead._size;for(let t=0;t<r;t++){const r=new Map;T.ReadEntryTX._toDescribeMap(e,i,r,a),i+=T.ReadEntryTX._size;for(const[e,a]of r.entries())s.set(`ntx${t+1}_`+e,a)}const n=s.get("Nrx").v;for(let t=0;t<n;t++){const r=new Map;T.ReadEntryRX._toDescribeMap(e,i,r,a),i+=T.ReadEntryRX._size;for(const[e,a]of r.entries())s.set(`nrx${t+1}_`+e,a)}return T.ReadTail._toDescribeMap(e,i,s,a),s}}class f{static TYPES=[51];static IsMyType(e){return-1<f.TYPES.findIndex((t=>t===e))}static STRUCT_EXTRA_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["contentID","U2"]]);static ReadHead=e.CreateReader(f.STRUCT_EXTRA_HEAD);static ReadContentID6=(t,a,s,r)=>{const i=!1!==r,n=t.getUint16(a,i);s.set("Nc",e.Describe(n,"U2",2));const o=e.ParseAscii(t,a+2,a+2+n);return s.set("content",e.Describe(o,"A"+n,n)),s};static ParseSectionDescribe(e,t,a){const s=new Map;f.ReadHead._toDescribeMap(e,t,s,a);let r=f.ReadHead._size;return 6===s.get("contentID").v&&(f.ReadContentID6(e,t+r,s,a),r=2+r+s.get("Nc").v),D(e,r,s,a),s}}function m(e,t){const a=parseInt(e/1e4),s=parseInt(e/100%100),r=parseInt(e%100),i=parseInt(t/1e3),n=parseInt(i/60/60),o=parseInt(i/60%60),c=parseInt(t/1e3%60),l=parseInt(t%1e3);return new Date(`${a}-${s}-${r} ${n}:${o}:${c}.${l}`)}function D(t,a,s,r){let i=a;const n=!1!==r;0===t.getUint8(i,n)&&(i++,s.set("spareEOS",e.Describe(0,"U1",1)));const o=t.getUint8(i++,n);s.set("etx",e.Describe(o,"U1",1));const c=t.getUint16(i++,n);s.set("checksum",e.Describe(c,"U2",2))}const g=(()=>{const e=new Map;return[s,n,o,i,r,c,l,u,p,h,U,S,d,T,f].forEach((t=>{t.TYPES.forEach((a=>{e.set(a,t)}))})),t=>e.get(t)})();class E{constructor(){this.mb=void 0,this.sections=void 0,this.isLE=!0,this.positions=void 0,this.xyz=void 0,this.lines=void 0}load(e,t,a){this.mb=e,this.sections=t,this.isLE=a,this.typeXYZ=this.judgeXYZ()}judgeXYZ(){return-1<this.sections.findIndex((e=>88===e.type))?88:-1<this.sections.findIndex((e=>68===e.type))?68:void 0}parsePosition(){const e=[],t=g(80);for(let a=0;a<this.sections.length;a++){const s=this.sections[a];if(80===s.type){const a=t.ParseSectionMinimum(this.mb,s.offset,s.length);e.push(a)}}this.positions=e}parseXYZ(){const e=[],t=this.typeXYZ,a=g(t);for(let t=0;t<this.sections.length;t++){const s=this.sections[t];if(68===s.type){const t=a.ParseSectionMinimum(this.mb,s.offset,s.length);e.push(t)}else if(88===s.type){const t=a.ParseSectionMinimum(this.mb,s.offset,s.length);e.push(t)}}this.xyz=e}calcPositionWithXYZ(){const e=Array(this.xyz.length);for(let t=0;t<this.xyz.length;t++){const a=this.xyz[t],s=this.findNearestPosition(a[0],a[1]),r=a[4],i=[],n=r.map((e=>e[0])),o=E.destVincentyArray(s[2],s[3],s[4],n);for(let e=0;e<r.length;e++){const t=r[e],n=E.destVincenty(o[e][0],o[e][1],s[4]+90,t[1]);i.push([n[0],n[1],a[3]+t[2]])}e[t]=i}this.lines=e}_debugcalcPositionWithXYZ(){const e=[];for(let t=0;t<this.xyz.length;t++){const a=this.xyz[t],s=this.findNearestPosition(a[0],a[1]),r=a[4],i=[];for(let e=0;e<r.length;e++){const t=r[e],n=E.destVincenty(s[2],s[3],s[4],t[0]),o=E.destVincenty(n.lat,n.lng,s[4]+90,t[1]);i.push([o.lat,o.lng,a[3]+t[2]])}e.push(i)}this.lines2=e}_testFindNearest(){for(let e=0;e<this.xyz.length;e++){const t=this.xyz[e],a=this.findNearestPosition(t[0],t[1]),s=this.findNearestPositionLinear(t[0],t[1]);if(a!==s){console.log(`is diff ${t[0]} ${t[1]} at [${e}]`),console.log(a,s);const r=[a[0]-t[0],a[1]-t[1]],i=[s[0]-t[0],s[1]-t[1]];console.log(r,i);break}}}_debugFindNearest(e){const t=this.xyz[e],a=this.findNearestPosition(t[0],t[1]),s=this.findNearestPositionLinear(t[0],t[1]);if(a!==s){console.log(`is diff ${t[0]} ${t[1]} at [${e}]`),console.log(a,s);const r=[a[0]-t[0],a[1]-t[1]],i=[s[0]-t[0],s[1]-t[1]];console.log(r,i)}}findNearestPosition(e,t){let a,s=0,r=this.positions.length-1;for(;r-s>1;)a=Math.floor((s+r)/2),this.positions[a][0]<e||this.positions[a][0]===e&&this.positions[a][1]<t?s=a:r=a;if(r===s)return this.positions[s];const i=this.positions[s],n=this.positions[r],o=[Math.abs(e-i[0]),Math.abs(t-i[1])],c=[Math.abs(e-n[0]),Math.abs(t-n[1])];return o[0]>c[0]?n:o[0]<c[0]?i:o[1]>c[1]?n:i}findNearestPositionLinear(e,t){return this.positions.reduce(((a,s)=>{const r=[Math.abs(e-a[0]),Math.abs(t-a[1])],i=[Math.abs(e-s[0]),Math.abs(t-s[1])];return r[0]>i[0]?s:r[0]<i[0]?a:r[1]>i[1]?s:a}))}clearMemory(){this.positions=[],this.xyz=[],this.sections=[],this.mb=void 0}static destVincentyArray(e,t,a,s){const r=[],i=6378137,n=6356752.3142,o=1/298.257223563,c=a*Math.PI/180,l=Math.sin(c),d=Math.cos(c),u=(1-o)*Math.tan(e*Math.PI/180),p=1/Math.sqrt(1+u*u),h=u*p,U=Math.atan2(u,d),S=p*l,T=1-S*S,f=T*(i*i-n*n)/(n*n),m=1+f/16384*(4096+f*(f*(320-175*f)-768)),D=f/1024*(256+f*(f*(74-47*f)-128));for(let e=0;e<s.length;e++){const a=s[e];let i=a/(n*m),c=2*Math.PI;for(;Math.abs(i-c)>1e-12;){var g=Math.cos(2*U+i),E=Math.sin(i),R=Math.cos(i);c=i,i=a/(n*m)+D*E*(g+D/4*(R*(2*g*g-1)-D/6*g*(4*E*E-3)*(4*g*g-3)))}var P=h*E-p*R*d,M=Math.atan2(h*R+p*E*d,(1-o)*Math.sqrt(S*S+P*P)),C=o/16*T*(4+o*(4-3*T)),I=Math.atan2(E*l,p*R-h*E*d)-(1-C)*o*S*(i+C*E*(g+C*R*(2*g*g-1)));Math.atan2(S,-P);r.push([180*M/Math.PI,t+180*I/Math.PI])}return r}static destVincenty(e,t,a,s){for(var r=6378137,i=6356752.3142,n=1/298.257223563,o=s,c=a*Math.PI/180,l=Math.sin(c),d=Math.cos(c),u=(1-n)*Math.tan(e*Math.PI/180),p=1/Math.sqrt(1+u*u),h=u*p,U=Math.atan2(u,d),S=p*l,T=1-S*S,f=T*(r*r-i*i)/(i*i),m=1+f/16384*(4096+f*(f*(320-175*f)-768)),D=f/1024*(256+f*(f*(74-47*f)-128)),g=o/(i*m),E=2*Math.PI;Math.abs(g-E)>1e-12;){var R=Math.cos(2*U+g),P=Math.sin(g),M=Math.cos(g);E=g,g=o/(i*m)+D*P*(R+D/4*(M*(2*R*R-1)-D/6*R*(4*P*P-3)*(4*R*R-3)))}var C=h*P-p*M*d,I=Math.atan2(h*M+p*P*d,(1-n)*Math.sqrt(S*S+C*C)),y=n/16*T*(4+n*(4-3*T)),b=Math.atan2(P*l,p*M-h*P*d)-(1-y)*n*S*(g+y*P*(R+y*M*(2*R*R-1)));Math.atan2(S,-C);return[180*I/Math.PI,t+180*b/Math.PI]}static CreateInstanceFrom(e){const t=new E;return t.mb=e.mb,t.sections=e.sections,t.isLE=e.isLE,t.positions=e.positions,t.xyz=e.xyz,t.lines=e.lines,t}}class R{static LoadArrayBuffer(e){let a=!0;const s=new DataView(e);s.getUint32(0,!0)>s.getUint32(0,!1)&&(a=!1);const r=R.ParseSectionTable(e,a);return r.sectionTable.forEach(((e,a)=>e.title=t.EMAll.DescType(e.type))),r}static ParseSectionTable(e,t){const s=new a(e);s.littleEndian=t;const r=s.parseBrief();return{dataView:s,sectionTable:r,littleEndian:t}}}return{EMAll:a,EMXYZ88:s,EMParamInstall:r,EMRuntimeParam:i,EMPosition:n,EMDepthDatagra:o,EMSoundSpeedProfile:c,EMPUID:l,EMNetworkAttitudeVelocity:u,EMClock:p,EMAttitude:h,EMSeabedImage:U,EMSeabedImage89:S,EMPUStatusOutput:d,EMRawRangeAngle78:T,EMExtra:f,GetParser:g,SliceToSection:function(e,t){return new DataView(t.buffer,e.offset,e.len+a.BYTE_LENGTH)},ParseDateTime:m,ParserContext:E,ParserTest:R}})(),a=(()=>{class t{static TYPES=[1];static IsMyType(e){return-1<t.TYPES.findIndex((t=>t===e))}static TITLE="BinHeader";static STRUCT_BINARY_HEADER3200=new Map([["jobIDNum","U4"],["lineNum","U4"],["reelNum","U4"],["tracesPEns","U2"],["auxTracesPEns","U2"],["interval","U2"],["intervalOrg","U2"],["numSamplePTrace","U2"],["numSamplePTraceOrg","U2"],["code","U2"],["ensFold","U2"],["traceSortingCode","U2"],["vertSumCode","U2"],["sweepFreqStart","U2"],["sweepFreqEnd","U2"],["sweepLen","U2"],["sweepTypeCode","U2"],["traceNumSweepChannel","U2"],["sweepTTLenStart","U2"],["sweepTTLenEnd","U2"],["taperType","U2"],["corelTrace","U2"],["binGainRec","U2"],["ampRecM","U2"],["measureSystem","U2"],["impulseSigPol","U2"],["vibPolCode","U2"],["extNumTracePEns","U4"],["extNumAuxTracePEns","U4"],["extNumSample","U4"],["extInterval","F8"],["extIntervalOrG","F8"],["extNumSamplePTraceOrg","U4"],["extEnsFold","U4"],["constant1234","U4"]]);static STRUCT_BINARY_HEADER3500=new Map([["majorRev","U1"],["minorRev","U1"],["fixedLenTrace","U2"],["numExtTextHDR","U2"],["numAddTraceHDR","U4"],["timeCode","U2"],["numTraceInFile","U8"],["offsetTrace","U8"],["numTrailerStanza","I4"]]);static SAMPLE_FORMAT_CODE=[[1,"4-byte IBM floating-point",4,"F"],[2,"4-byte, two's complement integer",4,"I"],[3,"2-byte, two's complement integer",2,"I"],[4,"4-byte fixed-point with gain (obsolete)",4,"I"],[5,"4-byte IEEE floating-point",4,"F"],[6,"8-byte IEEE floating-point",8,"F"],[7,"3-byte two's complement integer",3,"I"],[8,"1-byte, two's complement integer",1,"I"],[9,"8-byte, two's complement integer",8,"I"],[10,"4-byte, unsigned integer",4,"I"],[11,"2-byte, unsigned integer",2,"I"],[12,"8-byte, unsigned integer",8,"I"],[15,"3-byte, unsigned integer",3,"I"],[16,"1-byte, unsigned integer",1,"I"]];static FindSampleFormatCode(e){return t.SAMPLE_FORMAT_CODE.find((t=>e===t[0]))}static DATE_TIME_CODE={1:"Local",2:"GMT",3:"Other",4:"UTC",5:"GPS"};static ReadBinaryHeader3200=e.CreateReader(t.STRUCT_BINARY_HEADER3200);static ReadBinaryHeader3500=e.CreateReader(t.STRUCT_BINARY_HEADER3500);static ParseSectionDescribe(a,s,r){const i=new Map;t.ReadBinaryHeader3200._toDescribeMap(a,s,i,r);const n=300-t.ReadBinaryHeader3200._size;for(let t=0;t<n/4;t++)i.set(`un_${t+1}`,e.Describe(0,"U",4));return t.ReadBinaryHeader3500._toDescribeMap(a,s+300,i,r),i}static SOA2Degree(e){return e/3600}parseDetail(){this.setLittleEndian(!1);const e=this.parse(SegY.STRUCT_BINARY_HEADER3200,3200),t=this.parse(SegY.STRUCT_BINARY_HEADER3500,3500);Object.keys(t).forEach(((t,a)=>e[t]=a)),this.saveBrief(e),this.setParseOffset(3600);const a=[];if(SegY.SAMPLE_FORMAT_CODE.IBM_FP_4===e.code||SegY.SAMPLE_FORMAT_CODE.IEEE_FP_4===e.code){for(this.setLittleEndian(!1);this.parseOffset<this.byteLength;){const e=this.parseTraceOne();a.push(e)}return{binHeader:e,traces:a}}alert("Only 32bit floating point implemented, please report")}parseTraceOne(){const e=this.parse(SegY.STRUCT_TRACE_HEADER),t={},a=new Date;if(a.setUTCFullYear(e.year),a.setUTCMonth(0),a.setUTCDate(e.day),a.setUTCHours(e.hour),a.setUTCMinutes(e.minute),a.setUTCSeconds(e.second),a.setUTCMilliseconds(0),t.date=a,t.dateBase=SegY.DATE_TIME_CODE[e.timeCode],2===e.coordUnit){const a=e.srcCoordX/36e5,s=e.srcCoordY/36e5;t.srcPos=[s,a]}this.addParseOffset(10);const s=[];for(let t=0;t<e.numSample;t++){const e=this.getFloat32(this.parseOffset);s.push(e),this.parseOffset=this.parseOffset+4}return{header:e,parsedHeader:t,data:s}}getPrettyPrintBinHeader(){const e=this.getBrief();if(!e)return"Not yet parsed, or invalid";return[`Major: ${e.majorRev}, Minor: ${e.minorRev}`,`Data format code: ${e.code} - ${this.getCodeStr(e.code)}`,`Sample per trace: ${e.numSamplePTrace}`,`Interval: ${e.interval}us`].join("\n")}getCodeStr(e){let t="";return Object.keys(SegY.SAMPLE_FORMAT_CODE).forEach((a=>{SegY.SAMPLE_FORMAT_CODE[a]===e&&(t=a)})),t}}class a{static TYPES=[2];static IsMyType(e){return-1<a.TYPES.findIndex((t=>t===e))}static TITLE="Trace";static STRUCT_TRACE_HEADER=new Map([["traceSeqLine","U4"],["traceSeqFile","U4"],["orgFieldRecNum","U4"],["traceNumOrg","U4"],["energySrc","U4"],["ensNum","U4"],["traceNumEns","U4"],["traceIDCode","U2"],["numVertSum","U2"],["numHoriSum","U2"],["dataUse","U2"],["distCent","U4"],["elevRecv","U4"],["surfElev","U4"],["srcDepth","U4"],["seisDatumRecv","U4"],["seisDatumSrc","U4"],["watColHeiSrc","U4"],["watColHeiRecv","U4"],["scalarElev","I2"],["scalarCoord","I2"],["srcCoordX","I4"],["srcCoordY","I4"],["grpCoordX","I4"],["grpCoordY","I4"],["coordUnit","U2"],["weatherVel","U2"],["subWeatherVel","U2"],["upSrcMS","U2"],["upGrpMS","U2"],["srcCorrMS","U2"],["grpCorrMS","U2"],["totMS","U2"],["lagAMS","U2"],["lagBMS","U2"],["delayRecMS","U2"],["muiteStartMS","U2"],["muiteEndMS","U2"],["numSample","U2"],["intervalSample","U2"],["gainType","U2"],["instGain","U2"],["instInitGain","U2"],["correlated","U2"],["sweepFreqS","U2"],["sweepFreqE","U2"],["sweepLen","U2"],["sweepType","U2"],["sweepTraceLenS","U2"],["sweepTraceLenE","U2"],["taperType","U2"],["aliasFFreq","U2"],["aliasFSlope","U2"],["notchFFreq","U2"],["notchFSlope","U2"],["lcFreq","U2"],["hcFreq","U2"],["lcSlope","U2"],["hcSlope","U2"],["year","U2"],["day","U2"],["hour","U2"],["minute","U2"],["second","U2"],["timeCode","U2"],["traceWeiFac","U2"],["geoGNRoll","U2"],["geoGNTrace","U2"],["geoGNLTrace","U2"],["gapSize","U2"],["overTravel","U2"],["XcoordEns","U4"],["YcoordEns","U4"],["PSinline","U4"],["PScrossline","U4"],["shotpoint","U4"],["scalarShot","U2"],["traceUnit","I2"],["transC","U8"],["transUnit","I2"],["id","U2"],["scalarTimes","U2"],["srcType","I2"],["srcEnergyDir","U2"],["sourceM1","U4"],["sourceM2","U2"],["srcUnit","I2"],["useless1","U4"],["useless2","U4"],["useless3","U2"]]);static ReadTraceHeader=e.CreateReader(a.STRUCT_TRACE_HEADER);static ParseSectionDescribe4F(t,s,r){const i=new Map;a.ReadTraceHeader._toDescribeMap(t,s,i,r);const n=i.get("numSample").v;for(let o=0;o<n;o++){const n=s+a.ReadTraceHeader._size+4*o,c=t.getFloat32(n,r);i.set("dataF4_"+o,e.Describe(c,"F4",4))}return i}static ParseSection(e,t,s){const r=a.ReadTraceHeader.traceSeqLine(e,t,s),i=a.ReadTraceHeader.numSample(e,t,s),n=a.ReadTraceHeader.intervalSample(e,t,s),o=a.ReadTraceHeader.year(e,t,s),c=a.ReadTraceHeader.day(e,t,s),l=a.ReadTraceHeader.hour(e,t,s),d=a.ReadTraceHeader.minute(e,t,s),u=a.ReadTraceHeader.second(e,t,s),p=a.ReadTraceHeader.timeCode(e,t,s),h=new Date;h.setUTCFullYear(o),h.setUTCMonth(0),h.setUTCDate(c),h.setUTCHours(l),h.setUTCMinutes(d),h.setUTCSeconds(u),h.setUTCMilliseconds(0);let U=0,S=0;return 2===a.ReadTraceHeader.coordUnit(e,t,s)&&(S=a.ReadTraceHeader.srcCoordX(e,t,s)/36e5,U=a.ReadTraceHeader.srcCoordY(e,t,s)/36e5),[r,i,n,h,p,U,S]}static ParseSectionData4F(e,t,s){const r=a.ReadTraceHeader.numSample(e,t,s),i=[];for(let n=0;n<r;n++){const r=t+a.ReadTraceHeader._size+4*n,o=e.getFloat32(r,s);i.push(o)}return i}static ParseSectionData(e,s,r,i){const n=t.SAMPLE_FORMAT_CODE.find((e=>e[0]===i));if(n)return 4===n[2]&&"F"===n[3]?a.ParseSectionData4F(e,s,r):void 0}}class s{static LoadArrayBuffer(e){let t=!0;const a=new DataView(e);let r=a.getUint32(3204,!0),i=a.getUint32(3204,!1);r>i?t=!1:r===i&&(r=a.getUint16(3212,!0),i=a.getUint16(3212,!1),r>i&&(t=!1));return s.ParseSectionTable(e,t)}static ParseSectionTable(e,s){const r={dataView:void 0,sections:void 0,isLE:s,bin:void 0},i=[],n=new DataView(e),o=t.ParseSectionDescribe(n,3200,s);r.dataView=n,r.bin=o;const c={type:t.TYPES[0],title:t.TITLE,offset:3200,len:400};i.push(c);const l=o.get("offsetTrace").v;let d=3600+parseInt(l),u=t.SAMPLE_FORMAT_CODE[4];const p=t.SAMPLE_FORMAT_CODE.find((e=>o.get("code").v===e[0]));void 0===p?(console.error("Critical error, sample format code is Mandatory for all data but its empty"),console.info("Just proceed with 4 byte floating point")):u=p;const h=u[2],U=a.ReadTraceHeader._size;let S=d;for(;S<n.byteLength;){const e=U+a.ReadTraceHeader.numSample(n,S,s)*h,t={type:a.TYPES[0],title:a.TITLE,offset:S,len:e};i.push(t),S+=e}return r.sections=i,r}}const r=(()=>{const e=new Map;return[t,a].forEach((t=>{t.TYPES.forEach((a=>{e.set(a,t)}))})),t=>e.get(t)})();return{SEGY:t,SEGYTrace:a,GetParser:r,SliceToSection:function(e,t){return new DataView(t.buffer,e.offset,e.len)},ParserContext:class{constructor(){this.dataView=void 0,this.sections=void 0,this.isLE=!0,this.binHeader=void 0,this.sampleCode=0,this.sampleCodeFound=void 0,this.traces=[]}load(e){const a=s.LoadArrayBuffer(e);this.dataView=a.dataView,this.sections=a.sections,this.isLE=a.isLE,this.binHeader=a.bin,this.sampleCode=this.binHeader.get("code").v,0<this.sampleCode&&(this.sampleCodeFound=t.FindSampleFormatCode(this.sampleCode))}parseTraces(){const e=this.isLE,t=this.sections.filter((e=>a.IsMyType(e.type))).map((t=>a.ParseSectionData(this.dataView,t.offset,e,this.sampleCode)));return this.traces=t,this.traces}clearMemory(){this.dataView=void 0,this.sections=[],this.traces=[]}},ParserTest:s}})(),s=(()=>{function e(e,t){const a=t.match(/([^\.\[]*)/g),s=[];if(a.forEach((e=>{0!==e.length&&(e.match(/(\d+)\]$/)?s.push(parseInt(e)):s.push(e))})),0===s.length)return void console.log(`getValueFromObject Invalid expression ${e}, '${t}'`);let r=e;return s.forEach((e=>r=r[e])),r}class t{constructor(){this.files={bl:void 0,hdr:void 0,hex:void 0,xmlcon:void 0},this.instance={bl:void 0,hdr:void 0,hex:void 0,xmlcon:void 0},this.name=void 0}addFile(e){const t=e.name.match(/^(.*)\.([^.]*)$/i);if(t){const a=t[1],s=t[2].toLowerCase();-1!==["hex","bl","hdr","xmlcon"].findIndex((e=>s===e))&&(this.files[s]=e,this.name=a)}}getName(){return this.name}async parse(){if(this.files.hex){const e=new n;this.instance.hex=e,e.setParent(this),await e.setFile(this.files.hex)}if(this.files.xmlcon){const e=new o;this.instance.xmlcon=e,e.setParent(this),await e.setFile(this.files.xmlcon)}if(this.files.hdr){const e=new s;this.instance.hdr=e,e.setParent(this),await e.setFile(this.files.hdr)}if(this.files.bl){const e=new r;this.instance.bl=e,e.setParent(this),await e.setFile(this.files.bl)}}unload(){}getHex(){return this.instance.hex}getXmlcon(){return this.instance.xmlcon}getHdr(){return this.instance.hdr}getBl(){return this.instance.bl}}class a{constructor(){this.parent=void 0}setParent(e){this.parent=e}getHex(){if(this.parent)return this.parent.getHex()}getXmlcon(){if(this.parent)return this.parent.getXmlcon()}getBl(){if(this.parent)return this.parent.getBl()}getHdr(){if(this.parent)return this.parent.getHdr()}}class s extends a{constructor(){super(),this.file=void 0,this.parsedHDR=void 0}static parseHDR(e){const t={bytes:e.match(/Number of Bytes Per Scan = (.*)$/m),lat:e.match(/NMEA Latitude = (.*)$/m),lng:e.match(/NMEA Longitude = (.*)$/m),utc:e.match(/NMEA UTC \(Time\) = (.*)$/m),scanAvg:e.match(/Number of Scans Averaged by the Deck Unit = (.*)$/m)};if(t.bytes&&(t.bytes=parseInt(t.bytes[1])),t.lat){t.nmeaLat=t.lat[1];const e=t.lat[1].match(/(\d*) ([\d\.]*) (N|S)/);if(e){const a=parseInt(e[1]),s=parseFloat(e[2])/60;t.lat=a+s,"S"===e[3]&&(t.lat=-1*t.lat)}}if(t.lng){t.nmeaLng=t.lng[1];const e=t.lng[1].match(/(\d*) ([\d\.]*) (E|W)/);if(e){const a=parseInt(e[1]),s=parseFloat(e[2])/60;t.lng=a+s,"W"===e[3]&&(t.lng=-1*t.lng)}}if(t.utc){const e=t.utc[1];let a=new Date(e);a=new Date(a.getTime()+60*a.getTimezoneOffset()*1e3*-1),t.nmeaUTC=e,t.utc=a}return t.scanAvg&&(t.scanAvg=parseInt(t.scanAvg[1])),t}async setFile(e){return new Promise(((t,a)=>{const s=new FileReader;s.onloadend=()=>{this.setDataSource(s.result),t()},s.readAsText(e)}))}setDataSource(e){this.dataSource=e;const t=s.parseHDR(this.dataSource);this.parsedHDR=t}getParsedHDR(){return this.parsedHDR}}class r extends a{constructor(){super(),this.file=void 0,this.dataSource=void 0}static parseBL(e){const t={};let a=0;e.split("\n").forEach((e=>{const s=r.parseBLLine(e);s&&(a++,t[s.fired]=s)}));return{countFired:a,fired:t}}static parseBLLine(e){const t=e.split(",");if(5!==t.length)return!1;return{fired:parseInt(t[1]),dateStr:t[2],rawLineS:parseInt(t[3]),rawLineE:parseInt(t[4])}}static parseBLHEX(e,t){e.fired&&t&&Object.keys(e.fired).forEach((a=>{const s=e.fired[a],r=t.parseValue(s.rawLineS),i=r.value.altimeter,n=r.value.f2depth,o=r.value.f0,c=r.value.f1psu;i&&(s.altimeter=r.value.altimeter),s.depth=n,s.t=o,s.s=c}))}async setFile(e){return new Promise(((t,a)=>{const s=new FileReader;s.onloadend=()=>{this.setDataSource(s.result),t()},s.readAsText(e)}))}setDataSource(e){this.dataSource=e;const t=r.parseBL(this.dataSource);if(!this.getHex())return console.error("CTDBL.setDataSource : got no hex, can not proceed"),void console.log(t);r.parseBLHEX(t,this.getHex()),this.parsedBL=t}getParsedBL(){return this.parsedBL}}class n extends a{static TIME_BASE_MS=9466848e5;constructor(){super(),this.file=void 0,this.dataSource=void 0,this.parsingDesc={countFreq:3,countAD:0,countADWords:0,surfacePar:!1,nmeaPosition:!1,nmeaDepth:!1,nmeaTime:!1,scanTime:!1,scanAvg:-99}}async setFile(e){const t=await e.text();this.setDataSource(t)}setDataSource(e){this.updateParsingDescription();const t=n.SplitEdge(e);this.header=t.header,this.body=t.body,this.bodyLength=t.bodyLength,this.lineLength=t.lineLength,this.EOLLength=t.EOLLength,this.parseHeader()}static SplitEdge(e){const t=e.slice(0,2048);let a;for(let e=0;e<t.length-1;e++){if(10===t.charCodeAt(e)){if(42!==t.charCodeAt(e+1)){a=e;break}}}if(!a)return;const s=t.slice(0,a),r=e.slice(a+1);let i=-1,n=-1,o=1;for(let e=0;e<1024;e++)if(10===r.charCodeAt(e)){n=e+1,i=r.length/n;break}13===r.charCodeAt(n-2)&&(o=2);return{header:s,body:r,bodyLength:i,lineLength:n,EOLLength:o,getLine:e=>{if(e>=i)return;const t=n*e,a=t+n;return r.slice(t,a-o)}}}static Ascii2ta(e){const t=new Uint8Array(e.length/2);let a=0;for(let s=0;s<e.length;s+=2){const r=(parseInt(e[s],16)<<4)+parseInt(e[s+1],16);t[a++]=r}return t}parseHeader(){const e=s.parseHDR(this.header);if(this.parsedHDR=e,1===this.parsedHDR.scanAvg){const e=parseInt(this.getLength()/24);this.parsedHDR.scanDuration=e}else this.parsedHDR.scanDuration=-99}getParsedHDR(){return this.parsedHDR}getRaw(e){if(e>=this.bodyLength)return;const t=this.lineLength*e,a=t+this.lineLength,s=this.body.slice(t,a-this.EOLLength);return n.Ascii2ta(s)}parseValue(e){const t=this.getXmlcon();if(!t)return console.error("CTDHex.getValue : No xmlcon given"),!1;const a=t.getParsedMap(),s=t.findSensorKeyByType("Altimeter"),r=this.parseRaw(e),i=r.psT*a.f2.coef.AD590M+a.f2.coef.AD590B,n=a.f0.getValue(r.f0).DegreeC,o=a.f2.getValue(r.f2,i).psi,l=c.PSI2Decibar(o),d=c.DECIBAR2Depth(l,r.lat),u=a.f1.getValue(r.f1,n,l).SPerM,p=c.COND2PSU(u,n,l);if(r.value={f0:n,f1:u,f1psu:p,f2:o,f2decibar:l,f2depth:d},s){const e=r[s],t=a[s].getValue(e).meter;r.value.altimeter=t}return r}parseRaw(e){const t=this.getRaw(e);return this._parseBasic(t)}parseDepthOnly(e){const t=this.getRaw(e);return this._parseDepthOnly(t)}_parseBasic(e){const t={},a=this.parsingDesc;let s=0;for(let r=0;r<a.countFreq;r++)t["f"+r]=256*e[s++]+e[s++]+e[s++]/256;const r=[];for(let t=0;t<a.countADWords;t++)r.push(e[s++]<<16|e[s++]<<8|e[s++]);let i=0;if(r.forEach((e=>{t["v"+i]=5*(1-(e>>>12)/4095),i++,t["v"+i]=5*(1-(4095&e)/4095),i++})),a.surfacePar){s++;const a=e[s++]<<8|e[s++];t.spV=(4095&a)/819}if(a.nmeaPosition){let a=(65536*e[s++]+256*e[s++]+e[s++])/5e4,r=(65536*e[s++]+256*e[s++]+e[s++])/5e4;const i=e[s++];1===i&128&&(a*=-1),1===i&64&&(r*=-1),t.lat=a,t.lng=r}if(a.nmeaTime){const a=e[s++]|e[s++]<<8|e[s++]<<16|e[s++]<<24,r=n.TIME_BASE_MS+1e3*a;t.date=new Date(r),t.dateMS=r}const o=e[s++]<<8|e[s++];return t.psT=o>>>4,t.CTDStatus={pump:1==(1&o),bot:2==(2&o),ws:4==(4&o),cr:8==(8&o),s:(15&o).toString(2).padStart(4,"0")},t.moduloCount=e[s++],t}_parseDepthOnly(e){const t={},a=this.parsingDesc;let s=0;if(s=6,t.f2=256*e[s++]+e[s++]+e[s++]/256,s=3*a.countFreq,s+=3*a.countADWords,a.surfacePar&&(s+=3),a.nmeaPosition){let a=(65536*e[s++]+256*e[s++]+e[s++])/5e4,r=(65536*e[s++]+256*e[s++]+e[s++])/5e4;const i=e[s++];1===i&128&&(a*=-1),1===i&64&&(r*=-1),t.lat=a,t.lng=r}a.nmeaTime&&(s+=4);const r=e[s++]<<8|e[s++];return t.psT=r>>>4,t}updateParsingDescription(){const e=this.getXmlcon();if(!e)return;const t=e.getInstrument(),a=5-t.freqSuppress,s=8-t.voltSuppress,r=s/2,i=1===t.surfacePar,n=1===t.nmeaPosition,o=1===t.nmeaDepth,c=1===t.nmeaTime,l=1===t.scanTime;this.parsingDesc={countFreq:a,countAD:s,countADWords:r,surfacePar:i,nmeaPosition:n,nmeaDepth:o,nmeaTime:c,scanTime:l,scanAvg:t.scanAvg}}getLength(){return this.bodyLength}getParsingDescription(){return this.parsingDesc}getParsedHDR(){return this.parsedHDR}unload(){this.body=void 0}}class o extends a{static SENSOR_MAP=[{sensorID:3,attribute:"ConductivitySensor",title:"Conductivity",coef:{CPcor:"Coefficients[1].CPcor",CTcor:"Coefficients[1].CTcor",G:"Coefficients[1].G",H:"Coefficients[1].H",I:"Coefficients[1].I",J:"Coefficients[1].J",WBOTC:"Coefficients[1].WBOTC"},getValue:(e,t,a,s)=>{const r=t/1e3;return{SPerM:(e.G+e.H*Math.pow(r,2)+e.I*Math.pow(r,3)+e.J*Math.pow(r,4))/10*(1+e.CTcor*a+e.CPcor*s)}}},{sensorID:55,attribute:"TemperatureSensor",title:"Temperature",coef:["F0","G","H","I","J","Offset","Slope","UseG_J"],getValue:(e,t)=>{const a=e.F0/t,s=Math.log(a);return{DegreeC:1/(e.G+e.H*s+e.I*Math.pow(s,2)+e.J*Math.pow(s,3))-273.15}}},{sensorID:45,attribute:"PressureSensor",title:"Pressure",coef:["AD590B","AD590M","C1","C2","C3","D1","D2","Offset","Slope","T1","T2","T3","T4","T5"],getValue:(e,t,a)=>{const s=e.C1+e.C2*a+e.C3*Math.pow(a,2),r=e.D1+e.D2*a,i=e.T1+e.T2*a+e.T3*Math.pow(a,2)+e.T4*Math.pow(a,3)+e.T5*Math.pow(a,4),n=1/t*1e6,o=s*(1-Math.pow(i,2)/Math.pow(n,2))*(1-r*(1-Math.pow(i,2)/Math.pow(n,2)));return{psia:o,psi:o-14.7}}},{sensorID:38,attribute:"OxygenSensor",title:"Oxygen",coef:{A:"CalibrationCoefficients[1].A",B:"CalibrationCoefficients[1].B",C:"CalibrationCoefficients[1].C",D0:"CalibrationCoefficients[1].D0",D1:"CalibrationCoefficients[1].D1",D2:"CalibrationCoefficients[1].D2",E:"CalibrationCoefficients[1].E",H1:"CalibrationCoefficients[1].H1",H2:"CalibrationCoefficients[1].H2",H3:"CalibrationCoefficients[1].H3",Soc:"CalibrationCoefficients[1].Soc",Tau20:"CalibrationCoefficients[1].Tau20",offset:"CalibrationCoefficients[1].offset"}},{sensorID:71,attribute:"WET_LabsCStar",title:"Transmissometer",coef:["B","M","PathLength"]},{sensorID:20,attribute:"FluoroWetlabECO_AFL_FL_Sensor",title:"Fluorometer",coef:["ScaleFactor","Vblank"]},{sensorID:42,attribute:"PAR_BiosphericalLicorChelseaSensor",title:"PAR_Biospherical",coef:["B","M","Multiplier","Offset"]},{sensorID:0,attribute:"AltimeterSensor",title:"Altimeter",coef:["ScaleFactor","Offset"],getValue:(e,t)=>({meter:300*t/e.ScaleFactor+e.Offset})},{sensorID:27,attribute:"NotInUse",title:"NotInUse"}];constructor(){super(),this.file=void 0,this.dataSource=void 0,this.parsedMap={f0:void 0,f1:void 0,f2:void 0,f3:void 0,f4:void 0,v0:void 0,v1:void 0,v2:void 0,v3:void 0,v4:void 0,v5:void 0,v6:void 0,v7:void 0}}static parseXml(e){var t=null;if(window.DOMParser)try{t=(new DOMParser).parseFromString(e,"text/xml")}catch(e){t=null}return t}static xmlToJson(e){var t={};if(1==e.nodeType){if(e.attributes.length>0){t["@attributes"]={};for(var a=0;a<e.attributes.length;a++){var s=e.attributes.item(a);t["@attributes"][s.nodeName]=s.nodeValue}}}else 3==e.nodeType&&(t=e.nodeValue);if(e.hasChildNodes())for(var r=0;r<e.childNodes.length;r++){var i=e.childNodes.item(r),n=i.nodeName;if(void 0===t[n])t[n]=o.xmlToJson(i);else{if(void 0===t[n].push){var c=t[n];t[n]=[],t[n].push(c)}t[n].push(o.xmlToJson(i))}}return t}static parseCTDXMLConfig(e){const t=[];try{e.SBE_InstrumentConfiguration.Instrument.SensorArray.Sensor.forEach(((e,a)=>{const s=o.parseSensor(e);s&&(s.key=a,t.push(s))}))}catch(e){console.log(e)}return t}static parseSensor(t){const a=t["@attributes"].SensorID,s=o.SENSOR_MAP.find((e=>e.sensorID==a));if(!s)return console.warn(`CTDXMLCON.parseSensor sensor ID not found ${a}`),!1;const r=t[s.attribute],i=r.SerialNumber["#text"];let n,c,l=r.CalibrationDate["#text"];return l||(l=""),s.coef&&("function"==typeof s.coef?n=s.coef(r):"object"==typeof s.coef&&(n={},Array.isArray(s.coef)?s.coef.forEach((t=>{const a=e(r,t);a&&a.hasOwnProperty("#text")?n[t]=parseFloat(a["#text"]):(console.error("CTDXMLCON.parseSensor Invalid Coef"),console.error(t))})):Object.keys(s.coef).forEach((t=>{const a=s.coef[t],i=e(r,a);i&&i.hasOwnProperty("#text")?n[t]=parseFloat(i["#text"]):(console.error("CTDXMLCON.parseSensor Invalid Coef"),console.error(t))})))),s.getValue&&"function"==typeof s.getValue&&(c=(...e)=>s.getValue(n,...e)),{id:a,type:s.title,serial:i,calibration:l,coef:n,getValue:c}}async setFile(e){return new Promise(((t,a)=>{const s=new FileReader;s.onloadend=()=>{this.setDataSource(s.result),t()},s.readAsText(e)}))}setDataSource(e){const t=o.parseXml(e),a=o.xmlToJson(t);this.dataSource=a,this.parsed=o.parseCTDXMLConfig(a);const s=a.SBE_InstrumentConfiguration.Instrument;this.instrument={freqSuppress:parseInt(s.FrequencyChannelsSuppressed["#text"]),voltSuppress:parseInt(s.VoltageWordsSuppressed["#text"]),nmeaDepth:parseInt(s.NmeaDepthDataAdded["#text"]),nmeaPosition:parseInt(s.NmeaPositionDataAdded["#text"]),nmeaTime:parseInt(s.NmeaTimeAdded["#text"]),scanTime:parseInt(s.ScanTimeAdded["#text"]),surfacePar:parseInt(s.SurfaceParVoltageAdded["#text"]),scanAvg:parseInt(s.ScansToAverage["#text"])},["f0","f1","f2","f3","f4","v0","v1","v2","v3","v4","v5","v6","v7"].forEach(((e,t)=>{const a=this.getSensorAt(t);a&&"NotInUse"!==a.type&&(this.parsedMap[e]=a)}));const r=this.getHex();r&&r.updateParsingDescription()}getInstrument(){return this.instrument}getSensorAt(e){if(this.parsed)return e<this.parsed.length?this.parsed[e]:void 0;console.error(`CTDXMLCON.getSensorAt Not yet parsed ${e}`)}getParsedMap(){return this.parsedMap}findSensorKeyByType(e){const t=this.getParsedMap();if(!t)return console.log("CTDXmlcon.findSensorType : no xml parsed"),!1;let a;return Object.keys(t).forEach((s=>{const r=t[s];r&&e===r.type&&(a=s)})),a}}class c{static D="&deg;";static DC="&deg;C";static SpM="S/m";static PSU="PSU";static M="m";static MpS="m/s";static PSI2Decibar(e){return.689476*e}static DECIBAR2Depth(e,t){let a,s,r;return a=Math.sin(t/57.29578),a*=a,r=9.780318*(1+(.0052788+236e-7*a)*a)+1092e-9*e,s=(((-182e-17*e+2.279e-10)*e-22512e-9)*e+9.72659)*e,r&&(s/=r),s}static COND2PSU(e,t,a){const s=[.008,-.1692,25.3851,14.0941,-7.0261,2.7081],r=[5e-4,-.0056,-.0066,-.0375,.0636,-.0144];let i,n,o,c,l,d,u,p,h;if(e<=0)return 0;for(i=(e*=10)/42.914,p=1+.03426*t+4464e-7*t*t+.4215*i+-.003107*i*t,p&&(o=1+a*(207e-7+a*(3989e-18*a-6.37e-10))/p),p=o*(.6766097+t*(.0200564+t*(.0001104259+t*(1.0031e-9*t-6.9698e-7)))),p&&(n=i/p),n<=0&&(n=1e-6),l=d=0,h=0;h<6;h++)c=Math.pow(n,h/2),l+=s[h]*c,d+=r[h]*c;return p=1+.0162*(t-15),u=p?l+d*(t-15)/p:-99,u}static SVChenMillero(e,t,a){let s,r,i,n,o,c,l,d,u,p,h,U,S,T,f,m,D;return T=a/10,e<0&&(e=0),f=Math.sqrt(e),m=.001727-79836e-10*T,d=73637e-9+1.7945e-7*t,l=-.01922-442e-7*t,c=l+d*T,o=(-3389e-16*t+6649e-15)*t+1.1e-10,n=((7988e-15*t-1.6002e-10)*t+9.1041e-9)*t-3.9064e-7,i=(((-2.0122e-10*t+1.0507e-8)*t-6.4885e-8)*t-1258e-8)*t+94742e-9,r=(((-3.21e-8*t+2006e-9)*t+7164e-8)*t-.01262)*t+1.389,s=((o*T+n)*T+i)*T+r,S=(-23643e-16*t+3.8504e-10)*t-9.7729e-9,U=(((10405e-16*t-2.5335e-10)*t+2.5974e-8)*t-17107e-10)*t+3126e-8,h=(((-6.1185e-10*t+1.3621e-7)*t-81788e-10)*t+68982e-8)*t+.153563,p=((((3.1464e-9*t-1478e-9)*t+3342e-7)*t-.0580852)*t+5.03711)*t+1402.388,u=((S*T+U)*T+h)*T+p,D=u+(s+c*f+m*e)*e,D}static PrettyDepth(e,t=1,a,s){return c.PrettyPrint(e,c.M,t,a,s)}static PrettyTemp(e,t,a,s){return c.PrettyPrint(e,c.DC,t,a,s)}static PrettySal(e,t,a,s){return c.PrettyPrint(e,c.PSU,t,a,s)}static PrettyPrint(e,t,a=4,s=!0,r=!0){const i=c.Round(e,a);let n="";return n=s?i.toFixed(a):String(i),r&&(n+=" "),t&&(n+=t),n}static PrettySensor(e,t=3){return 0===t?e.type+" "+e.serial:e.type.slice(0,t)+" "+e.serial}static Round(e,t){const a="e+"+t,s="e-"+t;return+(Math.round(e+a)+s)}}return{CTDFileList:class{constructor(){this.listFiles=[],this.mapGroup={}}addFile(e){const a=e.name.match(/^(.*)\.([^.]*)$/i);if(a){const s=a[1].toLowerCase(),r=a[2].toLowerCase();-1!==["hex","bl","hdr","xmlcon"].findIndex((e=>r===e))&&(this.listFiles.push(e),this.mapGroup.hasOwnProperty(s)||(this.mapGroup[s]=new t),this.mapGroup[s].addFile(e))}}getGroup(e){if(this.mapGroup.hasOwnProperty(e))return this.mapGroup[e]}getNames(){return Object.keys(this.mapGroup)}getGroups(){return Object.values(this.mapGroup)}},CTDGroup:t,CTDChild:a,CTDHex:n,CTDXMLCON:o,SeaConvert:c,SeaParser:class{constructor(){this.group=void 0,this.hex=void 0,this.xmlcon=void 0,this.sensors=void 0}setGroup(e){this.group=e,this.setHex(e.getHex()),this.setXmlcon(e.getXmlcon())}setHex(e){this.hex=e}setXmlcon(e){this.xmlcon=e,this.sensors=e.getParsedMap()}parseDownUp(e){if(!this.hex||!this.xmlcon)return console.error("SeaParser.parseBrief no hex or no xmlcon"),!1;const t=this.hex.getLength();e||(e=parseInt(t/10));let a=e,s=0,r=t,i=0,n=null,o=0;for(;e===a;){i=parseInt((r-s)/e),i=i<1?1:i,n=this._loopInF2(s,r,i);let t=Math.floor(n-e/2),a=Math.ceil(n+e/2);if(s=t<s?s:t,r=a>r?r:a,e>r-s&&(e=r-s),o++,o>100){console.error("Invalid condition, program in infinite loop");break}}return{d:[0,n],u:[n+1,t-1]}}_loopInF2(e,t,a){let s=-999,r=-1;for(let i=e;i<=t;i+=a){const e=this.hex.parseDepthOnly(i);s<e.f2&&(s=e.f2,r=i)}return i}parseDepthTest(){const e=this.hex.getLength();let t,a,s=-1,r=-1;const i=(new Date).getTime();for(let a=0;a<e;a++){const e=this.hex.parseRaw(a);s<e.f2&&(s=e.f2,t=e)}const n=(new Date).getTime()-i,o=(new Date).getTime();for(let t=0;t<e;t++){const e=this.hex.parseDepthOnly(t);r<e.f2&&(r=e.f2,a=e)}const c=(new Date).getTime()-o;console.log(`count: ${e}, rawMS: ${n}, depthMS: ${c}`),console.log(`maxRaw ${s}, maxDepth ${r}`),console.log(t,a)}parseTest(){this.parseDownUp(),this.parseDepthTest()}}}})(),r=(()=>{const t=-32768;class a extends DataView{static TYPES=[0];static IsMyType(e){return-1<a.TYPES.findIndex((t=>t===e))}static STRUCT_HEADER=new Map([["hID","U2"],["noBytesEns","U2"],["spare01","U1"],["noDataTypes","U1"]]);static STRUCT_DATA_TYPES=new Map([["addr","U2"]]);static ReadHeader=e.CreateReader(a.STRUCT_HEADER);static ReadDataTypes=e.CreateReader(a.STRUCT_DATA_TYPES);static ParseSection(e,t=0,s=!0){const r={};a.ReadHeader._toObject(e,t,["hID","noBytesEns","noDataTypes"],r,s);const i=t+a.ReadHeader._size,n=[];for(let t=0;t<r.noDataTypes;t++){const a=i+2*t,r=e.getUint16(a,s);n.push(r)}return r.offsets=n,r}static ParseSectionDescribe(t,s,r){const i=new Map;a.ReadHeader._toDescribeMap(t,s,i,r);const n=i.get("noDataTypes").v;let o=a.ReadHeader._size;new Map;for(let a=0;a<n;a++){const n=s+(o+2*a),c=t.getUint16(n,r),l=e.Describe(c,"U2",2);i.set(`addr_${a}`,l)}return i}}class s{static TYPES=[0];static IsMyType(e){return-1<s.TYPES.findIndex((t=>t===e))}static FIXED_LEADER=new Map([["hID","U2"],["fwVer","U1"],["fwRev","U1"],["sysCfg","U2"],["flagSim","U1"],["lagLen","U1"],["noBeams","U1"],["noCells","U1"],["pingsPEns","U2"],["dptCellLen","U2"],["blankTrans","U2"],["profMode","U1"],["lowCorrThresh","U1"],["noCodeReps","U1"],["PGMin","U1"],["EVMax","U2"],["TPPm","U1"],["TPPs","U1"],["TPPHund","U1"],["coordTransf","U1"],["hdtAli","U2"],["hdtBias","U2"],["sensorSrc","U1"],["sensorsAvail","U1"],["bin1Dist","U2"],["xmitPulseLen","U2"],["WPRefAvg","U2"],["falseTgtThresh","U1"],["spare02","U1"],["transLagDist","U2"],["cpuSerial","U8"],["sysBandwidth","U2"],["sysPwr","U1"],["spare03","U1"],["insSerial","U4"],["beamAngle","U1"]]);static SYSTEM=[[0,"75kHz"],[1,"150kHz"],[2,"300kHz"],[3,"600kHz"],[4,"1200kHz"],[5,"2400kHz"],[6,"38kHz"]];static COORD=[[0,"No transformation"],[8,"Instrument coordinates"],[16,"Ship coordinates"],[24,"Earth coordinate"]];static SENSOR_SRC=[[64,"Calculates EC (Speed of sound) from ED, ES, ET"],[32,"Uses ED from depth sensor"],[16,"Uses EH from transducer heading sensor"],[8,"Uses EP from transducer pitch sensor"],[4,"Uses ER from transducer roll sensor"],[2,"Uses ES (Salinity) from transducer conductivity sensor"],[1,"Uses ET from transducer temperature sensor"]];static ParseCoordTransform(e){const t=24&e,a=4&e,r=2&e,i=1&e,n=s.COORD.find((e=>e[0]===t)),o=n?n[1]:S.UNHANDLED_STR+` value : ${t}`,c=0<a,l=0<r,d=0<i;return{type:t,typeStr:o,tilt:c,tiltStr:c?"Tilt pitch roll used":"Tilt pitch roll not used",beam3:l,beam3Str:l?"3-Beam solution used":"3-Beam solution not used",binMapping:d,binMappingStr:d?"Bin mapping used":"Bin mapping not used"}}static ParseSysConfig(e){const t=255&e,a=(65280&e)>>8,r=7&t,i=8&t,n=48&t,o=64&t,c=128&t,l=s.SYSTEM.find((e=>e[0]===r)),d=l?l[1]:S.UNHANDLED_STR+` value : ${r.toString(2)}`,u=0<i?"CONVEX BEAM PAT":"CONCAVE BEAM PAT";let p=S.UNHANDLED_STR;0===n?p="Sensor Config 1":16===n?p="Sensor Config 2":32===n&&(p="Sensor Config 3");const h=0<o?"XDCR HD Attached":"XDCR HD Not Attached",U=0<c?"Up Facing beam":"Down Facing beam",T=3&a,f=240&a;let m=S.UNHANDLED_STR+` value : ${T.toString(2)}`,D=S.UNHANDLED_STR+` value : ${f.toString(2)}`;0===T?m="15E Beam Angle":1===T?m="20E Beam Angle":2===T?m="30E Beam Angle":3===T&&(m="Other Beam Angle"),64===f?D="4-Beam JANUS Config":80===f?D="5-Beam JANUS Config DEMOD":240===f&&(D="5-Beam JANUS Config 2 DEMOD");return{systemStr:d,conBeamStr:u,sensorCfgStr:p,xdcrStr:h,beamFaceStr:U,beamAngleStr:m,janusStr:D}}static ParseSensorSrc(e){const t=[];return s.SENSOR_SRC.forEach((a=>{0<(a[0]&e)&&t.push(a[1])})),t}static ReadFixedLeader=e.CreateReader(s.FIXED_LEADER);static ParseCoord(e,t,a){const r=s.ReadFixedLeader.coordTransf(e,t,a);return s.ParseCoordTransform(r)}static ParseSectionDescribe(e,t,a){const r=new Map;return s.ReadFixedLeader._toDescribeMap(e,t,r,a),r}}class r{static TYPES=[128];static IsMyType(e){return-1<r.TYPES.findIndex((t=>t===e))}static VARIABLE_LEADER=new Map([["hID","U2"],["noEns","U2"],["tsYear","U1"],["tsMonth","U1"],["tsDay","U1"],["tsHour","U1"],["tsMin","U1"],["tsSec","U1"],["tsHundredths","U1"],["ensMSB","U1"],["bitResult","U2"],["soundSpeed","U2"],["dptTrans","U2"],["hdt","U2"],["pitch","I2"],["roll","I2"],["salinity","U2"],["temp","I2"],["mptMin","U1"],["mptSec","U1"],["mptHundredths","U1"],["stdHdt","U1"],["stdPitch","U1"],["stdRoll","U1"],["adc0","U1"],["adc1","U1"],["adc2","U1"],["adc3","U1"],["adc4","U1"],["adc5","U1"],["adc6","U1"],["adc7","U1"],["errStatus","U4"],["spare01","U2"],["pressure","U4"],["pressureVar","U4"],["spare02","U1"],["rtcCentury","U1"],["rtcYear","U1"]]);static BIT_RESULT_HI=[[16,"DEMOD 1 Error"],[8,"DEMOD 0 Error"],[2,"Timing card Error"]];static ERROR_STATUS1=[[1,"Bus error exception"],[2,"Address error exception"],[4,"Illegal Instruction exception"],[8,"Zero Divide exception"],[16,"Emulator exception"],[32,"Unassigned exception"],[64,"Watchdog restart occured"],[128,"Batter saver power"]];static ERROR_STATUS2=[[1,"Pinging"],[64,"Cold wakeup occurred"],[128,"Unknown wakeup occurred"]];static ERROR_STATUS3=[[1,"Clock read error occurred"],[2,"Unexpected alarm"],[4,"Clock jump forward"],[8,"Clock jump backward"]];static ERROR_STATUS4=[[8,"Power fail - unrecorded"],[16,"spurious level 4 intr - DSP"],[32,"spurious level 5 intr - UART"],[64,"spurious level 6 intr - CLOCK"],[128,"Level 7 interrupt occurred"]];static ParseBitResult(e){const t=e>>8,a=[];return r.BIT_RESULT_HI.forEach((e=>{0<(e[0]&t)&&a.push(e[1])})),a}static ParseErrorStatus(e){const t=255&e,a=(65280&e)>>8,s=(16711680&e)>>16,i=(4278190080&e)>>24,n=[];return r.ERROR_STATUS1.forEach((e=>{0<(e[0]&t)&&n.push(e[1])})),r.ERROR_STATUS2.forEach((e=>{0<(e[0]&a)&&n.push(e[1])})),r.ERROR_STATUS3.forEach((e=>{0<(e[0]&s)&&n.push(e[1])})),r.ERROR_STATUS4.forEach((e=>{0<(e[0]&i)&&n.push(e[1])})),n}static ParseDate(e,t,a,s,r,i,n){e+=e>80?1900:2e3,t-=1;const o=10*n;return new Date(Date.UTC(e,t,a,s,r,i,o))}static ReadVariableLeader=e.CreateReader(r.VARIABLE_LEADER);static ParseSectionDescribe(e,t,a){const s=new Map;return r.ReadVariableLeader._toDescribeMap(e,t,s,a),s}static ParseTimeStamp(e,t,a){const s={};r.ReadVariableLeader._toObject(e,t,["tsYear","tsMonth","tsDay","tsHour","tsMin","tsSec","tsHundredths"],s,a);return r.ParseDate(s.tsYear,s.tsMonth,s.tsDay,s.tsHour,s.tsMin,s.tsSec,s.tsHundredths)}}class i{static TYPES=[256];static IsMyType(e){return-1<i.TYPES.findIndex((t=>t===e))}static SIZE_VELOCITY=8;static DEPTH_CELL=new Map([["v1","I2"],["v2","I2"],["v3","I2"],["v4","I2"]]);static ParseVelocity2D(e,t){return s.COORD[0][0]!==e&&(s.COORD[3][0]===e&&i.ParseVelocity2DEarth(t))}static ParseVelocity2DEarth(e){const t=i.XYMagDir(e[0],e[1]);return{magnitude:t[0],direction:t[1],e:e[0],n:e[1],sur:e[2],err:e[3]}}static XYMagDir(e,t){return[Math.sqrt(e*e+t*t),(360-Math.atan2(t,e)*(180/Math.PI)+90)%360]}static TrueWind(e,t,a,s){const r=a*a+e*e-2*a*e*Math.cos(t*Math.PI/180),i=Math.sqrt(r),n=(e*e-i*i-a*a)/(2*i*a);return[i,s+Math.acos(n)*(180/Math.PI)]}static DegreeToRange(e){if(e=Number(e),isNaN(e))return 0;for(;e<0;)e=360+e;return e%=360}static ReadDepthCell=e.CreateReader(i.DEPTH_CELL);static ParseSection(e,t=0,a=!0){return[e.getUint16(t,a),(e.byteLength-2)/i.ReadDepthCell._size]}static ParseCell(e,t=2,a=!0){return[i.ReadDepthCell.v1(e,t,a),i.ReadDepthCell.v2(e,t,a),i.ReadDepthCell.v3(e,t,a),i.ReadDepthCell.v4(e,t,a)]}static ParseCellAt(e,t,a=!0){const s=2+t*i.ReadDepthCell._size;return i.ParseCell(e,s,a)}static ParseSectionDescribe(t,a=0,s=!0){const r=new Map,n=t.getUint16(a,s);r.set("hID",e.Describe(n,"U2",2));let o=a+2;const c=(t.byteLength-2)/i.ReadDepthCell._size;for(let e=0;e<c;e++){const a=new Map;i.ReadDepthCell._toDescribeMap(t,o,a,s),o+=i.ReadDepthCell._size;for(const[t,s]of a.entries())r.set(`dc${e+1}_`+t,s)}return r}parseDetail(){}parseVelocity2D(e){const a=[];if(s.COORD[3][0]!==e)return!1;this.parsedDetail&&(this.parsedDetail.cells.forEach((e=>{t!==e[0]&&t!==e[1]&&t!==e[2]&&t!==e[3]?a.push(i.XYMagDir(e[0],e[1])):a.push([t,t])})),this.parsedDetail.md=a)}parseMDNav(e,a){if(!this.parsedDetail||!this.parsedDetail.md)return console.error("parseMDNav should be called after md has calculated"),!1;const s=[];this.parsedDetail.md.forEach((r=>{if(t===r[0]||t===r[1])return void s.push([t,t]);if(0===e)return void s.push(r);const n=i.DegreeToRange(r[1]+180-a),o=i.TrueWind(r[0],n,e,a);o[1]=(o[1]+180)%360,s.push(o)})),this.parsedDetail.mdNav=s}}class n{static TYPES=[512];static IsMyType(e){return-1<n.TYPES.findIndex((t=>t===e))}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static SIZE_CORR=4;parseDetail(){const e=this.getUint16(0);if(this.addParseOffset(2),TDPD0.HID.CORR.code!==e)return void console.error(`Invalid HID for Corr(${TDPD0.HID.CORR.code.toString(16)}) != ${e.toString(16)}`);const t=[],a=(this.byteLength-2)/n.SIZE_CORR;for(let e=0;e<a;e++){const e=this.parseArray("U1",4);t.push(e)}const s={hID:e,cells:t};this.saveDetail(s)}static ReadDepthCell=e.CreateReader(n.DEPTH_CELL);static ParseSectionDescribe(t,a=0,s=!0){const r=new Map,i=t.getUint16(a,s);r.set("hID",e.Describe(i,"U2",2));let o=a+2;const c=(t.byteLength-2)/n.ReadDepthCell._size;for(let e=0;e<c;e++){const a=new Map;n.ReadDepthCell._toDescribeMap(t,o,a,s),o+=n.ReadDepthCell._size;for(const[t,s]of a.entries())r.set(`dc${e+1}_`+t,s)}return r}}class o{static TYPES=[768];static IsMyType(e){return-1<o.TYPES.findIndex((t=>t===e))}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static ReadDepthCell=e.CreateReader(o.DEPTH_CELL);static ParseSectionDescribe(t,a=0,s=!0){const r=new Map,i=t.getUint16(a,s);r.set("hID",e.Describe(i,"U2",2));let n=a+2;const c=(t.byteLength-2)/o.ReadDepthCell._size;for(let e=0;e<c;e++){const a=new Map;o.ReadDepthCell._toDescribeMap(t,n,a,s),n+=o.ReadDepthCell._size;for(const[t,s]of a.entries())r.set(`dc${e+1}_`+t,s)}return r}}class c{static TYPES=[1024];static IsMyType(e){return-1<c.TYPES.findIndex((t=>t===e))}static DEPTH_CELL=new Map([["f1","U1"],["f2","U1"],["f3","U1"],["f4","U1"]]);static ReadDepthCell=e.CreateReader(c.DEPTH_CELL);static ParseSectionDescribe(t,a=0,s=!0){const r=new Map,i=t.getUint16(a,s);r.set("hID",e.Describe(i,"U2",2));let n=a+2;const o=(t.byteLength-2)/c.ReadDepthCell._size;for(let e=0;e<o;e++){const a=new Map;c.ReadDepthCell._toDescribeMap(t,n,a,s),n+=c.ReadDepthCell._size;for(const[t,s]of a.entries())r.set(`dc${e+1}_`+t,s)}return r}}class l{static TYPES=[1280];static IsMyType(e){return-1<l.TYPES.findIndex((t=>t===e))}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static ReadDepthCell=e.CreateReader(l.DEPTH_CELL);static ParseSectionDescribe(t,a=0,s=!0){const r=new Map,i=t.getUint16(a,s);r.set("hID",e.Describe(i,"U2",2));const n=a+2,o=(t.byteLength-2)/l.ReadDepthCell._size;for(let e=0;e<o;e++){const a=new Map;l.ReadDepthCell._toDescribeMap(t,n,a,s),n+=l.ReadDepthCell._size;for(const[t,s]of a.entries())r.set(`dc${e+1}_`+t,s)}}}class d{static TYPES=[1536];static IsMyType(e){return-1<d.TYPES.findIndex((t=>t===e))}static BT_DATA=new Map([["hID","U2"],["pingsPEns","U2"],["delayReacq","U2"],["corrMagMin","U1"],["evalAmpMin","U1"],["pgMin","U1"],["mode","U1"],["errVelMax","U2"],["reserved","U4"],["range1","U2"],["range2","U2"],["range3","U2"],["range4","U2"],["vel1","U2"],["vel2","U2"],["vel3","U2"],["vel4","U2"],["corr1","U1"],["corr2","U1"],["corr3","U1"],["corr4","U1"],["evalAmp1","U1"],["evalAmp2","U1"],["evalAmp3","U1"],["evalAmp4","U1"],["pg1","U1"],["pg2","U1"],["pg3","U1"],["pg4","U1"],["rl1","U2"],["rl2","U2"],["rl3","U2"],["rlVel1","U2"],["rlVel2","U2"],["rlVel3","U2"],["rlVel4","U2"],["rlcm1","U1"],["rlcm2","U1"],["rlcm3","U1"],["rlcm4","U1"],["rlei1","U1"],["rlei2","U1"],["rlei3","U1"],["rlei4","U1"],["rlpg1","U1"],["rlpg2","U1"],["rlpg3","U1"],["rlpg4","U1"],["maxDepth","U2"],["rssiAmp1","U1"],["rssiAmp2","U1"],["rssiAmp3","U1"],["rssiAmp4","U1"],["gain","U1"],["rangeMSB1","U1"],["rangeMSB2","U1"],["rangeMSB3","U1"],["rangeMSB4","U1"]]);static BT_LAYER_WORD=new Map([["min","U2"],["near","U2"],["far","U2"]]);static ReadBottomTrack=e.CreateReader(d.BT_DATA);static ParseSectionDescribe(e,t=0,a=!0){const s=new Map;return d.ReadBottomTrack._toDescribeMap(e,t,s,a),s}}class u{parseDetail(){const e=this.getUint16(0);this.addParseOffset(2);const t=this.parseArray("U1",4);if(TDPD0.HID.ASP.code!==e)return void console.error(`Invalid HID for Ambient Sound Profile(${TDPD0.HID.PG.code.toString(16)}) != ${e.toString(16)}`);const a={hID:e,rssi:t};this.saveDetail(a)}}class p{static NAV_DATA=new Map([["hID","U2"],["utcDay","U1"],["utcMonth","U1"],["utcYear","U2"],["utcTimeFF","I4"],["pcClockOffset","I4"],["firstLat","U4"],["firstLng","U4"],["utcTimeLF","U4"],["lastLat","U4"],["lastLng","U4"],["avgSpd","I2"],["avgTrackTrue","U2"],["avgTrackMag","U2"],["SMG","U2"],["DMG","U2"],["reserved1","U2"],["flags","U2"],["reserved2","U2"],["noEns","U4"],["ensYear","U2"],["ensDay","U1"],["ensMonth","U1"],["ensTime","U4"],["pitch","I2"],["roll","I2"],["hdt","U2"],["numSpeedAvg","U2"],["numTTAvg","U2"],["numMTAvg","U2"],["numHdtAvg","U2"],["numPRAvg","U2"]]);static BAM(e,t){return 180*e/Math.pow(2,t-1)}static parseNavFlags(e){const t=[],a=[];return 0==(1&e)&&t.push("Data not updated"),0==(2&e)&&t.push("PSN Invalid"),0==(4&e)&&t.push("Speed Invalid"),0==(8&e)&&t.push("Mag Track Invalid"),0==(16&e)&&t.push("True Track Invalid"),0==(32&e)&&t.push("Date/Time Invalid"),0==(64&e)&&t.push("SMG/DMG Invalid"),0==(128&e)&&t.push("Pitch/Roll Invalid"),0==(256&e)&&t.push("Heading Invalid"),0==(512&e)&&t.push("ADCP Time Invalid"),0==(1024&e)&&t.push("Clock offset Time Invalid"),0!=(1&e)&&a.push("Data updated"),0!=(2&e)&&a.push("PSN Valid"),0!=(4&e)&&a.push("Speed Valid"),0!=(8&e)&&a.push("Mag Track Valid"),0!=(16&e)&&a.push("True Track Valid"),0!=(32&e)&&a.push("Date/Time Valid"),0!=(64&e)&&a.push("SMG/DMG Valid"),0!=(128&e)&&a.push("Pitch/Roll Valid"),0!=(256&e)&&a.push("Heading Valid"),0!=(512&e)&&a.push("ADCP Time Valid"),0!=(1024&e)&&a.push("Clock offset Time Valid"),{invalid:t,valid:a}}static ReadNavigation=e.CreateReader(p.NAV_DATA);static ParseSMGDMG(e,t=0,a=!0){return[p.ReadNavigation.SMG(e,t,a),p.ReadNavigation.DMG(e,t,a)]}static ParsePositionFirst(e,t=0,a=!0){return[p.ReadNavigation.firstLat(e,t,a),p.ReadNavigation.firstLng(e,t,a)]}static ParsePositionLast(e,t=0,a=!0){return[p.ReadNavigation.lastLat(e,t,a),p.ReadNavigation.lastLng(e,t,a)]}static ParseSectionDescribe(e,t=0,a=!0){const s=new Map;return p.ReadNavigation._toDescribeMap(e,t,s,a),s}}class h{static BINFIXED_ATTITUDE_DATA=new Map([["EF","U1"],["EH","U2"],["EI","U2"],["EJ","U2"],["EP","U4"],["EU","U1"],["EV","U2"],["EZ","U8"]]);parseDetail(){const e=this.getUint16(0);if(this.addParseOffset(2),TDPD0.HID.BINFIXED_ATTITUDE.code!==e)return void console.error(`Invalid HID for Binary Fixed Attitude(${TDPD0.HID.BINFIXED_ATTITUDE.code.toString(16)}) != ${e.toString(16)}`);const t=this.toAsciiString(2,9);this.addParseOffset(8);const a=this.parse(h.BINFIXED_ATTITUDE_DATA);a.hID=e,a.EE=t,this.saveDetail(a)}}class U{parseDetail(){const e=this.getUint16(0);this.addParseOffset(2);const t=[];for(let e=1;e<=8;e++){const e=this.parseArray("U2",6);t.push(e)}const a={hID:e,types:t};this.saveDetail(a)}}class S{static HEADER_HID=32639;static HID={HEADER:{code:S.HEADER_HID,title:"Header",cls:a},FIXED:{code:0,title:"Fixed Leader",cls:s},VARIABLE:{code:128,title:"Variable Leader",cls:r},VELOCITY:{code:256,title:"Veolocity Data",cls:i},CORR:{code:512,title:"Correlation magnitude Data",cls:n},INTENSITY:{code:768,title:"Echo intensity Data",cls:o},PG:{code:1024,title:"Percent good Data",cls:c},STATUS:{code:1280,title:"Status Data",cls:l},BT:{code:1536,title:"Bottom Track Data",cls:d},ASP:{code:524,title:"Ambient Sound Profile",cls:u},MICROCAT:{code:2048,title:"MicroCAT Data"},NAV:{code:8192,title:"Binary Navigation Data",cls:p},BINFIXED_ATTITUDE:{code:12288,title:"Binary Fixed Attitude Data",cls:h},BINVAR_ATTITUDE:{code:12352,title:"Binary Variable Attitude data",cls:U},UNKNOWN30E8:{code:12520,title:"Unknown type 0x30E8"},UNKNOWN30D8:{code:12504,title:"Unknown type 0x03D8"}};static SplitEnsemble(e,t,s=!0){const r=e.getUint16(t,s);if(S.HEADER_HID!==r)return!1;return a.ParseSection(e,t,s)}static DescType(e){for(const[t,a]of Object.entries(S.HID))if(a.code===e)return a}static GetTitle(e){for(const[t,a]of Object.entries(S.HID))if(a.code===e)return a.title}static GetParser(e){for(const[t,a]of Object.entries(S.HID))if(a.code===e)return a.cls?.ParseSectionDescribe}}class T{constructor(e=!0){this.littleEndian=e}parse(e,t=undefined){this.dataView=e,void 0===t&&(t=S.SplitEnsemble(e,0,this.littleEndian)),this.offsets=t.ensemble.offsets,this.sections=T.DivideOffsets(this.offsets,t.len,0),this.sections.forEach((a=>{const s=e.getUint16(a.offset,this.littleEndian);a.hID=s,a.dataView=new DataView(e.buffer,t.offset+a.offset,a.len)}));const a=new Map;for(const[e,t]of Object.entries(S.HID)){const s=this.sections.find((e=>e.hID===t.code));s&&a.set(e,s)}this.sectionMap=a,this.parseEssential()}parseEssential(){const e=this.fixed?.dataView,t=this.nav?.dataView;if(!e||!t)return;const a=s.ParseCoord(e,0,this.littleEndian);this.coord=a;const r=p.ParseSMGDMG(t,0,this.littleEndian);this.smg=r[0],this.dmg=p.BAM(r[1],16)}get header(){return this.sectionMap?.get("HEADER")}get fixed(){return this.sectionMap?.get("FIXED")}get variable(){return this.sectionMap?.get("VARIABLE")}get velocity(){return this.sectionMap?.get("VELOCITY")}get corr(){return this.sectionMap?.get("CORR")}get intensity(){return this.sectionMap?.get("INTENSITY")}get pg(){return this.sectionMap?.get("PG")}get status(){return this.sectionMap?.get("STATUS")}get nav(){return this.sectionMap?.get("NAV")}parseVelocity2D(e=-1,a=1){if(s.COORD[3][0]!==this.coord.type)return console.error("EnsembleContext.parseVelocity2D only supports Earth coordination type"),void console.log(this.coord);const r=this.velocity?.dataView;if(!r)return void console.error("EnsembleContext.parseVelocity2D has no velocity section");const n=i.ParseSection(r,0,this.littleEndian)[1];if(isNaN(n)||0>n||500<n||n!==parseInt(n))return void console.error(`EnsembleContext.parseVelocity2D invalid cellCount ${n}`);let o=e;(o<0||o>n||isNaN(o))&&(o=n);const c=[],l=[];for(let e=0;e<o;e+=a){const a=i.ParseCellAt(r,e,this.littleEndian),s=i.ParseVelocity2DEarth(a);t!==s.n&&t!==s.e||(s.magnitude=t,s.direction=t),c.push(a),l.push(s)}return this.velocityCells=c,this.velocityMD=l,!0}parseMDNav(){const e=this.smg,a=this.dmg,s=[];this.velocityMD.forEach((r=>{if(t===r.magnitude||t===r.direction)return void s.push([t,t]);if(0===e)return void s.push(r);const n=i.DegreeToRange(r.direction+180-a),o=i.TrueWind(r.magnitude,n,e,a);o[1]=(o[1]+180)%360,s.push(o)})),this.velocityMDNav=s}parsePosition(){const e=this.nav?.dataView;if(!e)return console.error("EnsembleContext.parsePosition has no navigation section"),!1;let t=p.ParsePositionFirst(e,0,this.littleEndian),a=p.ParsePositionLast(e,0,this.littleEndian);return t=[p.BAM(t[0],32),p.BAM(t[1],32)],a=[p.BAM(a[0],32),p.BAM(a[1],32)],this.posFirst=t,this.posLast=a,!0}static DivideOffsets(e,t,a=0,s=!0){const r=[];if(!t)return void console.error("EnsembleContext.OffsetDivide should have totalBytes");const i=e.map((e=>e));!0===s&&0!==i[0]&&i.unshift(0),i.push(t);for(let e=0;e<i.length-1;e++){const t=i[e],s=i[e+1]-t;r.push({offset:a+t,len:s})}return r}}class f{constructor(){this.dataView=void 0,this.ensembles=void 0,this.littleEndian=!0}load(e,t,a){this.dataView=e,this.ensembles=t,this.littleEndian=a}}class m{static ParseEnsembles(e,t=!0){const a=new DataView(e),s=[];let r=0;for(;r<a.byteLength;){const e=S.SplitEnsemble(a,r,t);if(!e)break;const i={offset:r,len:e.noBytesEns+2,title:"Ensemble",ensemble:e};s.push(i),r=r+e.noBytesEns+2}const i=new f;return i.load(a,s,t),i}static ParseEnsemblesContext(e){e.ensembles.forEach((t=>{const a=new T,s=new DataView(e.dataView.buffer,t.offset,t.len);a.parse(s,t),t.context=a}))}}return{PD0:S,PD0Header:a,PD0Fixed:s,PD0Variable:r,PD0Navigation:p,PD0Velocity:i,ParserContext:f,Ensemble:T,ParserTest:m,GetTitle:S.GetTitle,GetParser:S.GetParser,DescType:S.DescType,ParseEnsembles:m.ParseEnsembles,INVALID_VALUE:t}})();return{ParserA:e,ParserEM:t,ParserSEGY:a,ParserCTD:s,ParserPD0:r}})();