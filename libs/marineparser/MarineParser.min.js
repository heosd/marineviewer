const MarineParser=(()=>{const e=(()=>{const e={U1:["getUint8",1],U2:["getUint16",2],U4:["getUint32",4],U8:["getBigUint64",8],I1:["getInt8",1],I2:["getInt16",2],I4:["getInt32",4],I8:["getBigInt64",8],F4:["getFloat32",4],F8:["getFloat64",8]};function t(t){if(e[t])return e[t][1];if("A"===t[0]){const e=t.match(/^A(\d+)$/);if(!e)return-1;const s=parseInt(e[1]);return isNaN(s)?-1:s}return-1}function s(e,t,s){return{v:e,type:t,size:s}}const a={TypeMap:e,GetTypeSize:t,CreateReader:function(a){const i={};let r=0;return a.forEach(((s,a)=>{const n=e[s],o=r;if(n){const e=n[0];i[a]=(t,s,a)=>t[e](s+o,!1!==a),r+=n[1]}else if("A"===s[0]){const e=t(s);if(-1===e)return void console.error("Invalid Ascii type, that should have number after A like A16");i[a]=(t,s)=>{const a=t.byteOffset+s+o,i=t.buffer.slice(a,a+e);return String.fromCharCode.apply(null,new Uint8Array(i))},r+=e}})),i._size=r,i._toObject=(e,t,s,a,r)=>{s.forEach((s=>{a[s]=i[s](e,t,r)}))},i._toDescribeMap=(e,r,n,o)=>{a.forEach(((a,c)=>{const l=s(i[c](e,r,o),a,t(a));n.set(c,l)}))},i},ParseAscii:function(e,t,s){const a=e.buffer.slice(e.byteOffset+t,e.byteOffset+s);return String.fromCharCode.apply(null,new Uint8Array(a))},Describe:s,Undescribe:function(e){const t={};for(const[s,a]of e.entries())t[s]=a.v;return t},UndescribeMap:function(e){for(const[t,s]of e.entries())e.set(t,s.v);return e},ParseBit:function(e,t){const s=[];return e.forEach((e=>{0<(e[0]&t)&&s.push(e)})),s},ParseBitEqual:function(e,t){const s=[];return e.forEach((e=>{(t&e[0])===e[1]&&s.push(e)})),s},ParsedBitJoin:function(e){return e.map((e=>e.at(-1))).join(", ")},Project:function(e){for(const[t,s]of Object.entries(a))e[t]=s}};return a})(),t=(()=>{class s extends DataView{#e=!0;static STX=2;static ETX=3;static BYTE_LENGTH=4;static DATAGRAM_TYPES={73:{title:"Install Start",cls:null},105:{title:"Install Stop",cls:null},112:{title:"Install Remote",cls:null},82:{title:"Runtime",cls:null},88:{title:"XYZ88",cls:null},75:{title:"Central Beams",cls:null},70:{title:"Raw range and Beam angle",cls:null},102:{title:"Raw range and Beam angle F",cls:null},78:{title:"Raw range and angle 78",cls:null},83:{title:"Seabed image",cls:null},89:{title:"Seabed image 89",cls:null},107:{title:"Water column",cls:null},79:{title:"Quality factor 79",cls:null},65:{title:"Attitude",cls:null},110:{title:"Network attitude velocity",cls:null},67:{title:"Clock",cls:null},104:{title:"Depth or height",cls:null},72:{title:"Heading",cls:null},80:{title:"Position",cls:null},69:{title:"Single beam echo sounder depth",cls:null},84:{title:"Tide",cls:null},71:{title:"Surface sound speed",cls:null},85:{title:"Sound speed profile",cls:null},87:{title:"Kongberg Maritime SSP output",cls:null},74:{title:"Mechanical transducer tilt",cls:null},51:{title:"Extra parameters 3",cls:null},48:{title:"PU ID output",cls:null},49:{title:"PU Status output",cls:null},66:{title:"PU BIST result output",cls:null},68:{title:"Depth datagram",cls:null}};static DescType(e){return s.DATAGRAM_TYPES[e]?.title??void 0}set littleEndian(e){this.#e=e}parseBrief(){const e=[];let t=0;for(;t<this.byteLength;){const a=this.parseSection(t);e.push(a),t=t+a.len+s.BYTE_LENGTH}return e}parseSection(e){const t=this.getUint32(e,this.#e),a=this.getUint8(e+4,this.#e),i={type:this.getUint8(e+5,this.#e),offset:e,len:t,valid:!1};return s.STX===a&&(i.valid=!0),i}}class a{static TYPES=[88,136];static IsMyType(e){return-1<a.TYPES.findIndex((t=>t===e))}static STRUCT_XYZ_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["heading","U2"],["ss","U2"],["txTRDepth","F4"],["numBeams","U2"],["numValid","U2"],["freq","F4"],["info","U1"],["spare01","U1"],["spare02","U1"],["spare03","U1"]]);static STRUCT_XYZ_BODY=new Map([["z","F4"],["y","F4"],["x","F4"],["windowLen","U2"],["QFac","U1"],["angAdj","I1"],["dInfo","U1"],["cInfo","I1"],["reflectivity","I2"]]);static STRUCT_XYZ_TAIL=new Map([["spare04","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(a.STRUCT_XYZ_HEAD);static ReadBody=e.CreateReader(a.STRUCT_XYZ_BODY);static ReadTail=e.CreateReader(a.STRUCT_XYZ_TAIL);static ParseSection(e,t,i){const r={},n=a,o=n.ReadHead.numBeams(e,t,i),c=g(n.ReadHead.date(e,t,i),n.ReadHead.time(e,t,i));r.dt=c,r.numBeams=o;const l=n.ReadHead._size+t,d=[];for(let t=0;t<o;t++){const s=l+t*n.ReadBody._size,a=n.ReadBody.x(e,s,i),r=n.ReadBody.y(e,s,i),o=n.ReadBody.z(e,s,i);d.push([a,r,o])}r.body=d;const u=l+o*n.ReadBody._size,p=n.ReadTail.etx(e,u,i);return r.etxValid=s.ETX===p,r}static ParseSectionMinimum(e,t,s){const i=[a.ReadHead.date(e,t,s),a.ReadHead.time(e,t,s),a.ReadHead.numBeams(e,t,s),a.ReadHead.txTRDepth(e,t,s)],r=a.ReadHead._size+t,n=[];for(let t=0;t<i[2];t++){const i=r+t*a.ReadBody._size,o=a.ReadBody.x(e,i,s),c=a.ReadBody.y(e,i,s),l=a.ReadBody.z(e,i,s);n.push([o,c,l])}return i.push(n),i}static ParseSectionDescribe(e,t,s){const i=new Map;a.ReadHead._toDescribeMap(e,t,i,s);let r=a.ReadHead._size;const n=i.get("numBeams").v;for(let t=0;t<n;t++){const n=r+a.ReadBody._size*t,o=new Map;a.ReadBody._toDescribeMap(e,n,o,s);for(const[e,s]of o.entries())i.set(`e${t+1}_`+e,s)}return r+=a.ReadBody._size*n,a.ReadTail._toDescribeMap(e,r,i,s),i}}class i{static TYPES=[73,105,112];static IsMyType(e){return-1<i.TYPES.findIndex((t=>t===e))}static STRUCT_INSTALL=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["lineNo","U2"],["serial","U2"],["serial2ndSonar","U2"]]);static ReadInstall=e.CreateReader(i.STRUCT_INSTALL);static ParseSection(t,a,r){const n={};i.ReadInstall._toObject(t,a,["length","type","model","serial"],n,r);const o=i.ReadInstall._size,c=a+o,l=c+n.length-o,d=e.ParseAscii(t,c,l);n.ascii=d,n.etxValid=!1;const u=t.getUint8(l,r);if(0===u){const e=t.getUint8(l+1,r);s.ETX===e&&(n.etxValid=!0)}else s.ETX===u&&(n.etxValid=!0);return n}static ParseSectionDescribe(t,s,a){const r=new Map;i.ReadInstall._toDescribeMap(t,s,r,a);const n=i.ReadInstall._size,o=s+n,c=o+r.get("length").v-n,l=e.ParseAscii(t,o,c),d=e.Describe(l,"ASCII",c-o);return r.set("ascii",d),T(t,c,r,a),r}}class r{static TYPES=[82];static IsMyType(e){return-1<r.TYPES.findIndex((t=>t===e))}static STRUCT_RUNTIME=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["operatorStationStatus","U1"],["PUStatus","U1"],["BSPStatus","U1"],["SHTStatus","U1"],["mode","U1"],["filterID","U1"],["minDepth","U2"],["maxDepth","U2"],["absorpCoeff","U2"],["txPulseLen","U2"],["txBeamWidth","U2"],["txPower","I1"],["rxBeamWidth","U1"],["rxBandwidth","U1"],["rxGain","U1"],["TVGLawAng","U1"],["srcSS","U1"],["maxPortSwath","U2"],["beamSpacing","U1"],["maxPortCoverage","U1"],["yawPitchStable","U1"],["maxSTBDCoverage","U1"],["maxSTBDSwath","U2"],["txTiltValue","I2"],["filterID2","U1"],["etx","U1"],["checksum","U2"]]);static ReadRuntime=e.CreateReader(r.STRUCT_RUNTIME);static ParseSectionDescribe(e,t,s){const a=new Map;return r.ReadRuntime._toDescribeMap(e,t,a,s),a}static BitPUStatus=[[1,"Communication error With BSP (or CBMF) : All models except ME70BO"],[2,"Communication error with Sonar Head or Transceiver : All models except EM 2040 and ME70BO, Communication error with slave PU : EM 2040/EM 2040C, Problem with communication with ME70 : ME70BO"],[4,"Attitude not valid for this ping : All models"],[8,"Heading not valid for this ping : All models"],[16,"System clock has not been set since power up : All models"],[32,"External trigger signal not detected : All models except ME70BO"],[64,"CPU temperature warning : All models except EM 1002, Hull Unit not responding : EM 1002"],[128,"Attitude velocity data not valid for this ping : EM 122 EM 302 EM 710 EM 2040 EM 2040C"]];static BitBSPStatusA=[[1,"Error on R0 data received by BSP 1 (May be a bad high speed link) : EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[2,"Too much seabed image data on BSP1 : EM 3000, EM 3000D"],[4,"Invalid command received by BSP1 : EM 3000, EM 3000D"],[8,"Errors on BSP1 : EM 3002, EM 3002D"],[16,"Error on R0 data received by BSP 2 (May be a bad high speed link) : EM 3000D, EM 3002D"],[32,"Too much seabed image data on BSP2 : EM 3000D"],[64,"Invalid command received by BSP2 : EM 3000D"],[128,"Errors on BSP2 : EM 3002, EM 3002D"]];static BitBSPStatusB=[[1,"Sample number error in RX data received from SPRX"]];static BitBSPStatusC=[[1,"Sample number error in R0 data received from SPRX"],[2,"Missing R0 header data from SPRX"],[4,"Missing sample data from SPTX"],[8,"Missing second R0 header data from SPTX"],[16,"Bad sync TRU - PU - BSP"],[32,"Bad parameters received from PU"],[64,"Internal sync problem in BSP"],[128,"Checksum error in header from SPTX"]];static BitBSPStatusD=[[1,"Error on RX data received by BSP 1"],[2,"Error on RX data received by BSP 3"],[4,"Errors on BSP 3"],[8,"Errors on BSP 1"],[16,"Error on RX data received by BSP 2"],[32,"Error on RX data received by BSP 4"],[64,"Errors on BSP 4"],[128,"Errors on BSP2"]];static BitBSPStatusE=[[1,"Error on data from BSP 1 - master PU"],[2,"Error on data from BSP 2 - master PU"],[4,"Error on data from BSP 3 - master PU"],[8,"Error on data from BSP 4 - master PU"],[16,"Error on data from BSP 1 - slave PU"],[32,"Error on data from BSP 2 - slave PU"],[64,"Error on data from BSP 3 - slave PU"],[128,"Error on data from BSP 4 - slave PU"]];static BitCRMFStatus=[[1,"Error on data from CBMF 1 - master PU"],[2,"Error on data from CBMF 2 - master PU"],[4,"Error on data from CBMF 3 - slave PU"],[8,"Error on data from CBMF 4 - slave PU"]];static ModelBSPStatus=new Map([[2e3,[r.BitBSPStatusA]],[3e3,[r.BitBSPStatusA]],[3002,[r.BitBSPStatusA]],[1002,[r.BitBSPStatusB]],[102,[r.BitBSPStatusC]],[300,[r.BitBSPStatusC]],[122,[r.BitBSPStatusD]],[302,[r.BitBSPStatusD]],[710,[r.BitBSPStatusD]],[2040,[r.BitBSPStatusE]]]);static BitTransceiverStatusA=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Timeout error (SPRX waits for SPTX)"],[8,"Receive channel DC offset(s) out of range"],[16,"Illegal parameter received from PU"],[32,"Internal communication error (SPTX - SPRX sync)"],[64,"Timeout error (SPTX waits for SPRX)"],[128,"Defective fuse(s) in transmitter"]];static BitTransceiverStatusB=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Error on Transmitter"],[8,"Error on Receiver"],[16,"Not implemented"],[32,"Not implemented"],[64,"Not implemented"],[128,"Not implemented"]];static BitTransceiverStatusC=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Transmit voltage (HV) to high"],[8,"Error in command from PU (Illegal parameter)"],[16,"Error in command from PU (Bad checksum)"],[32,"Error in command from PU (Bad datagram length)"]];static BitTransceiverStatusD=[[1,"Transmit power (HV) out of range"],[2,"Communication error with TX"],[4,"Communication error with RX 1 (port)"],[8,"Communication error with RX 2 (starboard)"],[16,"Communication error with IO2040 - master PU"],[32,"Communication error with IO2040 - slave PU"],[64,"Spare"],[128,"Spare"]];static BitSonarHeadStatusA=[[1,"Temperature to high on Sonar Head 1 EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[2,"Data link failure on Sonar Head 1 EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[4,"DC Supply Voltages in Sonar Head 1 is out of range EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[8,"Spare"],[16,"Temperature to high on Sonar Head 2 EM 3000D, EM 3002D"],[32,"Data link failure on Sonar Head 2 EM 3000D, EM 3002D"],[64,"DC Supply Voltages in Sonar Head 2 is out of range EM 3000D, EM 3002D"],[128,"Spare"]];static BitSonarHeadStatusB=[[1,"Transmit power (HV) out of range SH1"],[2,"Communication error with TX SH1"],[4,"Communication error with RX SH1"],[8,"Temperature to high SH1"],[16,"Transmit power (HV) out of range SH2"],[32,"Communication error with TX SH2"],[64,"Communication error with RX SH2"],[128,"Temperature to high SH2"]];static ModelSHTStatus=new Map([[102,[r.BitTransceiverStatusA]],[300,[r.BitTransceiverStatusA]],[122,[r.BitTransceiverStatusB]],[302,[r.BitTransceiverStatusB]],[710,[r.BitTransceiverStatusB]],[1002,[r.BitTransceiverStatusC]],[2e3,[r.BitSonarHeadStatusA]],[3e3,[r.BitSonarHeadStatusA]],[3002,[r.BitSonarHeadStatusA]],[2040,[r.BitTransceiverStatusD,r.BitSonarHeadStatusB]]]);static BitEqualPingModeA=[[15,0,"Nearfield (4º)"],[15,1,"Normal (1.5º)"],[15,2,"Target detect"]];static BitEqualPingModeB=[[15,0,"Wide Tx beamwidth (4°)"],[15,1,"Normal Tx beamwidth (1.5°)"]];static BitEqualPingModeC=[[15,0,"Very Shallow"],[15,1,"Shallow"],[15,2,"Medium"],[15,3,"Deep"],[15,4,"Very deep"],[15,5,"Extra deep"]];static BitEqualPingModeD=[[15,0,"200 kHz"],[15,1,"300 kHz"],[15,2,"400 kHz"]];static BitEqualTXPulseFormA=[[48,0,"CW"],[48,16,"Mixed"],[48,32,"FM"]];static BitEqualFrequency=[[31,0,"180 kHz"],[31,1,"190 kHz"],[31,22,"400 kHz"]];static BitEqualTXPulseFormB=[[32,0,"CW"],[32,32,"FM"]];static BitEqualDualSwathMode=[[192,0,"Dual swath = Off"],[192,64,"Dual swath = Fixed"],[192,128,"Dual swath = Dynamic"]];static ModelMode=new Map([[3e3,[r.BitEqualPingModeA]],[3002,[r.BitEqualPingModeB]],[2e3,[r.BitEqualPingModeC]],[710,[r.BitEqualPingModeC,r.BitEqualTXPulseFormA,r.BitEqualDualSwathMode]],[1002,[r.BitEqualPingModeC]],[300,[r.BitEqualPingModeC]],[302,[r.BitEqualPingModeC,r.BitEqualTXPulseFormA,r.BitEqualDualSwathMode]],[120,[r.BitEqualPingModeC]],[122,[r.BitEqualPingModeC,r.BitEqualTXPulseFormA,r.BitEqualDualSwathMode]],[2040,[r.BitEqualPingModeD,r.BitEqualTXPulseFormA,r.BitEqualFrequency,r.BitEqualTXPulseFormB,r.BitEqualDualSwathMode]]]);static BitEqualFilterID=[[3,0,"Spike filter set to Off"],[3,1,"Spike filter is set to Weak"],[3,2,"Spike filter is set to Medium"],[3,3,"Spike filter is set to Strong"],[4,4,"Slope filter is on"],[8,8,"Sector tracking or Robust Bottom Detection (EM 3000) is on"],[144,0,"Range gates have Normal size"],[144,16,"Range gates are Large"],[144,128,"Range gates are Small"],[32,32,"Aeration filter is on"],[64,64,"Interference filter is on"]];static BitEqualFilterID2=[[3,0,"Penetration filter = Off"],[3,1,"Penetration filter = Weak"],[3,2,"Penetration filter = Medium"],[3,3,"Penetration filter = Strong"],[12,0,"Detect mode: Normal"],[12,4,"Detect mode: Waterway"],[12,8,"Detect mode: Tracking"],[12,12,"Detected mode: Minimum depth"],[48,0,"Short phase ramp"],[48,16,"Normal phase ramp"],[48,32,"Long phase ramp"],[64,0,"Normal TVG"],[64,64,"Special TVG"],[128,0,"Normal amp detect"],[128,128,"Special amp detect or soft sediments (EM 3002)"]];static BitEqualSoundSpeed=[[3,0,"From real time sensor"],[3,1,"Manually entered by operator"],[3,2,"Interpolated from currently used sound speed profile"],[3,3,"Calculated by ME70BO TRU"],[16,16,"Extra detections enabled"],[32,32,"Sonar mode enabled"],[64,64,"Passive mode enabled"],[128,128,"3D scanning enabled"]];static BitEqualBeamspacing=[[3,0,"Determined by beamwidth (FFT beamformer of EM 3000)"],[3,1,"Equidistant (Inbetween for EM 122 and EM 302)"],[3,2,"Equiangle"],[3,3,"High density equidistant (In between for EM 2000, EM 120, EM 300, EM 1002)"]];static BitEqualBeamspacing3002Only=[[128,0,"Only one sonar head is connected. If two heads are connected, both have the same beam spacing."],[128,128,"Two sonar heads are connected. Individual beam spacing is possible."],[112,0,"No head 2"],[112,16,"h2 equidistant"],[112,32,"h2 equiangle"],[112,48,"h2 high density"],[15,1,"h1 equidistant"],[15,2,"h1 equiangle"],[15,3,"h1 high density"]];static BitEqualYawPitchStable=[[3,0,"No yaw stabilization"],[3,1,"Yaw stabilization to survey line heading (Not used)"],[3,2,"Yaw stabilization to mean vessel heading"],[3,3,"Yaw stabilization to manually entered heading"],[12,0,"Heading filter, hard"],[12,4,"Heading filter, medium"],[12,8,"Heading filter, weak"],[128,128,"Pitch stabilization is on."]];static BitEqualRXFixedGain20040Only=[[3,0,"Off (RX inactive)"],[3,1,"port active"],[3,2,"starboard active"],[3,3,"Both active"],[12,0,"Short CW"],[12,4,"Medium CW"],[12,8,"Long CW"],[12,12,"FM"],[112,0,"Very Short CW"],[112,16,"Short CW"],[112,32,"Medium CW"],[112,48,"Long CW"],[112,64,"Very Long CW"],[112,80,"Extra Long CW"],[112,96,"Short FM"],[112,112,"Long FM"]];static ParseOperatorStationStatus(e){return[]}static ParsePUStatus(t){return e.ParseBit(r.BitPUStatus,t)}static ParseBSPStatus(t,s){const a=r.ModelBSPStatus.get(s);return a?e.ParseBit(a,t):[[t,`No model found for ${s}`]]}static ParseSHTStatus(t,s){const a=r.ModelSHTStatus.get(s);return a?[].concat(...a.map((s=>e.ParseBit(s,t)))):[[t,`No model found for ${s}`]]}static ParseMode(t,s){const a=r.ModelMode.get(s);return a?[].concat(...a.map((s=>e.ParseBitEqual(s,t)))):[[t,`No model found for ${s}`]]}static ParseFilterID(t){return e.ParseBitEqual(r.BitEqualFilterID,t)}static ParseFilterID2(t){return e.ParseBitEqual(r.BitEqualFilterID2,t)}static ParseSrcSS(t){return e.ParseBitEqual(r.BitEqualSoundSpeed,t)}static ParseBeamSpacing(t,s){return 3002===s?e.ParseBitEqual(r.BitEqualBeamspacing3002Only,t):e.ParseBitEqual(r.BitEqualBeamspacing,t)}static ParseYawPitchStable(t){return e.ParseBitEqual(r.BitEqualYawPitchStable,t)}static ParseRXGain(t,s){return 2040!==s?[[0,0,t]]:e.ParseBitEqual(r.BitEqualRXFixedGain20040Only,t)}}class n{static TYPES=[80];static IsMyType(e){return-1<n.TYPES.findIndex((t=>t===e))}static STRUCT_POSITION=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["positionCounter","U2"],["serial","U2"],["lat","I4"],["lng","I4"],["measurePosFixQ","U2"],["speed","U2"],["course","U2"],["heading","U2"],["posSysDesc","U1"],["numInput","U1"]]);static ReadPosition=e.CreateReader(n.STRUCT_POSITION);static ParseLatDegree=e=>e/2e7;static ParseLngDegree=e=>e/1e7;static ParseSpeedMpS=e=>e/100;static ParseCourseDegree=e=>e/100;static ParseHeadingDegree=e=>e/100;static ParseSection(e,t,s){const a={},i={},r=n;r.ReadPosition._toObject(e,t,["date","time","lat","lng","speed","course","heading"],i,s);const o=g(i.date,i.time);return a.dt=o,a.lat=r.ParseLatDegree(i.lat),a.lng=r.ParseLngDegree(i.lng),a.speed=r.ParseSpeedMpS(i.speed),a.course=r.ParseCourseDegree(i.course),a.heading=r.ParseHeadingDegree(i.heading),a}static ParseSectionMinimum(e,t,s){const a=n;return[a.ReadPosition.date(e,t,s),a.ReadPosition.time(e,t,s),n.ParseLatDegree(a.ReadPosition.lat(e,t,s)),n.ParseLngDegree(a.ReadPosition.lng(e,t,s)),n.ParseHeadingDegree(a.ReadPosition.heading(e,t,s))]}static ParseSectionDescribe(t,s,a){const i=new Map;n.ReadPosition._toDescribeMap(t,s,i,a);const r=s+n.ReadPosition._size,o=i.get("numInput").v,c=r+o,l=e.ParseAscii(t,r,c);return i.set("input",e.Describe(l,"A"+o,o)),T(t,c,i,a),i}}class o{static TYPES=[68];static IsMyType(e){return-1<o.TYPES.findIndex((t=>t===e))}static STRUCT_DD_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["heading","U2"],["ss","U2"],["txTRDepth","U2"],["maxNumBeams","U1"],["numValid","U1"],["zRes","U1"],["xyRes","U1"],["freq","U2"]]);static STRUCT_DD_BODY=new Map([["z","U2"],["y","I2"],["x","I2"],["beamDeprAng","I2"],["beamAzimAng","U2"],["range","U2"],["QFac","U1"],["len","U1"],["reflectivity","I1"],["beamNum","U1"]]);static STRUCT_DD_BODY_SIGN=new Map([["z","I2"],["y","I2"],["x","I2"],["beamDeprAng","I2"],["beamAzimAng","U2"],["range","U2"],["QFac","U1"],["len","U1"],["reflectivity","I1"],["beamNum","U1"]]);static STRUCT_DD_TAIL=new Map([["depthOffsetM","I1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(o.STRUCT_DD_HEAD);static ReadBody=e.CreateReader(o.STRUCT_DD_BODY);static ReadBodySign=e.CreateReader(o.STRUCT_DD_BODY_SIGN);static ReadTail=e.CreateReader(o.STRUCT_DD_TAIL);static ParseSectionMinimum(e,t,s){const a=o.ReadHead.model(e,t,s),i=[o.ReadHead.date(e,t,s),o.ReadHead.time(e,t,s),o.ReadHead.numValid(e,t,s),o.ReadHead.txTRDepth(e,t,s)/100],r=o.ReadHead._size+t,n=[];let c=o.ReadBody;120!==a&&300!==a||(c=o.ReadBodySign);for(let t=0;t<i[2];t++){const a=r+t*c._size,i=c.x(e,a,s),o=c.y(e,a,s),l=c.z(e,a,s);n.push([i/100,o/100,l/100])}return i.push(n),i}static ParseSectionDescribe(e,t,s){const a=new Map;o.ReadHead._toDescribeMap(e,t,a,s);const i=a.get("model").v,r=a.get("numValid").v;let n=o.ReadHead._size,c=o.ReadBody;120!==i&&300!==i||(c=o.ReadBodySign);for(let t=0;t<r;t++){const i=n+c._size*t,r=new Map;c._toDescribeMap(e,i,r,s);for(const[e,s]of r.entries())a.set(`e${t+1}_`+e,s)}return n+=c._size*r,o.ReadTail._toDescribeMap(e,n,a,s),a}}class c{static TYPES=[85];static IsMyType(e){return-1<c.TYPES.findIndex((t=>t===e))}static STRUCT_SS_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["date2","U4"],["time2","U4"],["numEntries","U2"],["depthRes","U2"]]);static STRUCT_SS_ENTRY=new Map([["depth","U4"],["ss","U4"]]);static STRUCT_SS_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(c.STRUCT_SS_HEAD);static ReadEntry=e.CreateReader(c.STRUCT_SS_ENTRY);static ReadTail=e.CreateReader(c.STRUCT_SS_TAIL);static ParseSectionDescribe(t,s,a){const i=new Map,r=!1!==a;c.ReadHead._toDescribeMap(t,s,i,a);const n=i.get("numEntries").v;let o=s+c.ReadHead._size;for(let s=0;s<n;s++){const a=o+8*s,n=c.ReadEntry.depth(t,a,r),l=c.ReadEntry.ss(t,a+4,r);i.set(`depth_${s+1}`,e.Describe(n,"U4",4)),i.set(`ss_${s+1}`,e.Describe(l,"U4",4))}return o+=8*n,c.ReadTail._toDescribeMap(t,o,i,a),i}}class l{static TYPES=[48];static IsMyType(e){return-1<l.TYPES.findIndex((t=>t===e))}static STRUCT_PU_ID=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["byteOrder","U2"],["serial","U2"],["UDP1","U2"],["UDP2","U2"],["UDP3","U2"],["UDP4","U2"],["sysDesc","U4"],["PUVer","A16"],["BSPVer","A16"],["sonarHead1Ver","A16"],["sonarHead2Ver","A16"],["IPAddr","U4"],["txOpenAng","U1"],["rxOpenAng","U1"],["spare1","U4"],["spare2","U2"],["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadPUID=e.CreateReader(l.STRUCT_PU_ID);static ParseSectionDescribe(e,t,s){const a=new Map;return l.ReadPUID._toDescribeMap(e,t,a,s),a}}class d{static TYPES=[49];static IsMyType(e){return-1<d.TYPES.findIndex((t=>t===e))}static STRUCT_PU_STATUS=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["statusCounter","U2"],["serial","U2"],["pingRate","U2"],["pingCounter","U2"],["distSwath10","U4"],["UDP2","U4"],["serial1","U4"],["serial2","U4"],["serial3","U4"],["serial4","U4"],["pps","I1"],["posStat","I1"],["attStat","I1"],["clockStat","I1"],["headingStat","I1"],["puStat","U1"],["lastHeading","U2"],["lastRoll","I2"],["lastPitch","I2"],["lastHeave","U2"],["ssTrans","U2"],["lastDepth","U4"],["velocity","I2"],["attVelocity","U1"],["mammalRamp","U1"],["backObliqueAngle","I1"],["backIncidence","I1"],["fixedGain","I1"],["depthIncidence","U1"],["rangeIncidence","U2"],["portCoverage","U1"],["stbdCoverage","U1"],["ssTransProfile","U2"],["yawStabAngle","I2"],["portCoverage2","I2"],["stbdCoverage2","I2"],["tempCPU","I1"],["etx","U1"],["checksum","U2"]]);static ReadPUStatus=e.CreateReader(d.STRUCT_PU_STATUS);static ParseSectionDescribe(e,t,s){const a=new Map;return d.ReadPUStatus._toDescribeMap(e,t,a,s),a}}class u{static TYPES=[110];static IsMyType(e){return-1<u.TYPES.findIndex((t=>t===e))}static STRUCT_NATTV=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["netAttCounter","U2"],["serial","U2"],["numEntries","U2"],["senSysDesc","I1"],["spare1","U1"]]);static STRUCT_NATTV_ENTRY=new Map([["time","U2"],["roll","I2"],["pitch","I2"],["heave","I2"],["heading","U2"],["numBytes","U1"]]);static ReadHead=e.CreateReader(u.STRUCT_NATTV);static ReadEntry=e.CreateReader(u.STRUCT_NATTV_ENTRY);static ParseSectionDescribe(t,s,a){const i=new Map;u.ReadHead._toDescribeMap(t,s,i,a);const r=i.get("numEntries").v;let n=s+u.ReadHead._size;for(let s=0;s<r;s++){const r=new Map;u.ReadEntry._toDescribeMap(t,n,r,a),n+=u.ReadEntry._size;const o=r.get("numBytes").v,c=e.ParseAscii(t,n,n+o);n+=o,r.set("inputs",e.Describe(c,"A"+o,o));for(const[e,t]of r.entries())i.set(`e${s+1}_`+e,t)}return T(t,n,i,a),i}}class p{static TYPES=[67];static IsMyType(e){return-1<p.TYPES.findIndex((t=>t===e))}static STRUCT_CLOCK=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["clockCounter","U2"],["serial","U2"],["date2","U4"],["time2","U4"],["ppsUsed","U1"],["etx","U1"],["checksum","U2"]]);static ReadClock=e.CreateReader(p.STRUCT_CLOCK);static ParseSectionDescribe(e,t,s){const a=new Map;return p.ReadClock._toDescribeMap(e,t,a,s),a}}class h{static TYPES=[65];static IsMyType(e){return-1<h.TYPES.findIndex((t=>t===e))}static STRUCT_ATT_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["attCounter","U2"],["serial","U2"],["numEntries","U2"]]);static STRUCT_ATT_ENTRY=new Map([["time","U2"],["senStatus","U2"],["roll","I2"],["pitch","I2"],["heave","I2"],["heading","U2"]]);static STRUCT_ATT_TAIL=new Map([["senSysDesc","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(h.STRUCT_ATT_HEAD);static ReadEntry=e.CreateReader(h.STRUCT_ATT_ENTRY);static ReadTail=e.CreateReader(h.STRUCT_ATT_TAIL);static ParseSectionDescribe(e,t,s){const a=new Map;h.ReadHead._toDescribeMap(e,t,a,s);const i=a.get("numEntries").v;let r=t+h.ReadHead._size;for(let t=0;t<i;t++){const i=new Map;h.ReadEntry._toDescribeMap(e,r,i,s),r+=h.ReadEntry._size;for(const[e,s]of i.entries())a.set(`e${t+1}_`+e,s)}return h.ReadTail._toDescribeMap(e,r,a,s),a}}class U{static TYPES=[83];static IsMyType(e){return-1<U.TYPES.findIndex((t=>t===e))}static STRUCT_SEABED_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["meanAbsorpCoeff","U2"],["pulseLen","U2"],["rangeIncience","U2"],["startTVG","U2"],["stoptTVG","U2"],["BSN","I1"],["BSO","I1"],["txBeamWidth","U2"],["tvgLaw","U1"],["numValidBeams","U1"]]);static STRUCT_SEABED_ENTRY=new Map([["idx","U1"],["direction","I1"],["Ns","U2"],["centreSampleNum","U2"]]);static ReadHead=e.CreateReader(U.STRUCT_SEABED_HEAD);static ReadEntry=e.CreateReader(U.STRUCT_SEABED_ENTRY);static ParseSectionDescribe(e,t,s){const a=new Map;U.ReadHead._toDescribeMap(e,t,a,s);const i=a.get("numValidBeams").v;let r=t+U.ReadHead._size;for(let t=0;t<i;t++){const i=new Map;U.ReadEntry._toDescribeMap(e,r,i,s),r+=U.ReadEntry._size;for(const[e,s]of i.entries())a.set(`e${t+1}_`+e,s)}return a}}class m{static TYPES=[89,137];static IsMyType(e){return-1<m.TYPES.findIndex((t=>t===e))}static STRUCT_SEABED89_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["sampleFreq","F4"],["rangeIncience","U2"],["BSN","I2"],["BSO","I2"],["txBeamWidth","U2"],["tvgLaw","U2"],["numValidBeams","U2"]]);static STRUCT_SEABED89_ENTRY=new Map([["direction","I1"],["dInfo","U1"],["Ns","U2"],["centreSampleNum","U2"]]);static STRUCT_SEABED89_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(m.STRUCT_SEABED89_HEAD);static ReadEntry=e.CreateReader(m.STRUCT_SEABED89_ENTRY);static ReadTail=e.CreateReader(m.STRUCT_SEABED89_TAIL);static ParseSectionDescribe(t,s,a){const i=new Map,r=!1!==a;m.ReadHead._toDescribeMap(t,s,i,a);const n=i.get("numValidBeams").v;let o=s+m.ReadHead._size,c=0;for(let e=0;e<n;e++){const s=new Map;m.ReadEntry._toDescribeMap(t,o,s,a),o+=m.ReadEntry._size;c+=s.get("Ns").v;for(const[t,a]of s.entries())i.set(`e${e+1}_`+t,a)}for(let s=0;s<c;s++){const a=o+2*s,n=t.getInt16(a,r);i.set(`amplitudes${s+1}`,e.Describe(n,"I2",2))}return o+=2*c,m.ReadTail._toDescribeMap(t,o,i,a),i}}class S{static TYPES=[78,120];static IsMyType(e){return-1<S.TYPES.findIndex((t=>t===e))}static STRUCT_RAW78_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["ssTrans","U2"],["Ntx","U2"],["Nrx","U2"],["numValidDetect","U2"],["sampleFreq","F4"],["dScale","U4"]]);static STRUCT_RAW78_ENTRY_NTX=new Map([["tiltAngle","I2"],["focusRange","U2"],["sigLen","F4"],["secTransDelay","F4"],["centreFreq","F4"],["meanAbsorpCoeff","U2"],["sigId","U1"],["transSecNum","U1"],["sigBandwidth","F4"]]);static STRUCT_RAW78_ENTRY_RTX=new Map([["beamAngle","I2"],["transSecNum","U1"],["dInfo","U1"],["windowLen","U2"],["qFac","U1"],["dCorr","I1"],["twoTT","F4"],["BS","I2"],["cInfo","I1"],["spare","U1"]]);static STRUCT_RAW78_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(S.STRUCT_RAW78_HEAD);static ReadEntryTX=e.CreateReader(S.STRUCT_RAW78_ENTRY_NTX);static ReadEntryRX=e.CreateReader(S.STRUCT_RAW78_ENTRY_RTX);static ReadTail=e.CreateReader(S.STRUCT_RAW78_TAIL);static ParseSectionDescribe(e,t,s){const a=new Map;S.ReadHead._toDescribeMap(e,t,a,s);const i=a.get("Ntx").v;let r=t+S.ReadHead._size;for(let t=0;t<i;t++){const i=new Map;S.ReadEntryTX._toDescribeMap(e,r,i,s),r+=S.ReadEntryTX._size;for(const[e,s]of i.entries())a.set(`ntx${t+1}_`+e,s)}const n=a.get("Nrx").v;for(let t=0;t<n;t++){const i=new Map;S.ReadEntryRX._toDescribeMap(e,r,i,s),r+=S.ReadEntryRX._size;for(const[e,s]of i.entries())a.set(`nrx${t+1}_`+e,s)}return S.ReadTail._toDescribeMap(e,r,a,s),a}}class f{static TYPES=[51];static IsMyType(e){return-1<f.TYPES.findIndex((t=>t===e))}static STRUCT_EXTRA_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["contentID","U2"]]);static ReadHead=e.CreateReader(f.STRUCT_EXTRA_HEAD);static ReadContentID6=(t,s,a,i)=>{const r=!1!==i,n=t.getUint16(s,r);a.set("Nc",e.Describe(n,"U2",2));const o=e.ParseAscii(t,s+2,s+2+n);return a.set("content",e.Describe(o,"A"+n,n)),a};static ParseSectionDescribe(e,t,s){const a=new Map;f.ReadHead._toDescribeMap(e,t,a,s);let i=f.ReadHead._size;return 6===a.get("contentID").v&&(f.ReadContentID6(e,t+i,a,s),i=2+i+a.get("Nc").v),T(e,i,a,s),a}}function g(e,t){const s=parseInt(e/1e4),a=parseInt(e/100%100),i=parseInt(e%100),r=parseInt(t/1e3),n=parseInt(r/60/60),o=parseInt(r/60%60),c=parseInt(t/1e3%60),l=parseInt(t%1e3);return new Date(`${s}-${a}-${i} ${n}:${o}:${c}.${l}`)}function T(t,s,a,i){let r=s;const n=!1!==i;0===t.getUint8(r,n)&&(r++,a.set("spareEOS",e.Describe(0,"U1",1)));const o=t.getUint8(r++,n);a.set("etx",e.Describe(o,"U1",1));const c=t.getUint16(r++,n);a.set("checksum",e.Describe(c,"U2",2))}const E=(()=>{const e=new Map;return[a,n,o,r,i,c,l,u,p,h,U,m,d,S,f].forEach((t=>{t.TYPES.forEach((s=>{e.set(s,t)}))})),t=>e.get(t)})();class D{constructor(){this.mb=void 0,this.sections=void 0,this.isLE=!0,this.positions=void 0,this.xyz=void 0,this.lines=void 0}load(e,t,s){this.mb=e,this.sections=t,this.isLE=s,this.typeXYZ=this.judgeXYZ(),this.bytes=this.mb.byteLength}judgeXYZ(){return-1<this.sections.findIndex((e=>88===e.type))?88:-1<this.sections.findIndex((e=>68===e.type))?68:void 0}parsePosition(){const e=[],t=E(80);for(let s=0;s<this.sections.length;s++){const a=this.sections[s];if(80===a.type){const s=t.ParseSectionMinimum(this.mb,a.offset,a.length);e.push(s)}}this.positions=e}parseXYZ(){const e=[],t=this.typeXYZ,s=E(t);for(let t=0;t<this.sections.length;t++){const a=this.sections[t];if(68===a.type){const t=s.ParseSectionMinimum(this.mb,a.offset,a.length);e.push(t)}else if(88===a.type){const t=s.ParseSectionMinimum(this.mb,a.offset,a.length);e.push(t)}}this.xyz=e}calcPositionWithXYZ(){const e=Array(this.xyz.length);for(let t=0;t<this.xyz.length;t++){const s=this.xyz[t],a=this.findNearestPosition(s[0],s[1]),i=s[4],r=[],n=i.map((e=>e[0])),o=D.destVincentyArray(a[2],a[3],a[4],n);for(let e=0;e<i.length;e++){const t=i[e],n=D.destVincenty(o[e][0],o[e][1],a[4]+90,t[1]);r.push([n[0],n[1],s[3]+t[2]])}e[t]=r}this.lines=e}_debugcalcPositionWithXYZ(){const e=[];for(let t=0;t<this.xyz.length;t++){const s=this.xyz[t],a=this.findNearestPosition(s[0],s[1]),i=s[4],r=[];for(let e=0;e<i.length;e++){const t=i[e],n=D.destVincenty(a[2],a[3],a[4],t[0]),o=D.destVincenty(n.lat,n.lng,a[4]+90,t[1]);r.push([o.lat,o.lng,s[3]+t[2]])}e.push(r)}this.lines2=e}_testFindNearest(){for(let e=0;e<this.xyz.length;e++){const t=this.xyz[e],s=this.findNearestPosition(t[0],t[1]),a=this.findNearestPositionLinear(t[0],t[1]);if(s!==a){console.log(`is diff ${t[0]} ${t[1]} at [${e}]`),console.log(s,a);const i=[s[0]-t[0],s[1]-t[1]],r=[a[0]-t[0],a[1]-t[1]];console.log(i,r);break}}}_debugFindNearest(e){const t=this.xyz[e],s=this.findNearestPosition(t[0],t[1]),a=this.findNearestPositionLinear(t[0],t[1]);if(s!==a){console.log(`is diff ${t[0]} ${t[1]} at [${e}]`),console.log(s,a);const i=[s[0]-t[0],s[1]-t[1]],r=[a[0]-t[0],a[1]-t[1]];console.log(i,r)}}findNearestPosition(e,t){let s,a=0,i=this.positions.length-1;for(;i-a>1;)s=Math.floor((a+i)/2),this.positions[s][0]<e||this.positions[s][0]===e&&this.positions[s][1]<t?a=s:i=s;if(i===a)return this.positions[a];const r=this.positions[a],n=this.positions[i],o=[Math.abs(e-r[0]),Math.abs(t-r[1])],c=[Math.abs(e-n[0]),Math.abs(t-n[1])];return o[0]>c[0]?n:o[0]<c[0]?r:o[1]>c[1]?n:r}findNearestPositionLinear(e,t){return this.positions.reduce(((s,a)=>{const i=[Math.abs(e-s[0]),Math.abs(t-s[1])],r=[Math.abs(e-a[0]),Math.abs(t-a[1])];return i[0]>r[0]?a:i[0]<r[0]?s:i[1]>r[1]?a:s}))}clearMemory(){this.positions=[],this.xyz=[],this.sections=[],this.mb=void 0}static destVincentyArray(e,t,s,a){const i=[],r=6378137,n=6356752.3142,o=1/298.257223563,c=s*Math.PI/180,l=Math.sin(c),d=Math.cos(c),u=(1-o)*Math.tan(e*Math.PI/180),p=1/Math.sqrt(1+u*u),h=u*p,U=Math.atan2(u,d),m=p*l,S=1-m*m,f=S*(r*r-n*n)/(n*n),g=1+f/16384*(4096+f*(f*(320-175*f)-768)),T=f/1024*(256+f*(f*(74-47*f)-128));for(let e=0;e<a.length;e++){const s=a[e];let r=s/(n*g),c=2*Math.PI;for(;Math.abs(r-c)>1e-12;){var E=Math.cos(2*U+r),D=Math.sin(r),M=Math.cos(r);c=r,r=s/(n*g)+T*D*(E+T/4*(M*(2*E*E-1)-T/6*E*(4*D*D-3)*(4*E*E-3)))}var R=h*D-p*M*d,P=Math.atan2(h*M+p*D*d,(1-o)*Math.sqrt(m*m+R*R)),C=o/16*S*(4+o*(4-3*S)),y=Math.atan2(D*l,p*M-h*D*d)-(1-C)*o*m*(r+C*D*(E+C*M*(2*E*E-1)));Math.atan2(m,-R);i.push([180*P/Math.PI,t+180*y/Math.PI])}return i}static destVincenty(e,t,s,a){for(var i=6378137,r=6356752.3142,n=1/298.257223563,o=a,c=s*Math.PI/180,l=Math.sin(c),d=Math.cos(c),u=(1-n)*Math.tan(e*Math.PI/180),p=1/Math.sqrt(1+u*u),h=u*p,U=Math.atan2(u,d),m=p*l,S=1-m*m,f=S*(i*i-r*r)/(r*r),g=1+f/16384*(4096+f*(f*(320-175*f)-768)),T=f/1024*(256+f*(f*(74-47*f)-128)),E=o/(r*g),D=2*Math.PI;Math.abs(E-D)>1e-12;){var M=Math.cos(2*U+E),R=Math.sin(E),P=Math.cos(E);D=E,E=o/(r*g)+T*R*(M+T/4*(P*(2*M*M-1)-T/6*M*(4*R*R-3)*(4*M*M-3)))}var C=h*R-p*P*d,y=Math.atan2(h*P+p*R*d,(1-n)*Math.sqrt(m*m+C*C)),b=n/16*S*(4+n*(4-3*S)),I=Math.atan2(R*l,p*P-h*R*d)-(1-b)*n*m*(E+b*R*(M+b*P*(2*M*M-1)));Math.atan2(m,-C);return[180*y/Math.PI,t+180*I/Math.PI]}static CreateInstanceFrom(e){const t=new D;return t.mb=e.mb,t.sections=e.sections,t.isLE=e.isLE,t.positions=e.positions,t.xyz=e.xyz,t.lines=e.lines,t}parseMeta(){const e={},t=this.parseMetaPosition();e.ts=t[0].ts,e.ms=t[0].ts.getTime(),e.lat=t[0].lat,e.lng=t[0].lng,e.ts2=t[1].ts,e.ms2=t[1].ts.getTime(),e.lat2=t[1].lat,e.lng2=t[1].lng;const s=this.parseMetaFirstRuntime();return e.eq=s.eq,e.eqid=s.eqid,e.count=this.parseMetaDepthSectionCount(),e.bytes=this.bytes,this.meta=e,e}parseMetaDepthSectionCount(){return this.sections.filter((e=>a.IsMyType(e.type)||o.IsMyType(e.type))).length}parseMetaPosition(){const e=n,t=this.sections.filter((t=>e.IsMyType(t.type)));return[t[0],t.at(-1)].map((t=>e.ParseSectionMinimum(this.mb,t.offset,this.isLE))).map((e=>({ts:g(e[0],e[1]),lat:e[2],lng:e[3]})))}parseMetaFirstRuntime(){const e=r,t=this.sections.find((t=>e.IsMyType(t.type))),s=e.ReadRuntime.model(this.mb,t.offset,this.isLE),a=e.ReadRuntime.serial(this.mb,t.offset,this.isLE);return{eq:"EM"+s,eqid:String(a)}}getMeta(){return this.meta}static GetMetaDesc(){return{eq:"EM + runtime[0].model",eqid:"runtime[0].serial",ts:"position[0].ts",ts2:"position.at(-1).ts",ms:"ts.getTime()",ms2:"ts2.getTime()",lat:"position[0].lat",lng:"position[0].lng",lat2:"position[1].lat",lng2:"position[1].lng",count:"number of xyz88 or depth datagram",bytes:"context.bytes from dataView.byteLength"}}}class M{static LoadArrayBuffer(e){let s=!0;const a=new DataView(e);a.getUint32(0,!0)>a.getUint32(0,!1)&&(s=!1);const i=M.ParseSectionTable(e,s);return i.sectionTable.forEach(((e,s)=>e.title=t.EMAll.DescType(e.type))),i}static ParseSectionTable(e,t){const a=new s(e);a.littleEndian=t;const i=a.parseBrief();return{dataView:a,sectionTable:i,littleEndian:t}}static ParseMeta(e){const t=M.LoadArrayBuffer(e),s=new D;return s.load(t.dataView,t.sectionTable,t.littleEndian),s.parseMeta(),s.getMeta()}}return{EMAll:s,EMXYZ88:a,EMParamInstall:i,EMRuntimeParam:r,EMPosition:n,EMDepthDatagra:o,EMSoundSpeedProfile:c,EMPUID:l,EMNetworkAttitudeVelocity:u,EMClock:p,EMAttitude:h,EMSeabedImage:U,EMSeabedImage89:m,EMPUStatusOutput:d,EMRawRangeAngle78:S,EMExtra:f,GetParser:E,SliceToSection:function(e,t){return new DataView(t.buffer,e.offset,e.len+s.BYTE_LENGTH)},ParseDateTime:g,ParserContext:D,ParserTest:M,ParseMeta:M.ParseMeta}})(),s=(()=>{class t{static TYPES=[1];static IsMyType(e){return-1<t.TYPES.findIndex((t=>t===e))}static TITLE="BinHeader";static STRUCT_BINARY_HEADER3200=new Map([["jobIDNum","U4"],["lineNum","U4"],["reelNum","U4"],["tracesPEns","U2"],["auxTracesPEns","U2"],["interval","U2"],["intervalOrg","U2"],["numSamplePTrace","U2"],["numSamplePTraceOrg","U2"],["code","U2"],["ensFold","U2"],["traceSortingCode","U2"],["vertSumCode","U2"],["sweepFreqStart","U2"],["sweepFreqEnd","U2"],["sweepLen","U2"],["sweepTypeCode","U2"],["traceNumSweepChannel","U2"],["sweepTTLenStart","U2"],["sweepTTLenEnd","U2"],["taperType","U2"],["corelTrace","U2"],["binGainRec","U2"],["ampRecM","U2"],["measureSystem","U2"],["impulseSigPol","U2"],["vibPolCode","U2"],["extNumTracePEns","U4"],["extNumAuxTracePEns","U4"],["extNumSample","U4"],["extInterval","F8"],["extIntervalOrG","F8"],["extNumSamplePTraceOrg","U4"],["extEnsFold","U4"],["constant1234","U4"]]);static STRUCT_BINARY_HEADER3500=new Map([["majorRev","U1"],["minorRev","U1"],["fixedLenTrace","U2"],["numExtTextHDR","U2"],["numAddTraceHDR","U4"],["timeCode","U2"],["numTraceInFile","U8"],["offsetTrace","U8"],["numTrailerStanza","I4"]]);static SAMPLE_FORMAT_CODE=[[1,"4-byte IBM floating-point",4,"F"],[2,"4-byte, two's complement integer",4,"I"],[3,"2-byte, two's complement integer",2,"I"],[4,"4-byte fixed-point with gain (obsolete)",4,"I"],[5,"4-byte IEEE floating-point",4,"F"],[6,"8-byte IEEE floating-point",8,"F"],[7,"3-byte two's complement integer",3,"I"],[8,"1-byte, two's complement integer",1,"I"],[9,"8-byte, two's complement integer",8,"I"],[10,"4-byte, unsigned integer",4,"I"],[11,"2-byte, unsigned integer",2,"I"],[12,"8-byte, unsigned integer",8,"I"],[15,"3-byte, unsigned integer",3,"I"],[16,"1-byte, unsigned integer",1,"I"]];static FindSampleFormatCode(e){return t.SAMPLE_FORMAT_CODE.find((t=>e===t[0]))}static DATE_TIME_CODE={1:"Local",2:"GMT",3:"Other",4:"UTC",5:"GPS"};static ReadBinaryHeader3200=e.CreateReader(t.STRUCT_BINARY_HEADER3200);static ReadBinaryHeader3500=e.CreateReader(t.STRUCT_BINARY_HEADER3500);static ParseSectionDescribe(s,a,i){const r=new Map;t.ReadBinaryHeader3200._toDescribeMap(s,a,r,i);const n=300-t.ReadBinaryHeader3200._size;for(let t=0;t<n/4;t++)r.set(`un_${t+1}`,e.Describe(0,"U",4));return t.ReadBinaryHeader3500._toDescribeMap(s,a+300,r,i),r}static SOA2Degree(e){return e/3600}parseDetail(){this.setLittleEndian(!1);const e=this.parse(SegY.STRUCT_BINARY_HEADER3200,3200),t=this.parse(SegY.STRUCT_BINARY_HEADER3500,3500);Object.keys(t).forEach(((t,s)=>e[t]=s)),this.saveBrief(e),this.setParseOffset(3600);const s=[];if(SegY.SAMPLE_FORMAT_CODE.IBM_FP_4===e.code||SegY.SAMPLE_FORMAT_CODE.IEEE_FP_4===e.code){for(this.setLittleEndian(!1);this.parseOffset<this.byteLength;){const e=this.parseTraceOne();s.push(e)}return{binHeader:e,traces:s}}alert("Only 32bit floating point implemented, please report")}parseTraceOne(){const e=this.parse(SegY.STRUCT_TRACE_HEADER),t={},s=new Date;if(s.setUTCFullYear(e.year),s.setUTCMonth(0),s.setUTCDate(e.day),s.setUTCHours(e.hour),s.setUTCMinutes(e.minute),s.setUTCSeconds(e.second),s.setUTCMilliseconds(0),t.date=s,t.dateBase=SegY.DATE_TIME_CODE[e.timeCode],2===e.coordUnit){const s=e.srcCoordX/36e5,a=e.srcCoordY/36e5;t.srcPos=[a,s]}this.addParseOffset(10);const a=[];for(let t=0;t<e.numSample;t++){const e=this.getFloat32(this.parseOffset);a.push(e),this.parseOffset=this.parseOffset+4}return{header:e,parsedHeader:t,data:a}}getPrettyPrintBinHeader(){const e=this.getBrief();if(!e)return"Not yet parsed, or invalid";return[`Major: ${e.majorRev}, Minor: ${e.minorRev}`,`Data format code: ${e.code} - ${this.getCodeStr(e.code)}`,`Sample per trace: ${e.numSamplePTrace}`,`Interval: ${e.interval}us`].join("\n")}getCodeStr(e){let t="";return Object.keys(SegY.SAMPLE_FORMAT_CODE).forEach((s=>{SegY.SAMPLE_FORMAT_CODE[s]===e&&(t=s)})),t}}class s{static TYPES=[2];static IsMyType(e){return-1<s.TYPES.findIndex((t=>t===e))}static TITLE="Trace";static STRUCT_TRACE_HEADER=new Map([["traceSeqLine","U4"],["traceSeqFile","U4"],["orgFieldRecNum","U4"],["traceNumOrg","U4"],["energySrc","U4"],["ensNum","U4"],["traceNumEns","U4"],["traceIDCode","U2"],["numVertSum","U2"],["numHoriSum","U2"],["dataUse","U2"],["distCent","U4"],["elevRecv","U4"],["surfElev","U4"],["srcDepth","U4"],["seisDatumRecv","U4"],["seisDatumSrc","U4"],["watColHeiSrc","U4"],["watColHeiRecv","U4"],["scalarElev","I2"],["scalarCoord","I2"],["srcCoordX","I4"],["srcCoordY","I4"],["grpCoordX","I4"],["grpCoordY","I4"],["coordUnit","U2"],["weatherVel","U2"],["subWeatherVel","U2"],["upSrcMS","U2"],["upGrpMS","U2"],["srcCorrMS","U2"],["grpCorrMS","U2"],["totMS","U2"],["lagAMS","U2"],["lagBMS","U2"],["delayRecMS","U2"],["muiteStartMS","U2"],["muiteEndMS","U2"],["numSample","U2"],["intervalSample","U2"],["gainType","U2"],["instGain","U2"],["instInitGain","U2"],["correlated","U2"],["sweepFreqS","U2"],["sweepFreqE","U2"],["sweepLen","U2"],["sweepType","U2"],["sweepTraceLenS","U2"],["sweepTraceLenE","U2"],["taperType","U2"],["aliasFFreq","U2"],["aliasFSlope","U2"],["notchFFreq","U2"],["notchFSlope","U2"],["lcFreq","U2"],["hcFreq","U2"],["lcSlope","U2"],["hcSlope","U2"],["year","U2"],["day","U2"],["hour","U2"],["minute","U2"],["second","U2"],["timeCode","U2"],["traceWeiFac","U2"],["geoGNRoll","U2"],["geoGNTrace","U2"],["geoGNLTrace","U2"],["gapSize","U2"],["overTravel","U2"],["XcoordEns","U4"],["YcoordEns","U4"],["PSinline","U4"],["PScrossline","U4"],["shotpoint","U4"],["scalarShot","U2"],["traceUnit","I2"],["transC","U8"],["transUnit","I2"],["id","U2"],["scalarTimes","U2"],["srcType","I2"],["srcEnergyDir","U2"],["sourceM1","U4"],["sourceM2","U2"],["srcUnit","I2"],["useless1","U4"],["useless2","U4"],["useless3","U2"]]);static ReadTraceHeader=e.CreateReader(s.STRUCT_TRACE_HEADER);static ParseSectionDescribe4F(t,a,i){const r=new Map;s.ReadTraceHeader._toDescribeMap(t,a,r,i);const n=r.get("numSample").v;for(let o=0;o<n;o++){const n=a+s.ReadTraceHeader._size+4*o,c=t.getFloat32(n,i);r.set("dataF4_"+o,e.Describe(c,"F4",4))}return r}static ParseSection(e,t,a){const i=s.ReadTraceHeader.traceSeqLine(e,t,a),r=s.ReadTraceHeader.numSample(e,t,a),n=s.ReadTraceHeader.intervalSample(e,t,a),o=s.ReadTraceHeader.year(e,t,a),c=s.ReadTraceHeader.day(e,t,a),l=s.ReadTraceHeader.hour(e,t,a),d=s.ReadTraceHeader.minute(e,t,a),u=s.ReadTraceHeader.second(e,t,a),p=s.ReadTraceHeader.timeCode(e,t,a),h=new Date;h.setUTCFullYear(o),h.setUTCMonth(0),h.setUTCDate(c),h.setUTCHours(l),h.setUTCMinutes(d),h.setUTCSeconds(u),h.setUTCMilliseconds(0);let U=0,m=0;return 2===s.ReadTraceHeader.coordUnit(e,t,a)&&(m=s.ReadTraceHeader.srcCoordX(e,t,a)/36e5,U=s.ReadTraceHeader.srcCoordY(e,t,a)/36e5),[i,r,n,h,p,U,m]}static ParseSectionData4F(e,t,a){const i=s.ReadTraceHeader.numSample(e,t,a),r=[];for(let n=0;n<i;n++){const i=t+s.ReadTraceHeader._size+4*n,o=e.getFloat32(i,a);r.push(o)}return r}static ParseSectionData(e,a,i,r){const n=t.SAMPLE_FORMAT_CODE.find((e=>e[0]===r));if(n)return 4===n[2]&&"F"===n[3]?s.ParseSectionData4F(e,a,i):void 0}}class a{static TYPES=[3];static IsMyType(e){return-1<a.TYPES.findIndex((t=>t===e))}static TITLE="Text";static SIZE_TEXT_HEADER=3200;static MapEBCDIC={0:0,1:1,2:2,3:3,4:26,5:9,6:26,7:127,8:26,9:26,10:26,11:11,12:12,13:13,14:14,15:15,16:16,17:17,18:18,19:19,20:26,21:26,22:8,23:26,24:24,25:25,26:26,27:26,28:28,29:29,30:30,31:31,32:26,33:26,34:26,35:26,36:26,37:10,38:23,39:27,40:26,41:26,42:26,43:26,44:26,45:5,46:6,47:7,48:26,49:26,50:22,51:26,52:26,53:26,54:26,55:4,56:26,57:26,58:26,59:26,60:20,61:21,62:26,63:26,64:32,65:26,66:26,67:26,68:26,69:26,70:26,71:26,72:26,73:26,74:91,75:46,76:60,77:40,78:43,79:33,80:38,81:26,82:26,83:26,84:26,85:26,86:26,87:26,88:26,89:26,90:93,91:36,92:42,93:41,94:59,95:94,96:45,97:47,98:26,99:26,100:26,101:26,102:26,103:26,104:26,105:26,106:124,107:44,108:37,109:95,110:62,111:63,112:26,113:26,114:26,115:26,116:26,117:26,118:26,119:26,120:26,121:96,122:58,123:35,124:64,125:39,126:61,127:34,128:26,129:97,130:98,131:99,132:100,133:101,134:102,135:103,136:104,137:105,138:26,139:26,140:26,141:26,142:26,143:26,144:26,145:106,146:107,147:108,148:109,149:110,150:111,151:112,152:113,153:114,154:26,155:26,156:26,157:26,158:26,159:26,160:26,161:126,162:115,163:116,164:117,165:118,166:119,167:120,168:121,169:122,170:26,171:26,172:26,173:26,174:26,175:26,176:26,177:26,178:26,179:26,180:26,181:26,182:26,183:26,184:26,185:26,186:26,187:26,188:26,189:26,190:26,191:26,192:123,193:65,194:66,195:67,196:68,197:69,198:70,199:71,200:72,201:73,202:26,203:26,204:26,205:26,206:26,207:26,208:125,209:74,210:75,211:76,212:77,213:78,214:79,215:80,216:81,217:82,218:26,219:26,220:26,221:26,222:26,223:26,224:92,225:26,226:83,227:84,228:85,229:86,230:87,231:88,232:89,233:90,234:26,235:26,236:26,237:26,238:26,239:26,240:48,241:49,242:50,243:51,244:52,245:53,246:54,247:55,248:56,249:57,250:26,251:26,252:26,253:26,254:26,255:26};static ParseTextHeader0(e,t,s){const i=e.buffer.slice(t,t+a.SIZE_TEXT_HEADER),r=new DataView(i),n=r.getUint8(0);let o,c;if(67===n?o="ASCII":195===n&&(o="EBCDIC"),"EBCDIC"===o){const e=new Uint8Array(a.SIZE_TEXT_HEADER);for(let t=0;t<a.SIZE_TEXT_HEADER;t++){const s=a.MapEBCDIC[r.getUint8(t)];e[t]=s||32}c=String.fromCharCode.apply(null,e)}else"ASCII"===o&&(c=String.fromCharCode.apply(null,new Uint8Array(i)));const l={text:c,lines:void 0,type:o};if(c){const e=c.match(/.{80}/g);l.lines=e}return l}static ParseSectionDescribe(t,s,i){const r=new Map,n=a.ParseTextHeader0(t,s,i).text||"";return r.set("text",e.Describe(n,"A"+a.SIZE_TEXT_HEADER,a.SIZE_TEXT_HEADER)),r}}class i{static LoadArrayBuffer(e){let t;const s=new DataView(e),a=[[s.getUint32(3204,!0),s.getUint32(3204,!1)],[s.getUint16(3212,!0),s.getUint16(3212,!1)],[s.getUint16(3224,!0),s.getUint16(3224,!1)]];for(let e=0;e<a.length;e++){const s=a[e],i=s[0],r=s[1];if(i>r){t=!1;break}if(i<r){t=!0;break}}!0!==t&&!1!==t&&(t=!0,console.info("Could not judge endianness!!, proceed as little endian"));return i.ParseSectionTable(e,t)}static ParseSectionTable(e,i){const r={dataView:void 0,sections:void 0,isLE:i,bin:void 0},n=[],o=new DataView(e),c=a.ParseTextHeader0(o,0,i),l=t.ParseSectionDescribe(o,3200,i);r.dataView=o,r.bin=l,r.text=c;const d={type:a.TYPES[0],title:a.TITLE,offset:0,len:3200},u={type:t.TYPES[0],title:t.TITLE,offset:3200,len:400};n.push(d),n.push(u);const p=l.get("offsetTrace").v;let h=3600+parseInt(p),U=t.SAMPLE_FORMAT_CODE[4];const m=l.get("code").v,S=t.SAMPLE_FORMAT_CODE.find((e=>m===e[0]));void 0===S?(console.error("Critical error, sample format code is Mandatory for all data but its empty"),console.info(`Sample code is ${m}`),console.info("Just proceed with 4 byte floating point")):U=S;const f=U[2],g=s.ReadTraceHeader._size;let T=h;for(;T<o.byteLength;){const e=g+s.ReadTraceHeader.numSample(o,T,i)*f,t={type:s.TYPES[0],title:s.TITLE,offset:T,len:e};n.push(t),T+=e}return r.sections=n,r}static ParseMeta(e){const t=new r;return t.load(e),t.parseMeta(),t.getMeta()}}class r{constructor(){this.dataView=void 0,this.sections=void 0,this.isLE=!0,this.binHeader=void 0,this.sampleCode=0,this.sampleCodeFound=void 0,this.traces=[]}load(e){const s=i.LoadArrayBuffer(e);this.dataView=s.dataView,this.sections=s.sections,this.isLE=s.isLE,this.binHeader=s.bin,this.sampleCode=this.binHeader.get("code").v,0<this.sampleCode&&(this.sampleCodeFound=t.FindSampleFormatCode(this.sampleCode))}parseTraces(){const e=this.isLE,t=this.sections.filter((e=>s.IsMyType(e.type))).map((t=>s.ParseSectionData(this.dataView,t.offset,e,this.sampleCode)));return this.traces=t,this.traces}clearMemory(){this.dataView=void 0,this.sections=[],this.traces=[]}parseMeta(){const e={},t=this.sections.filter((e=>s.IsMyType(e.type))),a=[t[0],t.at(-1)].map((e=>s.ParseSection(this.dataView,e.offset,this.isLE,this.sampleCode)));return e.ts=a[0][3],e.ms=e.ts.getTime(),e.lat=a[0][5],e.lng=a[0][6],e.ts2=a[1][3],e.ms2=e.ts2.getTime(),e.lat2=a[1][5],e.lng2=a[1][6],e.desc=`interval : ${a[0][2]}, number samples : ${a[0][1]}`,e.count=t.length,e.bytes=this.dataView.byteLength,this.meta=e,this.meta}getMeta(){return this.meta}static GetMetaDesc(){return{ts:"trace[0].ts",ms:"trace[0].ts.getTime()",lat:"trace[0].lat",lng:"trace[0].lng",ts2:"trace[-1].ts",ms2:"trace[-1].ts.getTime()",lat2:"trace[-1].lat",lng2:"trace[-1].lng",desc:"trace[0].interval, trace[0].numSample",count:"trace.length",bytes:"arrayBuffer.byteLength"}}}const n=(()=>{const e=new Map;return[t,s].forEach((t=>{t.TYPES.forEach((s=>{e.set(s,t)}))})),t=>e.get(t)})();return{SEGY:t,SEGYTrace:s,SEGYText:a,GetParser:n,SliceToSection:function(e,t){return new DataView(t.buffer,e.offset,e.len)},ParserContext:r,ParserTest:i,ParseMeta:i.ParseMeta}})(),a=(()=>{function e(e,t){const s=t.match(/([^\.\[]*)/g),a=[];if(s.forEach((e=>{0!==e.length&&(e.match(/(\d+)\]$/)?a.push(parseInt(e)):a.push(e))})),0===a.length)return void console.log(`getValueFromObject Invalid expression ${e}, '${t}'`);let i=e;return a.forEach((e=>i=i[e])),i}class t{constructor(){this.listFiles=[],this.listURLs=[],this.mapGroup={}}addFile(e){const a=t.MatchFileName(e.name);a&&!0===a.found&&(this.listFiles.push(e),this.mapGroup.hasOwnProperty(a.filenameLower)||(this.mapGroup[a.filenameLower]=new s),this.mapGroup[a.filenameLower].addFile(e))}addURL(e){const a=t.MatchFileName(e);a&&!0===a.found&&(this.listURLs.push(e),this.mapGroup.hasOwnProperty(a.filenameLower)||(this.mapGroup[a.filenameLower]=new s),this.mapGroup[a.filenameLower].addURL(e))}getGroup(e){if(this.mapGroup.hasOwnProperty(e))return this.mapGroup[e]}getNames(){return Object.keys(this.mapGroup)}getGroups(){return Object.values(this.mapGroup)}static MatchFileName(e){const t=e.match(/([^/]*)\.([^.]*)$/i);if(t){const e=t[1],s=e.toLowerCase(),a=t[2],i=a.toLowerCase(),r=["hex","bl","hdr","xmlcon"].findIndex((e=>i===e));return{filename:e,filenameLower:s,ext:a,extLower:i,found:-1!==r}}}}class s{constructor(){this.files={bl:void 0,hdr:void 0,hex:void 0,xmlcon:void 0},this.urls={bl:void 0,hdr:void 0,hex:void 0,xmlcon:void 0},this.instance={bl:void 0,hdr:void 0,hex:void 0,xmlcon:void 0},this.name=void 0}addFile(e){const s=t.MatchFileName(e.name);s&&!0===s.found&&(this.files[s.extLower]=e,this.name=s.filename)}addURL(e){const s=t.MatchFileName(e);s&&!0===s.found&&(this.urls[s.extLower]=e,this.name=s.filename)}getName(){return this.name}async parse(){if(this.files.hex){const e=new o;this.instance.hex=e,e.setParent(this),await e.setFile(this.files.hex)}if(this.files.xmlcon){const e=new c;this.instance.xmlcon=e,e.setParent(this),await e.setFile(this.files.xmlcon)}if(this.files.hdr){const e=new r;this.instance.hdr=e,e.setParent(this),await e.setFile(this.files.hdr)}if(this.files.bl){const e=new n;this.instance.bl=e,e.setParent(this),await e.setFile(this.files.bl)}}async parseURLs(){if(this.urls.hex){const e=new o;this.instance.hex=e,e.setParent(this),await e.setFileURL(this.urls.hex)}if(this.urls.xmlcon){const e=new c;this.instance.xmlcon=e,e.setParent(this),await e.setFileURL(this.urls.xmlcon)}if(this.urls.hdr){const e=new r;this.instance.hdr=e,e.setParent(this),await e.setFileURL(this.urls.hdr)}if(this.urls.bl){const e=new n;this.instance.bl=e,e.setParent(this),await e.setFileURL(this.urls.bl)}}unload(){}getHex(){return this.instance.hex}getXmlcon(){return this.instance.xmlcon}getHdr(){return this.instance.hdr}getBl(){return this.instance.bl}parseMeta(){const e={},t={},s=this.getHex(),a=this.getHdr(),i=this.getXmlcon();if(s){const a=s.parseMeta(),i=o.GetMetaDesc();["lat","lng","ts","ms","count","desc","bytes"].forEach((s=>{e[s]=a[s],t[s]=i[s]}))}else if(a){const s=a.parseMeta(),i=r.GetMetaDesc();["lat","lng","ts","ms","bytes"].forEach((a=>{e[a]=s[a],t[a]=i[a]}))}if(i){const s=i.parseMeta(),a=c.GetMetaDesc();["eq","eqid"].forEach((i=>{e[i]=s[i],t[i]=a[i]}))}return this.meta=e,this.metaDesc=t,e}getMeta(){return this.meta}static GetMetaDesc(){return{lat:"HEX, HDR string NMEA Latitude = lat",lng:"HEX, HDR string NMEA Longitude = lng",ts:"HEX, HDR string NMEA UTC (Time) = ts",ms:"HEX, HDR string NMEA UTC (Time) = ts to ms",count:"HEX length of line",desc:"HEX getParsingDescription()",bytes:"HEX, HDR content-length or file.size"}}}class a{constructor(){this.parent=void 0}setParent(e){this.parent=e}getHex(){if(this.parent)return this.parent.getHex()}getXmlcon(){if(this.parent)return this.parent.getXmlcon()}getBl(){if(this.parent)return this.parent.getBl()}getHdr(){if(this.parent)return this.parent.getHdr()}}class r extends a{constructor(){super(),this.file=void 0,this.parsedHDR=void 0}static parseHDR(e){const t={bytes:e.match(/Number of Bytes Per Scan = (.*)$/m),lat:e.match(/NMEA Latitude = (.*)$/m),lng:e.match(/NMEA Longitude = (.*)$/m),utc:e.match(/NMEA UTC \(Time\) = (.*)$/m),scanAvg:e.match(/Number of Scans Averaged by the Deck Unit = (.*)$/m)};if(t.bytes&&(t.bytes=parseInt(t.bytes[1])),t.lat){t.nmeaLat=t.lat[1];const e=t.lat[1].match(/(\d*) ([\d\.]*) (N|S)/);if(e){const s=parseInt(e[1]),a=parseFloat(e[2])/60;t.lat=s+a,"S"===e[3]&&(t.lat=-1*t.lat)}}if(t.lng){t.nmeaLng=t.lng[1];const e=t.lng[1].match(/(\d*) ([\d\.]*) (E|W)/);if(e){const s=parseInt(e[1]),a=parseFloat(e[2])/60;t.lng=s+a,"W"===e[3]&&(t.lng=-1*t.lng)}}if(t.utc){const e=t.utc[1];let s=new Date(e);s=new Date(s.getTime()+60*s.getTimezoneOffset()*1e3*-1),t.nmeaUTC=e,t.utc=s}return t.scanAvg&&(t.scanAvg=parseInt(t.scanAvg[1])),t}async setFile(e){const t=await e.text();this.setDataSource(t),this.bytes=e.size}async setFileURL(e){const t=await fetch(e),s=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt(s)}setDataSource(e){this.dataSource=e;const t=r.parseHDR(this.dataSource);this.parsedHDR=t}getParsedHDR(){return this.parsedHDR}parseMeta(){if(!this.parsedHDR)return void console.error("hdr should parsed before");const e={};return e.lat=this.parsedHDR.lat,e.lng=this.parsedHDR.lng,e.ts=this.parsedHDR.utc,e.ms=e.ts.getTime(),e.bytes=this.bytes,this.meta=e,e}getMeta(){return this.meta}static GetMetaDesc(){return{lat:"HDR string NMEA Latitude = lat",lng:"HDR string NMEA Longitude = lng",ts:"HDR string NMEA UTC (Time) = ts",ms:"HDR string NMEA UTC (Time) = ts to ms",bytes:"HDR content-length header or file.size"}}}class n extends a{constructor(){super(),this.file=void 0,this.dataSource=void 0}static parseBL(e){const t={};let s=0;e.split("\n").forEach((e=>{const a=n.parseBLLine(e);a&&(s++,t[a.fired]=a)}));return{countFired:s,fired:t}}static parseBLLine(e){const t=e.split(",");if(5!==t.length)return!1;return{fired:parseInt(t[1]),dateStr:t[2],rawLineS:parseInt(t[3]),rawLineE:parseInt(t[4])}}static parseBLHEX(e,t){e.fired&&t&&Object.keys(e.fired).forEach((s=>{const a=e.fired[s],i=t.parseValue(a.rawLineS),r=i.value.altimeter,n=i.value.f2depth,o=i.value.f0,c=i.value.f1psu;r&&(a.altimeter=i.value.altimeter),a.depth=n,a.t=o,a.s=c}))}async setFile(e){const t=await e.text();this.setDataSource(t),this.bytes=e.size}async setFileURL(e){const t=await fetch(e),s=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt(s)}setDataSource(e){this.dataSource=e;const t=n.parseBL(this.dataSource);if(!this.getHex())return console.error("CTDBL.setDataSource : got no hex, can not proceed"),void console.log(t);n.parseBLHEX(t,this.getHex()),this.parsedBL=t}getParsedBL(){return this.parsedBL}}class o extends a{static TIME_BASE_MS=9466848e5;constructor(){super(),this.file=void 0,this.dataSource=void 0,this.parsingDesc={countFreq:3,countAD:0,countADWords:0,surfacePar:!1,nmeaPosition:!1,nmeaDepth:!1,nmeaTime:!1,scanTime:!1,scanAvg:-99}}async setFile(e){const t=await e.text();this.setDataSource(t),this.bytes=e.size}async setFileURL(e){const t=await fetch(e),s=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt(s)}setDataSource(e){this.updateParsingDescription();const t=o.SplitEdge(e);this.header=t.header,this.body=t.body,this.bodyLength=t.bodyLength,this.lineLength=t.lineLength,this.EOLLength=t.EOLLength,this.parseHeader()}static SplitEdge(e){const t=e.slice(0,2048);let s;for(let e=0;e<t.length-1;e++){if(10===t.charCodeAt(e)){if(42!==t.charCodeAt(e+1)){s=e;break}}}if(!s)return;const a=t.slice(0,s),i=e.slice(s+1);let r=-1,n=-1,o=1;for(let e=0;e<1024;e++)if(10===i.charCodeAt(e)){n=e+1,r=i.length/n;break}13===i.charCodeAt(n-2)&&(o=2);return{header:a,body:i,bodyLength:r,lineLength:n,EOLLength:o,getLine:e=>{if(e>=r)return;const t=n*e,s=t+n;return i.slice(t,s-o)}}}static Ascii2ta(e){const t=new Uint8Array(e.length/2);let s=0;for(let a=0;a<e.length;a+=2){const i=(parseInt(e[a],16)<<4)+parseInt(e[a+1],16);t[s++]=i}return t}parseHeader(){const e=r.parseHDR(this.header);if(this.parsedHDR=e,1===this.parsedHDR.scanAvg){const e=parseInt(this.getLength()/24);this.parsedHDR.scanDuration=e}else this.parsedHDR.scanDuration=-99}getParsedHDR(){return this.parsedHDR}getRaw(e){if(e>=this.bodyLength)return;const t=this.lineLength*e,s=t+this.lineLength,a=this.body.slice(t,s-this.EOLLength);return o.Ascii2ta(a)}parseValue(e){const t=this.getXmlcon();if(!t)return console.error("CTDHex.getValue : No xmlcon given"),!1;const s=t.getParsedMap(),a=t.findSensorKeyByType("Altimeter"),i=this.parseRaw(e),r=i.psT*s.f2.coef.AD590M+s.f2.coef.AD590B,n=s.f0.getValue(i.f0).DegreeC,o=s.f2.getValue(i.f2,r).psi,c=l.PSI2Decibar(o),d=l.DECIBAR2Depth(c,i.lat),u=s.f1.getValue(i.f1,n,c).SPerM,p=l.COND2PSU(u,n,c);if(i.value={f0:n,f1:u,f1psu:p,f2:o,f2decibar:c,f2depth:d},a){const e=i[a],t=s[a].getValue(e).meter;i.value.altimeter=t}return i}parseRaw(e){const t=this.getRaw(e);return this._parseBasic(t)}parseDepthOnly(e){const t=this.getRaw(e);return this._parseDepthOnly(t)}_parseBasic(e){const t={},s=this.parsingDesc;let a=0;for(let i=0;i<s.countFreq;i++)t["f"+i]=256*e[a++]+e[a++]+e[a++]/256;const i=[];for(let t=0;t<s.countADWords;t++)i.push(e[a++]<<16|e[a++]<<8|e[a++]);let r=0;if(i.forEach((e=>{t["v"+r]=5*(1-(e>>>12)/4095),r++,t["v"+r]=5*(1-(4095&e)/4095),r++})),s.surfacePar){a++;const s=e[a++]<<8|e[a++];t.spV=(4095&s)/819}if(s.nmeaPosition){let s=(65536*e[a++]+256*e[a++]+e[a++])/5e4,i=(65536*e[a++]+256*e[a++]+e[a++])/5e4;const r=e[a++];1===r&128&&(s*=-1),1===r&64&&(i*=-1),t.lat=s,t.lng=i}if(s.nmeaTime){const s=e[a++]|e[a++]<<8|e[a++]<<16|e[a++]<<24,i=o.TIME_BASE_MS+1e3*s;t.date=new Date(i),t.dateMS=i}const n=e[a++]<<8|e[a++];return t.psT=n>>>4,t.CTDStatus={pump:1==(1&n),bot:2==(2&n),ws:4==(4&n),cr:8==(8&n),s:(15&n).toString(2).padStart(4,"0")},t.moduloCount=e[a++],t}_parseDepthOnly(e){const t={},s=this.parsingDesc;let a=0;if(a=6,t.f2=256*e[a++]+e[a++]+e[a++]/256,a=3*s.countFreq,a+=3*s.countADWords,s.surfacePar&&(a+=3),s.nmeaPosition){let s=(65536*e[a++]+256*e[a++]+e[a++])/5e4,i=(65536*e[a++]+256*e[a++]+e[a++])/5e4;const r=e[a++];1===r&128&&(s*=-1),1===r&64&&(i*=-1),t.lat=s,t.lng=i}s.nmeaTime&&(a+=4);const i=e[a++]<<8|e[a++];return t.psT=i>>>4,t}updateParsingDescription(){const e=this.getXmlcon();if(!e)return;const t=e.getInstrument(),s=5-t.freqSuppress,a=8-t.voltSuppress,i=a/2,r=1===t.surfacePar,n=1===t.nmeaPosition,o=1===t.nmeaDepth,c=1===t.nmeaTime,l=1===t.scanTime;this.parsingDesc={countFreq:s,countAD:a,countADWords:i,surfacePar:r,nmeaPosition:n,nmeaDepth:o,nmeaTime:c,scanTime:l,scanAvg:t.scanAvg}}getLength(){return this.bodyLength}getParsingDescription(){return this.parsingDesc}getParsedHDR(){return this.parsedHDR}unload(){this.body=void 0}parseMeta(){if(!this.parsedHDR)return void console.error("hdr should parsed before");const e=this.getParsingDescription(),t=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join(", "),s={};return s.lat=this.parsedHDR.lat,s.lng=this.parsedHDR.lng,s.ts=this.parsedHDR.utc,s.ms=s.ts.getTime(),s.count=this.getLength(),s.desc=t,s.bytes=this.bytes,this.meta=s,s}getMeta(){return this.meta}static GetMetaDesc(){return{lat:"HEX HDR string NMEA Latitude = lat",lng:"HEX HDR string NMEA Longitude = lng",ts:"HEX HDR string NMEA UTC (Time) = ts",ms:"HEX HDR string NMEA UTC (Time) = ts to ms",count:"HEX getLength()",desc:"HEX getParsingDescription()",bytes:"HEX content-length header or file.size"}}}class c extends a{static SENSOR_MAP=[{sensorID:3,attribute:"ConductivitySensor",title:"Conductivity",coef:{CPcor:"Coefficients[1].CPcor",CTcor:"Coefficients[1].CTcor",G:"Coefficients[1].G",H:"Coefficients[1].H",I:"Coefficients[1].I",J:"Coefficients[1].J",WBOTC:"Coefficients[1].WBOTC"},getValue:(e,t,s,a)=>{const i=t/1e3;return{SPerM:(e.G+e.H*Math.pow(i,2)+e.I*Math.pow(i,3)+e.J*Math.pow(i,4))/10*(1+e.CTcor*s+e.CPcor*a)}}},{sensorID:55,attribute:"TemperatureSensor",title:"Temperature",coef:["F0","G","H","I","J","Offset","Slope","UseG_J"],getValue:(e,t)=>{const s=e.F0/t,a=Math.log(s);return{DegreeC:1/(e.G+e.H*a+e.I*Math.pow(a,2)+e.J*Math.pow(a,3))-273.15}}},{sensorID:45,attribute:"PressureSensor",title:"Pressure",coef:["AD590B","AD590M","C1","C2","C3","D1","D2","Offset","Slope","T1","T2","T3","T4","T5"],getValue:(e,t,s)=>{const a=e.C1+e.C2*s+e.C3*Math.pow(s,2),i=e.D1+e.D2*s,r=e.T1+e.T2*s+e.T3*Math.pow(s,2)+e.T4*Math.pow(s,3)+e.T5*Math.pow(s,4),n=1/t*1e6,o=a*(1-Math.pow(r,2)/Math.pow(n,2))*(1-i*(1-Math.pow(r,2)/Math.pow(n,2)));return{psia:o,psi:o-14.7}}},{sensorID:38,attribute:"OxygenSensor",title:"Oxygen",coef:{A:"CalibrationCoefficients[1].A",B:"CalibrationCoefficients[1].B",C:"CalibrationCoefficients[1].C",D0:"CalibrationCoefficients[1].D0",D1:"CalibrationCoefficients[1].D1",D2:"CalibrationCoefficients[1].D2",E:"CalibrationCoefficients[1].E",H1:"CalibrationCoefficients[1].H1",H2:"CalibrationCoefficients[1].H2",H3:"CalibrationCoefficients[1].H3",Soc:"CalibrationCoefficients[1].Soc",Tau20:"CalibrationCoefficients[1].Tau20",offset:"CalibrationCoefficients[1].offset"}},{sensorID:71,attribute:"WET_LabsCStar",title:"Transmissometer",coef:["B","M","PathLength"]},{sensorID:20,attribute:"FluoroWetlabECO_AFL_FL_Sensor",title:"Fluorometer",coef:["ScaleFactor","Vblank"]},{sensorID:42,attribute:"PAR_BiosphericalLicorChelseaSensor",title:"PAR_Biospherical",coef:["B","M","Multiplier","Offset"]},{sensorID:0,attribute:"AltimeterSensor",title:"Altimeter",coef:["ScaleFactor","Offset"],getValue:(e,t)=>({meter:300*t/e.ScaleFactor+e.Offset})},{sensorID:27,attribute:"NotInUse",title:"NotInUse"}];constructor(){super(),this.file=void 0,this.dataSource=void 0,this.parsedMap={f0:void 0,f1:void 0,f2:void 0,f3:void 0,f4:void 0,v0:void 0,v1:void 0,v2:void 0,v3:void 0,v4:void 0,v5:void 0,v6:void 0,v7:void 0}}static parseXml(e){var t=null;if(window.DOMParser)try{t=(new DOMParser).parseFromString(e,"text/xml")}catch(e){t=null}return t}static xmlToJson(e){var t={};if(1==e.nodeType){if(e.attributes.length>0){t["@attributes"]={};for(var s=0;s<e.attributes.length;s++){var a=e.attributes.item(s);t["@attributes"][a.nodeName]=a.nodeValue}}}else 3==e.nodeType&&(t=e.nodeValue);if(e.hasChildNodes())for(var i=0;i<e.childNodes.length;i++){var r=e.childNodes.item(i),n=r.nodeName;if(void 0===t[n])t[n]=c.xmlToJson(r);else{if(void 0===t[n].push){var o=t[n];t[n]=[],t[n].push(o)}t[n].push(c.xmlToJson(r))}}return t}static parseCTDXMLConfig(e){const t=[];try{e.SBE_InstrumentConfiguration.Instrument.SensorArray.Sensor.forEach(((e,s)=>{const a=c.parseSensor(e);a&&(a.key=s,t.push(a))}))}catch(e){console.log(e)}return t}static parseSensor(t){const s=t["@attributes"].SensorID,a=c.SENSOR_MAP.find((e=>e.sensorID==s));if(!a)return console.warn(`CTDXMLCON.parseSensor sensor ID not found ${s}`),!1;const i=t[a.attribute],r=i.SerialNumber["#text"];let n,o,l=i.CalibrationDate["#text"];return l||(l=""),a.coef&&("function"==typeof a.coef?n=a.coef(i):"object"==typeof a.coef&&(n={},Array.isArray(a.coef)?a.coef.forEach((t=>{const s=e(i,t);s&&s.hasOwnProperty("#text")?n[t]=parseFloat(s["#text"]):(console.error("CTDXMLCON.parseSensor Invalid Coef"),console.error(t))})):Object.keys(a.coef).forEach((t=>{const s=a.coef[t],r=e(i,s);r&&r.hasOwnProperty("#text")?n[t]=parseFloat(r["#text"]):(console.error("CTDXMLCON.parseSensor Invalid Coef"),console.error(t))})))),a.getValue&&"function"==typeof a.getValue&&(o=(...e)=>a.getValue(n,...e)),{id:s,type:a.title,serial:r,calibration:l,coef:n,getValue:o}}async setFile(e){const t=await e.text();this.setDataSource(t),this.bytes=e.size}async setFileURL(e){const t=await fetch(e),s=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt(s)}setDataSource(e){const t=c.parseXml(e),s=c.xmlToJson(t);this.dataSource=s,this.parsed=c.parseCTDXMLConfig(s);const a=s.SBE_InstrumentConfiguration.Instrument;this.instrument={freqSuppress:parseInt(a.FrequencyChannelsSuppressed["#text"]),voltSuppress:parseInt(a.VoltageWordsSuppressed["#text"]),nmeaDepth:parseInt(a.NmeaDepthDataAdded["#text"]),nmeaPosition:parseInt(a.NmeaPositionDataAdded["#text"]),nmeaTime:parseInt(a.NmeaTimeAdded["#text"]),scanTime:parseInt(a.ScanTimeAdded["#text"]),surfacePar:parseInt(a.SurfaceParVoltageAdded["#text"]),scanAvg:parseInt(a.ScansToAverage["#text"])},["f0","f1","f2","f3","f4","v0","v1","v2","v3","v4","v5","v6","v7"].forEach(((e,t)=>{const s=this.getSensorAt(t);s&&"NotInUse"!==s.type&&(this.parsedMap[e]=s)}));const i=this.getHex();i&&i.updateParsingDescription()}parseMeta(){if(!this.dataSource)return console.error("Required dataSource json from xml"),!1;const e={},t=this.dataSource.SBE_InstrumentConfiguration.Instrument;e.eq=t.Name["#text"];const s=t.SensorArray.Sensor.find((e=>"45"===e["@attributes"].SensorID));return e.eqid=s.PressureSensor.SerialNumber["#text"],e.bytes=this.bytes,this.meta=e,this.meta}getMeta(){return this.meta}static GetMetaDesc(){return{eq:"XMLCON.Instrument.Name",eqid:"XMLCON.Instrument.SensorArray.Sensor.SensorID == 45 serial",bytes:"XMLCON content-length header or file.size"}}getInstrument(){return this.instrument}getSensorAt(e){if(this.parsed)return e<this.parsed.length?this.parsed[e]:void 0;console.error(`CTDXMLCON.getSensorAt Not yet parsed ${e}`)}getParsedMap(){return this.parsedMap}findSensorKeyByType(e){const t=this.getParsedMap();if(!t)return console.log("CTDXmlcon.findSensorType : no xml parsed"),!1;let s;return Object.keys(t).forEach((a=>{const i=t[a];i&&e===i.type&&(s=a)})),s}}class l{static D="&deg;";static DC="&deg;C";static SpM="S/m";static PSU="PSU";static M="m";static MpS="m/s";static PSI2Decibar(e){return.689476*e}static DECIBAR2Depth(e,t){let s,a,i;return s=Math.sin(t/57.29578),s*=s,i=9.780318*(1+(.0052788+236e-7*s)*s)+1092e-9*e,a=(((-182e-17*e+2.279e-10)*e-22512e-9)*e+9.72659)*e,i&&(a/=i),a}static COND2PSU(e,t,s){const a=[.008,-.1692,25.3851,14.0941,-7.0261,2.7081],i=[5e-4,-.0056,-.0066,-.0375,.0636,-.0144];let r,n,o,c,l,d,u,p,h;if(e<=0)return 0;for(r=(e*=10)/42.914,p=1+.03426*t+4464e-7*t*t+.4215*r+-.003107*r*t,p&&(o=1+s*(207e-7+s*(3989e-18*s-6.37e-10))/p),p=o*(.6766097+t*(.0200564+t*(.0001104259+t*(1.0031e-9*t-6.9698e-7)))),p&&(n=r/p),n<=0&&(n=1e-6),l=d=0,h=0;h<6;h++)c=Math.pow(n,h/2),l+=a[h]*c,d+=i[h]*c;return p=1+.0162*(t-15),u=p?l+d*(t-15)/p:-99,u}static SVChenMillero(e,t,s){let a,i,r,n,o,c,l,d,u,p,h,U,m,S,f,g,T;return S=s/10,e<0&&(e=0),f=Math.sqrt(e),g=.001727-79836e-10*S,d=73637e-9+1.7945e-7*t,l=-.01922-442e-7*t,c=l+d*S,o=(-3389e-16*t+6649e-15)*t+1.1e-10,n=((7988e-15*t-1.6002e-10)*t+9.1041e-9)*t-3.9064e-7,r=(((-2.0122e-10*t+1.0507e-8)*t-6.4885e-8)*t-1258e-8)*t+94742e-9,i=(((-3.21e-8*t+2006e-9)*t+7164e-8)*t-.01262)*t+1.389,a=((o*S+n)*S+r)*S+i,m=(-23643e-16*t+3.8504e-10)*t-9.7729e-9,U=(((10405e-16*t-2.5335e-10)*t+2.5974e-8)*t-17107e-10)*t+3126e-8,h=(((-6.1185e-10*t+1.3621e-7)*t-81788e-10)*t+68982e-8)*t+.153563,p=((((3.1464e-9*t-1478e-9)*t+3342e-7)*t-.0580852)*t+5.03711)*t+1402.388,u=((m*S+U)*S+h)*S+p,T=u+(a+c*f+g*e)*e,T}static PrettyDepth(e,t=1,s,a){return l.PrettyPrint(e,l.M,t,s,a)}static PrettyTemp(e,t,s,a){return l.PrettyPrint(e,l.DC,t,s,a)}static PrettySal(e,t,s,a){return l.PrettyPrint(e,l.PSU,t,s,a)}static PrettyPrint(e,t,s=4,a=!0,i=!0){const r=l.Round(e,s);let n="";return n=a?r.toFixed(s):String(r),i&&(n+=" "),t&&(n+=t),n}static PrettySensor(e,t=3){return 0===t?e.type+" "+e.serial:e.type.slice(0,t)+" "+e.serial}static Round(e,t){const s="e+"+t,a="e-"+t;return+(Math.round(e+s)+a)}}return{CTDFileList:t,CTDGroup:s,CTDChild:a,CTDHex:o,CTDXMLCON:c,SeaConvert:l,SeaParser:class{constructor(){this.group=void 0,this.hex=void 0,this.xmlcon=void 0,this.sensors=void 0}setGroup(e){this.group=e,this.setHex(e.getHex()),this.setXmlcon(e.getXmlcon())}setHex(e){this.hex=e}setXmlcon(e){this.xmlcon=e,this.sensors=e.getParsedMap()}parseDownUp(e){if(!this.hex||!this.xmlcon)return console.error("SeaParser.parseBrief no hex or no xmlcon"),!1;const t=this.hex.getLength();e||(e=parseInt(t/10));let s=e,a=0,i=t,r=0,n=null,o=0;for(;e===s;){r=parseInt((i-a)/e),r=r<1?1:r,n=this._loopInF2(a,i,r);let t=Math.floor(n-e/2),s=Math.ceil(n+e/2);if(a=t<a?a:t,i=s>i?i:s,e>i-a&&(e=i-a),o++,o>100){console.error("Invalid condition, program in infinite loop");break}}return{d:[0,n],u:[n+1,t-1]}}_loopInF2(e,t,s){let a=-999,r=-1;for(let i=e;i<=t;i+=s){const e=this.hex.parseDepthOnly(i);a<e.f2&&(a=e.f2,r=i)}return i}parseDepthTest(){const e=this.hex.getLength();let t,s,a=-1,i=-1;const r=(new Date).getTime();for(let s=0;s<e;s++){const e=this.hex.parseRaw(s);a<e.f2&&(a=e.f2,t=e)}const n=(new Date).getTime()-r,o=(new Date).getTime();for(let t=0;t<e;t++){const e=this.hex.parseDepthOnly(t);i<e.f2&&(i=e.f2,s=e)}const c=(new Date).getTime()-o;console.log(`count: ${e}, rawMS: ${n}, depthMS: ${c}`),console.log(`maxRaw ${a}, maxDepth ${i}`),console.log(t,s)}parseTest(){this.parseDownUp(),this.parseDepthTest()}}}})(),r=(()=>{const t=-32768;class s extends DataView{static TYPES=[0];static IsMyType(e){return-1<s.TYPES.findIndex((t=>t===e))}static STRUCT_HEADER=new Map([["hID","U2"],["noBytesEns","U2"],["spare01","U1"],["noDataTypes","U1"]]);static STRUCT_DATA_TYPES=new Map([["addr","U2"]]);static ReadHeader=e.CreateReader(s.STRUCT_HEADER);static ReadDataTypes=e.CreateReader(s.STRUCT_DATA_TYPES);static ParseSection(e,t=0,a=!0){const i={};s.ReadHeader._toObject(e,t,["hID","noBytesEns","noDataTypes"],i,a);const r=t+s.ReadHeader._size,n=[];for(let t=0;t<i.noDataTypes;t++){const s=r+2*t,i=e.getUint16(s,a);n.push(i)}return i.offsets=n,i}static ParseSectionDescribe(t,a,i){const r=new Map;s.ReadHeader._toDescribeMap(t,a,r,i);const n=r.get("noDataTypes").v;let o=s.ReadHeader._size;new Map;for(let s=0;s<n;s++){const n=a+(o+2*s),c=t.getUint16(n,i),l=e.Describe(c,"U2",2);r.set(`addr_${s}`,l)}return r}}class a{static TYPES=[0];static IsMyType(e){return-1<a.TYPES.findIndex((t=>t===e))}static FIXED_LEADER=new Map([["hID","U2"],["fwVer","U1"],["fwRev","U1"],["sysCfg","U2"],["flagSim","U1"],["lagLen","U1"],["noBeams","U1"],["noCells","U1"],["pingsPEns","U2"],["dptCellLen","U2"],["blankTrans","U2"],["profMode","U1"],["lowCorrThresh","U1"],["noCodeReps","U1"],["PGMin","U1"],["EVMax","U2"],["TPPm","U1"],["TPPs","U1"],["TPPHund","U1"],["coordTransf","U1"],["hdtAli","U2"],["hdtBias","U2"],["sensorSrc","U1"],["sensorsAvail","U1"],["bin1Dist","U2"],["xmitPulseLen","U2"],["WPRefAvg","U2"],["falseTgtThresh","U1"],["spare02","U1"],["transLagDist","U2"],["cpuSerial","U8"],["sysBandwidth","U2"],["sysPwr","U1"],["spare03","U1"],["insSerial","U4"],["beamAngle","U1"]]);static SYSTEM=[[0,"75kHz"],[1,"150kHz"],[2,"300kHz"],[3,"600kHz"],[4,"1200kHz"],[5,"2400kHz"],[6,"38kHz"]];static COORD=[[0,"No transformation"],[8,"Instrument coordinates"],[16,"Ship coordinates"],[24,"Earth coordinate"]];static SENSOR_SRC=[[64,"Calculates EC (Speed of sound) from ED, ES, ET"],[32,"Uses ED from depth sensor"],[16,"Uses EH from transducer heading sensor"],[8,"Uses EP from transducer pitch sensor"],[4,"Uses ER from transducer roll sensor"],[2,"Uses ES (Salinity) from transducer conductivity sensor"],[1,"Uses ET from transducer temperature sensor"]];static ParseCoordTransform(e){const t=24&e,s=4&e,i=2&e,r=1&e,n=a.COORD.find((e=>e[0]===t)),o=n?n[1]:m.UNHANDLED_STR+` value : ${t}`,c=0<s,l=0<i,d=0<r;return{type:t,typeStr:o,tilt:c,tiltStr:c?"Tilt pitch roll used":"Tilt pitch roll not used",beam3:l,beam3Str:l?"3-Beam solution used":"3-Beam solution not used",binMapping:d,binMappingStr:d?"Bin mapping used":"Bin mapping not used"}}static ParseSysConfig(e){const t=255&e,s=(65280&e)>>8,i=7&t,r=8&t,n=48&t,o=64&t,c=128&t,l=a.SYSTEM.find((e=>e[0]===i)),d=l?l[1]:m.UNHANDLED_STR+` value : ${i.toString(2)}`,u=0<r?"CONVEX BEAM PAT":"CONCAVE BEAM PAT";let p=m.UNHANDLED_STR;0===n?p="Sensor Config 1":16===n?p="Sensor Config 2":32===n&&(p="Sensor Config 3");const h=0<o?"XDCR HD Attached":"XDCR HD Not Attached",U=0<c?"Up Facing beam":"Down Facing beam",S=3&s,f=240&s;let g=m.UNHANDLED_STR+` value : ${S.toString(2)}`,T=m.UNHANDLED_STR+` value : ${f.toString(2)}`;0===S?g="15E Beam Angle":1===S?g="20E Beam Angle":2===S?g="30E Beam Angle":3===S&&(g="Other Beam Angle"),64===f?T="4-Beam JANUS Config":80===f?T="5-Beam JANUS Config DEMOD":240===f&&(T="5-Beam JANUS Config 2 DEMOD");return{systemStr:d,conBeamStr:u,sensorCfgStr:p,xdcrStr:h,beamFaceStr:U,beamAngleStr:g,janusStr:T}}static ParseSensorSrc(e){const t=[];return a.SENSOR_SRC.forEach((s=>{0<(s[0]&e)&&t.push(s[1])})),t}static ReadFixedLeader=e.CreateReader(a.FIXED_LEADER);static ParseSysCfg(e,t,s){const i=a.ReadFixedLeader.sysCfg(e,t,s);return a.ParseSysConfig(i)}static ParseCoord(e,t,s){const i=a.ReadFixedLeader.coordTransf(e,t,s);return a.ParseCoordTransform(i)}static ParseSectionDescribe(e,t,s){const i=new Map;return a.ReadFixedLeader._toDescribeMap(e,t,i,s),i}}class i{static TYPES=[128];static IsMyType(e){return-1<i.TYPES.findIndex((t=>t===e))}static VARIABLE_LEADER=new Map([["hID","U2"],["noEns","U2"],["tsYear","U1"],["tsMonth","U1"],["tsDay","U1"],["tsHour","U1"],["tsMin","U1"],["tsSec","U1"],["tsHundredths","U1"],["ensMSB","U1"],["bitResult","U2"],["soundSpeed","U2"],["dptTrans","U2"],["hdt","U2"],["pitch","I2"],["roll","I2"],["salinity","U2"],["temp","I2"],["mptMin","U1"],["mptSec","U1"],["mptHundredths","U1"],["stdHdt","U1"],["stdPitch","U1"],["stdRoll","U1"],["adc0","U1"],["adc1","U1"],["adc2","U1"],["adc3","U1"],["adc4","U1"],["adc5","U1"],["adc6","U1"],["adc7","U1"],["errStatus","U4"],["spare01","U2"],["pressure","U4"],["pressureVar","U4"],["spare02","U1"],["rtcCentury","U1"],["rtcYear","U1"]]);static BIT_RESULT_HI=[[16,"DEMOD 1 Error"],[8,"DEMOD 0 Error"],[2,"Timing card Error"]];static ERROR_STATUS1=[[1,"Bus error exception"],[2,"Address error exception"],[4,"Illegal Instruction exception"],[8,"Zero Divide exception"],[16,"Emulator exception"],[32,"Unassigned exception"],[64,"Watchdog restart occured"],[128,"Batter saver power"]];static ERROR_STATUS2=[[1,"Pinging"],[64,"Cold wakeup occurred"],[128,"Unknown wakeup occurred"]];static ERROR_STATUS3=[[1,"Clock read error occurred"],[2,"Unexpected alarm"],[4,"Clock jump forward"],[8,"Clock jump backward"]];static ERROR_STATUS4=[[8,"Power fail - unrecorded"],[16,"spurious level 4 intr - DSP"],[32,"spurious level 5 intr - UART"],[64,"spurious level 6 intr - CLOCK"],[128,"Level 7 interrupt occurred"]];static ParseBitResult(e){const t=e>>8,s=[];return i.BIT_RESULT_HI.forEach((e=>{0<(e[0]&t)&&s.push(e[1])})),s}static ParseErrorStatus(e){const t=255&e,s=(65280&e)>>8,a=(16711680&e)>>16,r=(4278190080&e)>>24,n=[];return i.ERROR_STATUS1.forEach((e=>{0<(e[0]&t)&&n.push(e[1])})),i.ERROR_STATUS2.forEach((e=>{0<(e[0]&s)&&n.push(e[1])})),i.ERROR_STATUS3.forEach((e=>{0<(e[0]&a)&&n.push(e[1])})),i.ERROR_STATUS4.forEach((e=>{0<(e[0]&r)&&n.push(e[1])})),n}static ParseDate(e,t,s,a,i,r,n){e+=e>80?1900:2e3,t-=1;const o=10*n;return new Date(Date.UTC(e,t,s,a,i,r,o))}static ReadVariableLeader=e.CreateReader(i.VARIABLE_LEADER);static ParseSectionDescribe(e,t,s){const a=new Map;return i.ReadVariableLeader._toDescribeMap(e,t,a,s),a}static ParseTimeStamp(e,t,s){const a={};i.ReadVariableLeader._toObject(e,t,["tsYear","tsMonth","tsDay","tsHour","tsMin","tsSec","tsHundredths"],a,s);return i.ParseDate(a.tsYear,a.tsMonth,a.tsDay,a.tsHour,a.tsMin,a.tsSec,a.tsHundredths)}}class r{static TYPES=[256];static IsMyType(e){return-1<r.TYPES.findIndex((t=>t===e))}static SIZE_VELOCITY=8;static DEPTH_CELL=new Map([["v1","I2"],["v2","I2"],["v3","I2"],["v4","I2"]]);static ParseVelocity2D(e,t){return a.COORD[0][0]!==e&&(a.COORD[3][0]===e&&r.ParseVelocity2DEarth(t))}static ParseVelocity2DEarth(e){const t=r.XYMagDir(e[0],e[1]);return{magnitude:t[0],direction:t[1],e:e[0],n:e[1],sur:e[2],err:e[3]}}static XYMagDir(e,t){return[Math.sqrt(e*e+t*t),(360-Math.atan2(t,e)*(180/Math.PI)+90)%360]}static TrueWind(e,t,s,a){const i=s*s+e*e-2*s*e*Math.cos(t*Math.PI/180),r=Math.sqrt(i),n=(e*e-r*r-s*s)/(2*r*s);return[r,a+Math.acos(n)*(180/Math.PI)]}static DegreeToRange(e){if(e=Number(e),isNaN(e))return 0;for(;e<0;)e=360+e;return e%=360}static ReadDepthCell=e.CreateReader(r.DEPTH_CELL);static ParseSection(e,t=0,s=!0){return[e.getUint16(t,s),(e.byteLength-2)/r.ReadDepthCell._size]}static ParseCell(e,t=2,s=!0){return[r.ReadDepthCell.v1(e,t,s),r.ReadDepthCell.v2(e,t,s),r.ReadDepthCell.v3(e,t,s),r.ReadDepthCell.v4(e,t,s)]}static ParseCellAt(e,t,s=!0){const a=2+t*r.ReadDepthCell._size;return r.ParseCell(e,a,s)}static ParseSectionDescribe(t,s=0,a=!0){const i=new Map,n=t.getUint16(s,a);i.set("hID",e.Describe(n,"U2",2));let o=s+2;const c=(t.byteLength-2)/r.ReadDepthCell._size;for(let e=0;e<c;e++){const s=new Map;r.ReadDepthCell._toDescribeMap(t,o,s,a),o+=r.ReadDepthCell._size;for(const[t,a]of s.entries())i.set(`dc${e+1}_`+t,a)}return i}}class n{static TYPES=[512];static IsMyType(e){return-1<n.TYPES.findIndex((t=>t===e))}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static SIZE_CORR=4;static ReadDepthCell=e.CreateReader(n.DEPTH_CELL);static ParseSectionDescribe(t,s=0,a=!0){const i=new Map,r=t.getUint16(s,a);i.set("hID",e.Describe(r,"U2",2));let o=s+2;const c=(t.byteLength-2)/n.ReadDepthCell._size;for(let e=0;e<c;e++){const s=new Map;n.ReadDepthCell._toDescribeMap(t,o,s,a),o+=n.ReadDepthCell._size;for(const[t,a]of s.entries())i.set(`dc${e+1}_`+t,a)}return i}}class o{static TYPES=[768];static IsMyType(e){return-1<o.TYPES.findIndex((t=>t===e))}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static ReadDepthCell=e.CreateReader(o.DEPTH_CELL);static ParseSectionDescribe(t,s=0,a=!0){const i=new Map,r=t.getUint16(s,a);i.set("hID",e.Describe(r,"U2",2));let n=s+2;const c=(t.byteLength-2)/o.ReadDepthCell._size;for(let e=0;e<c;e++){const s=new Map;o.ReadDepthCell._toDescribeMap(t,n,s,a),n+=o.ReadDepthCell._size;for(const[t,a]of s.entries())i.set(`dc${e+1}_`+t,a)}return i}}class c{static TYPES=[1024];static IsMyType(e){return-1<c.TYPES.findIndex((t=>t===e))}static DEPTH_CELL=new Map([["f1","U1"],["f2","U1"],["f3","U1"],["f4","U1"]]);static ReadDepthCell=e.CreateReader(c.DEPTH_CELL);static ParseSectionDescribe(t,s=0,a=!0){const i=new Map,r=t.getUint16(s,a);i.set("hID",e.Describe(r,"U2",2));let n=s+2;const o=(t.byteLength-2)/c.ReadDepthCell._size;for(let e=0;e<o;e++){const s=new Map;c.ReadDepthCell._toDescribeMap(t,n,s,a),n+=c.ReadDepthCell._size;for(const[t,a]of s.entries())i.set(`dc${e+1}_`+t,a)}return i}}class l{static TYPES=[1280];static IsMyType(e){return-1<l.TYPES.findIndex((t=>t===e))}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static ReadDepthCell=e.CreateReader(l.DEPTH_CELL);static ParseSectionDescribe(t,s=0,a=!0){const i=new Map,r=t.getUint16(s,a);i.set("hID",e.Describe(r,"U2",2));const n=s+2,o=(t.byteLength-2)/l.ReadDepthCell._size;for(let e=0;e<o;e++){const s=new Map;l.ReadDepthCell._toDescribeMap(t,n,s,a),n+=l.ReadDepthCell._size;for(const[t,a]of s.entries())i.set(`dc${e+1}_`+t,a)}}}class d{static TYPES=[1536];static IsMyType(e){return-1<d.TYPES.findIndex((t=>t===e))}static BT_DATA=new Map([["hID","U2"],["pingsPEns","U2"],["delayReacq","U2"],["corrMagMin","U1"],["evalAmpMin","U1"],["pgMin","U1"],["mode","U1"],["errVelMax","U2"],["reserved","U4"],["range1","U2"],["range2","U2"],["range3","U2"],["range4","U2"],["vel1","U2"],["vel2","U2"],["vel3","U2"],["vel4","U2"],["corr1","U1"],["corr2","U1"],["corr3","U1"],["corr4","U1"],["evalAmp1","U1"],["evalAmp2","U1"],["evalAmp3","U1"],["evalAmp4","U1"],["pg1","U1"],["pg2","U1"],["pg3","U1"],["pg4","U1"],["rl1","U2"],["rl2","U2"],["rl3","U2"],["rlVel1","U2"],["rlVel2","U2"],["rlVel3","U2"],["rlVel4","U2"],["rlcm1","U1"],["rlcm2","U1"],["rlcm3","U1"],["rlcm4","U1"],["rlei1","U1"],["rlei2","U1"],["rlei3","U1"],["rlei4","U1"],["rlpg1","U1"],["rlpg2","U1"],["rlpg3","U1"],["rlpg4","U1"],["maxDepth","U2"],["rssiAmp1","U1"],["rssiAmp2","U1"],["rssiAmp3","U1"],["rssiAmp4","U1"],["gain","U1"],["rangeMSB1","U1"],["rangeMSB2","U1"],["rangeMSB3","U1"],["rangeMSB4","U1"]]);static BT_LAYER_WORD=new Map([["min","U2"],["near","U2"],["far","U2"]]);static ReadBottomTrack=e.CreateReader(d.BT_DATA);static ParseSectionDescribe(e,t=0,s=!0){const a=new Map;return d.ReadBottomTrack._toDescribeMap(e,t,a,s),a}}class u{}class p{static NAV_DATA=new Map([["hID","U2"],["utcDay","U1"],["utcMonth","U1"],["utcYear","U2"],["utcTimeFF","I4"],["pcClockOffset","I4"],["firstLat","U4"],["firstLng","U4"],["utcTimeLF","U4"],["lastLat","U4"],["lastLng","U4"],["avgSpd","I2"],["avgTrackTrue","U2"],["avgTrackMag","U2"],["SMG","U2"],["DMG","U2"],["reserved1","U2"],["flags","U2"],["reserved2","U2"],["noEns","U4"],["ensYear","U2"],["ensDay","U1"],["ensMonth","U1"],["ensTime","U4"],["pitch","I2"],["roll","I2"],["hdt","U2"],["numSpeedAvg","U2"],["numTTAvg","U2"],["numMTAvg","U2"],["numHdtAvg","U2"],["numPRAvg","U2"]]);static BAM(e,t){return 180*e/Math.pow(2,t-1)}static parseNavFlags(e){const t=[],s=[];return 0==(1&e)&&t.push("Data not updated"),0==(2&e)&&t.push("PSN Invalid"),0==(4&e)&&t.push("Speed Invalid"),0==(8&e)&&t.push("Mag Track Invalid"),0==(16&e)&&t.push("True Track Invalid"),0==(32&e)&&t.push("Date/Time Invalid"),0==(64&e)&&t.push("SMG/DMG Invalid"),0==(128&e)&&t.push("Pitch/Roll Invalid"),0==(256&e)&&t.push("Heading Invalid"),0==(512&e)&&t.push("ADCP Time Invalid"),0==(1024&e)&&t.push("Clock offset Time Invalid"),0!=(1&e)&&s.push("Data updated"),0!=(2&e)&&s.push("PSN Valid"),0!=(4&e)&&s.push("Speed Valid"),0!=(8&e)&&s.push("Mag Track Valid"),0!=(16&e)&&s.push("True Track Valid"),0!=(32&e)&&s.push("Date/Time Valid"),0!=(64&e)&&s.push("SMG/DMG Valid"),0!=(128&e)&&s.push("Pitch/Roll Valid"),0!=(256&e)&&s.push("Heading Valid"),0!=(512&e)&&s.push("ADCP Time Valid"),0!=(1024&e)&&s.push("Clock offset Time Valid"),{invalid:t,valid:s}}static ReadNavigation=e.CreateReader(p.NAV_DATA);static ParseSMGDMG(e,t=0,s=!0){return[p.ReadNavigation.SMG(e,t,s),p.ReadNavigation.DMG(e,t,s)]}static ParsePositionFirst(e,t=0,s=!0){return[p.ReadNavigation.firstLat(e,t,s),p.ReadNavigation.firstLng(e,t,s)]}static ParsePositionLast(e,t=0,s=!0){return[p.ReadNavigation.lastLat(e,t,s),p.ReadNavigation.lastLng(e,t,s)]}static ParseSectionDescribe(e,t=0,s=!0){const a=new Map;return p.ReadNavigation._toDescribeMap(e,t,a,s),a}}class h{static BINFIXED_ATTITUDE_DATA=new Map([["EF","U1"],["EH","U2"],["EI","U2"],["EJ","U2"],["EP","U4"],["EU","U1"],["EV","U2"],["EZ","U8"]])}class U{}class m{static HEADER_HID=32639;static HID={HEADER:{code:m.HEADER_HID,title:"Header",cls:s},FIXED:{code:0,title:"Fixed Leader",cls:a},VARIABLE:{code:128,title:"Variable Leader",cls:i},VELOCITY:{code:256,title:"Veolocity Data",cls:r},CORR:{code:512,title:"Correlation magnitude Data",cls:n},INTENSITY:{code:768,title:"Echo intensity Data",cls:o},PG:{code:1024,title:"Percent good Data",cls:c},STATUS:{code:1280,title:"Status Data",cls:l},BT:{code:1536,title:"Bottom Track Data",cls:d},ASP:{code:524,title:"Ambient Sound Profile",cls:u},MICROCAT:{code:2048,title:"MicroCAT Data"},NAV:{code:8192,title:"Binary Navigation Data",cls:p},BINFIXED_ATTITUDE:{code:12288,title:"Binary Fixed Attitude Data",cls:h},BINVAR_ATTITUDE:{code:12352,title:"Binary Variable Attitude data",cls:U},UNKNOWN30E8:{code:12520,title:"Unknown type 0x30E8"},UNKNOWN30D8:{code:12504,title:"Unknown type 0x03D8"}};static SplitEnsemble(e,t,a=!0){const i=e.getUint16(t,a);if(m.HEADER_HID!==i)return!1;return s.ParseSection(e,t,a)}static DescType(e){for(const[t,s]of Object.entries(m.HID))if(s.code===e)return s}static GetTitle(e){for(const[t,s]of Object.entries(m.HID))if(s.code===e)return s.title}static GetParser(e){for(const[t,s]of Object.entries(m.HID))if(s.code===e)return s.cls?.ParseSectionDescribe}}class S{constructor(e=!0){this.littleEndian=e}parse(e,t=void 0){this.dataView=e,void 0===t&&(t=m.SplitEnsemble(e,0,this.littleEndian)),this.offsets=t.ensemble.offsets,this.sections=S.DivideOffsets(this.offsets,t.len,0),this.sections.forEach((s=>{const a=e.getUint16(s.offset,this.littleEndian);s.hID=a,s.dataView=new DataView(e.buffer,t.offset+s.offset,s.len)}));const s=new Map;for(const[e,t]of Object.entries(m.HID)){const a=this.sections.find((e=>e.hID===t.code));a&&s.set(e,a)}this.sectionMap=s,this.parseEssential()}parseEssential(){const e=this.fixed?.dataView,t=this.nav?.dataView;if(!e||!t)return;const s=a.ParseSysCfg(e,0,this.littleEndian);this.sysCfg=s;const i=a.ParseCoord(e,0,this.littleEndian);this.coord=i;const r=p.ParseSMGDMG(t,0,this.littleEndian);this.smg=r[0],this.dmg=p.BAM(r[1],16)}get header(){return this.sectionMap?.get("HEADER")}get fixed(){return this.sectionMap?.get("FIXED")}get variable(){return this.sectionMap?.get("VARIABLE")}get velocity(){return this.sectionMap?.get("VELOCITY")}get corr(){return this.sectionMap?.get("CORR")}get intensity(){return this.sectionMap?.get("INTENSITY")}get pg(){return this.sectionMap?.get("PG")}get status(){return this.sectionMap?.get("STATUS")}get nav(){return this.sectionMap?.get("NAV")}parseVelocity2D(e=-1,s=1){if(a.COORD[3][0]!==this.coord.type)return console.error("EnsembleContext.parseVelocity2D only supports Earth coordination type"),void console.log(this.coord);const i=this.velocity?.dataView;if(!i)return void console.error("EnsembleContext.parseVelocity2D has no velocity section");const n=r.ParseSection(i,0,this.littleEndian)[1];if(isNaN(n)||0>n||500<n||n!==parseInt(n))return void console.error(`EnsembleContext.parseVelocity2D invalid cellCount ${n}`);let o=e;(o<0||o>n||isNaN(o))&&(o=n);const c=[],l=[];for(let e=0;e<o;e+=s){const s=r.ParseCellAt(i,e,this.littleEndian),a=r.ParseVelocity2DEarth(s);t!==a.n&&t!==a.e||(a.magnitude=t,a.direction=t),c.push(s),l.push(a)}return this.velocityCells=c,this.velocityMD=l,!0}parseMDNav(){const e=this.smg,s=this.dmg,a=[];this.velocityMD.forEach((i=>{if(t===i.magnitude||t===i.direction)return void a.push([t,t]);if(0===e)return void a.push(i);const n=r.DegreeToRange(i.direction+180-s),o=r.TrueWind(i.magnitude,n,e,s);o[1]=(o[1]+180)%360,a.push(o)})),this.velocityMDNav=a}parsePosition(){const e=this.nav?.dataView;if(!e)return console.error("EnsembleContext.parsePosition has no navigation section"),!1;let t=p.ParsePositionFirst(e,0,this.littleEndian),s=p.ParsePositionLast(e,0,this.littleEndian);return t=[p.BAM(t[0],32),p.BAM(t[1],32)],s=[p.BAM(s[0],32),p.BAM(s[1],32)],this.posFirst=t,this.posLast=s,!0}parseTimeStamp(){const e=this.variable?.dataView;if(!e)return console.error("EnsembleContext.parseTimeStamp has no variable section"),!1;const t=i.ParseTimeStamp(e,0,this.littleEndian);this.ts=t}parseMeta(){return this.posFirst||this.parsePosition(),this.ts||this.parseTimeStamp(),this.meta={eq:"ADCP_"+this.sysCfg.systemStr,eqid:"ADCP_"+this.sysCfg.systemStr+"_0000",ts:this.ts,ms:this.ts.getTime(),lat:this.posFirst[0],lng:this.posFirst[1],lat2:this.posLast[0],lng2:this.posLast[1]},this.meta}getMeta(){return this.meta}static GetMetaDesc(){return{ts:"Variable tsYear, tsMonth, tsDay, tsHour, tsMin, tsSec, tsHundredths - parseTimestamp",ts2:"no ts2 since ensemble has one varialbe",ms:"ts.getTime()",eq:"ADCP_ + sysCfg.systemStr - ADCP_38kHz",eqid:"no serial in file, eq +_0000, just use any name",lat:"Navigation positionFirst[0] from parsePosition",lng:"Navigation positionFirst[1] from parsePosition",lat2:"Navigation positionLast[0] from parsePosition",lng2:"Navigation positionLast[1] from parsePosition"}}static DivideOffsets(e,t,s=0,a=!0){const i=[];if(!t)return void console.error("EnsembleContext.OffsetDivide should have totalBytes");const r=e.map((e=>e));!0===a&&0!==r[0]&&r.unshift(0),r.push(t);for(let e=0;e<r.length-1;e++){const t=r[e],a=r[e+1]-t;i.push({offset:s+t,len:a})}return i}}class f{constructor(){this.dataView=void 0,this.ensembles=void 0,this.littleEndian=!0}load(e,t,s){this.dataView=e,this.ensembles=t,this.littleEndian=s}}class g{static ParseEnsembles(e,t=!0){const s=new DataView(e),a=[];let i=0;for(;i<s.byteLength;){const e=m.SplitEnsemble(s,i,t);if(!e)break;const r={offset:i,len:e.noBytesEns+2,title:"Ensemble",ensemble:e};a.push(r),i=i+e.noBytesEns+2}const r=new f;return r.load(s,a,t),r}static ParseEnsemblesContext(e){e.ensembles.forEach((t=>{g.ParseEnsembleContext(e,t)}))}static ParseEnsembleContext(e,t){const s=new S,a=new DataView(e.dataView.buffer,t.offset,t.len);s.parse(a,t),t.context=s}static ParseMeta(e,t=!0){const s=g.ParseEnsembles(e,t),a=[s.ensembles.at(0),s.ensembles.at(-1)].map((e=>(g.ParseEnsembleContext(s,e),e.context.parseMeta(),e.context.getMeta())));return{eq:a[0].eq,eqid:a[0].eqid,lat:a[0].lat,lng:a[0].lng,lat2:a[1].lat2,lng2:a[1].lng2,ts:a[0].ts,ms:a[0].ms,ts2:a[1].ts,ms2:a[1].ms,count:s.ensembles.length,bytes:e.byteLength}}static GetMetaDesc(){return{ts:"Variable tsYear, tsMonth, tsDay, tsHour, tsMin, tsSec, tsHundredths - parseTimestamp",ts2:"no ts2 since ensemble has one varialbe",ms:"ts.getTime()",eq:"ADCP_ + sysCfg.systemStr - ADCP_38kHz",eqid:"no serial in file, eq +_0000, just use any name",lat:"Navigation positionFirst[0] from parsePosition",lng:"Navigation positionFirst[1] from parsePosition",lat2:"Navigation positionLast[0] from parsePosition",lng2:"Navigation positionLast[1] from parsePosition",count:"number of ensembles",desc:"parse meta from arrayBuffer, first and last ensemble only, ensemble context parsed with ParserEntryPD0",bytes:"arrayBuffer.byteLength"}}}return{PD0:m,PD0Header:s,PD0Fixed:a,PD0Variable:i,PD0Navigation:p,PD0Velocity:r,ParserContext:f,Ensemble:S,ParserTest:g,GetTitle:m.GetTitle,GetParser:m.GetParser,DescType:m.DescType,ParseEnsembles:g.ParseEnsembles,ParseMeta:g.ParseMeta,GetMetaDesc:g.GetMetaDesc,INVALID_VALUE:t}})();return{ParserA:e,ParserEM:t,ParserSEGY:s,ParserCTD:a,ParserPD0:r}})();