const MarineParser=(()=>{let e=(()=>{let e={U1:["getUint8",1],U2:["getUint16",2],U4:["getUint32",4],U8:["getBigUint64",8],I1:["getInt8",1],I2:["getInt16",2],I4:["getInt32",4],I8:["getBigInt64",8],F4:["getFloat32",4],F8:["getFloat64",8]};function t(t){if(e[t])return e[t][1];if("A"===t[0]){let $=t.match(/^A(\d+)$/);if(!$)return -1;let a=parseInt($[1]);return isNaN(a)?-1:a}return -1}function $($){let a={},r=0;return $.forEach(($,s)=>{let n=e[$],o=r;if(n){let l=n[0];a[s]=(e,t,$)=>e[l](t+o,!1!==$),r+=n[1]}else if("A"===$[0]){let c=t($);if(-1===c){console.error("Invalid Ascii type, that should have number after A like A16");return}a[s]=(e,t)=>{let $=e.byteOffset+t+o,a=e.buffer.slice($,$+c);return String.fromCharCode.apply(null,new Uint8Array(a))},r+=c}}),a._size=r,a._toObject=(e,t,$,s,r)=>{$.forEach($=>{s[$]=a[$](e,t,r)})},a._toDescribeMap=(e,r,n,o)=>{$.forEach(($,l)=>{let c=a[l](e,r,o),_=t($),d=s(c,$,_);n.set(l,d)})},a}function a(e,t,$){let a=e.buffer.slice(e.byteOffset+t,e.byteOffset+$);return String.fromCharCode.apply(null,new Uint8Array(a))}function s(e,t,$){return{v:e,type:t,size:$}}function r(e){let t={};for(let[$,a]of e.entries())t[$]=a.v;return t}function n(e){for(let[t,$]of e.entries())e.set(t,$.v);return e}function o(e,t){let $=[];return e.forEach(e=>{0<(e[0]&t)&&$.push(e)}),$}function l(e,t){let $=[];return e.forEach(e=>{let a=t&e[0];a===e[1]&&$.push(e)}),$}function c(e){return e.map(e=>e.at(-1)).join(", ")}function _(e){for(let[t,$]of Object.entries(d))e[t]=$}let d={TypeMap:e,GetTypeSize:t,CreateReader:$,ParseAscii:a,Describe:s,Undescribe:r,UndescribeMap:n,ParseBit:o,ParseBitEqual:l,ParsedBitJoin:c,Project:_};return d})(),t=(()=>{class $ extends DataView{#a=!0;static STX=2;static ETX=3;static BYTE_LENGTH=4;static DATAGRAM_TYPES={73:{title:"Install Start",cls:null},105:{title:"Install Stop",cls:null},112:{title:"Install Remote",cls:null},82:{title:"Runtime",cls:null},88:{title:"XYZ88",cls:null},75:{title:"Central Beams",cls:null},70:{title:"Raw range and Beam angle",cls:null},102:{title:"Raw range and Beam angle F",cls:null},78:{title:"Raw range and angle 78",cls:null},83:{title:"Seabed image",cls:null},89:{title:"Seabed image 89",cls:null},107:{title:"Water column",cls:null},79:{title:"Quality factor 79",cls:null},65:{title:"Attitude",cls:null},110:{title:"Network attitude velocity",cls:null},67:{title:"Clock",cls:null},104:{title:"Depth or height",cls:null},72:{title:"Heading",cls:null},80:{title:"Position",cls:null},69:{title:"Single beam echo sounder depth",cls:null},84:{title:"Tide",cls:null},71:{title:"Surface sound speed",cls:null},85:{title:"Sound speed profile",cls:null},87:{title:"Kongberg Maritime SSP output",cls:null},74:{title:"Mechanical transducer tilt",cls:null},51:{title:"Extra parameters 3",cls:null},48:{title:"PU ID output",cls:null},49:{title:"PU Status output",cls:null},66:{title:"PU BIST result output",cls:null},68:{title:"Depth datagram",cls:null}};static DescType(e){return $.DATAGRAM_TYPES[e]?.title??void 0}set littleEndian(e){this.#a=e}parseBrief(){let e=[],t=0;for(;t<this.byteLength;){let a=this.parseSection(t);e.push(a),t=t+a.len+$.BYTE_LENGTH}return e}parseSection(e){let t=this.getUint32(e,this.#a),a=this.getUint8(e+4,this.#a),s=this.getUint8(e+5,this.#a),r={type:s,offset:e,len:t,valid:!1};return $.STX===a&&(r.valid=!0),r}}class a{static TYPES=[88,136];static IsMyType(e){return -1<a.TYPES.findIndex(t=>t===e)}static STRUCT_XYZ_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["heading","U2"],["ss","U2"],["txTRDepth","F4"],["numBeams","U2"],["numValid","U2"],["freq","F4"],["info","U1"],["spare01","U1"],["spare02","U1"],["spare03","U1"]]);static STRUCT_XYZ_BODY=new Map([["z","F4"],["y","F4"],["x","F4"],["windowLen","U2"],["QFac","U1"],["angAdj","I1"],["dInfo","U1"],["cInfo","I1"],["reflectivity","I2"]]);static STRUCT_XYZ_TAIL=new Map([["spare04","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(a.STRUCT_XYZ_HEAD);static ReadBody=e.CreateReader(a.STRUCT_XYZ_BODY);static ReadTail=e.CreateReader(a.STRUCT_XYZ_TAIL);static ParseSection(e,t,s){let r={},n=a,o=n.ReadHead.numBeams(e,t,s),l=n.ReadHead.date(e,t,s),c=n.ReadHead.time(e,t,s),_=T(l,c);r.dt=_,r.numBeams=o;let d=n.ReadHead._size+t,u=[];for(let p=0;p<o;p++){let h=d+p*n.ReadBody._size,U=n.ReadBody.x(e,h,s),x=n.ReadBody.y(e,h,s),m=n.ReadBody.z(e,h,s);u.push([U,x,m])}r.body=u;let b=o*n.ReadBody._size,f=n.ReadTail.etx(e,d+b,s);return r.etxValid=$.ETX===f,r}static ParseSectionMinimum(e,t,$){let s=[a.ReadHead.date(e,t,$),a.ReadHead.time(e,t,$),a.ReadHead.numBeams(e,t,$),a.ReadHead.txTRDepth(e,t,$),],r=a.ReadHead._size+t,n=[];for(let o=0;o<s[2];o++){let l=r+o*a.ReadBody._size,c=a.ReadBody.x(e,l,$),_=a.ReadBody.y(e,l,$),d=a.ReadBody.z(e,l,$);n.push([c,_,d])}return s.push(n),s}static ParseSectionDescribe(e,t,$){let s=new Map;a.ReadHead._toDescribeMap(e,t,s,$);let r=a.ReadHead._size,n=s.get("numBeams").v;for(let o=0;o<n;o++){let l=r+a.ReadBody._size*o,c=new Map;for(let[_,d]of(a.ReadBody._toDescribeMap(e,l,c,$),c.entries()))s.set(`e${o+1}_`+_,d)}return r+=a.ReadBody._size*n,a.ReadTail._toDescribeMap(e,r,s,$),s}}class s{static TYPES=[73,105,112];static IsMyType(e){return -1<s.TYPES.findIndex(t=>t===e)}static STRUCT_INSTALL=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["lineNo","U2"],["serial","U2"],["serial2ndSonar","U2"]]);static ReadInstall=e.CreateReader(s.STRUCT_INSTALL);static ParseSection(t,a,r){let n={};s.ReadInstall._toObject(t,a,["length","type","model","serial"],n,r);let o=s.ReadInstall._size,l=a+o,c=l+n.length-o,_=e.ParseAscii(t,l,c);n.ascii=_,n.etxValid=!1;let d=t.getUint8(c,r);if(0===d){let u=t.getUint8(c+1,r);$.ETX===u&&(n.etxValid=!0)}else $.ETX===d&&(n.etxValid=!0);return n}static ParseSectionDescribe(t,$,a){let r=new Map;s.ReadInstall._toDescribeMap(t,$,r,a);let n=s.ReadInstall._size,o=$+n,l=o+r.get("length").v-n,c=e.ParseAscii(t,o,l),_=e.Describe(c,"ASCII",l-o);return r.set("ascii",_),b(t,l,r,a),r}}class r{static TYPES=[82];static IsMyType(e){return -1<r.TYPES.findIndex(t=>t===e)}static STRUCT_RUNTIME=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["operatorStationStatus","U1"],["PUStatus","U1"],["BSPStatus","U1"],["SHTStatus","U1"],["mode","U1"],["filterID","U1"],["minDepth","U2"],["maxDepth","U2"],["absorpCoeff","U2"],["txPulseLen","U2"],["txBeamWidth","U2"],["txPower","I1"],["rxBeamWidth","U1"],["rxBandwidth","U1"],["rxGain","U1"],["TVGLawAng","U1"],["srcSS","U1"],["maxPortSwath","U2"],["beamSpacing","U1"],["maxPortCoverage","U1"],["yawPitchStable","U1"],["maxSTBDCoverage","U1"],["maxSTBDSwath","U2"],["txTiltValue","I2"],["filterID2","U1"],["etx","U1"],["checksum","U2"]]);static ReadRuntime=e.CreateReader(r.STRUCT_RUNTIME);static ParseSectionDescribe(e,t,$){let a=new Map;return r.ReadRuntime._toDescribeMap(e,t,a,$),a}static BitPUStatus=[[1,"Communication error With BSP (or CBMF) : All models except ME70BO"],[2,"Communication error with Sonar Head or Transceiver : All models except EM 2040 and ME70BO, Communication error with slave PU : EM 2040/EM 2040C, Problem with communication with ME70 : ME70BO"],[4,"Attitude not valid for this ping : All models"],[8,"Heading not valid for this ping : All models"],[16,"System clock has not been set since power up : All models"],[32,"External trigger signal not detected : All models except ME70BO"],[64,"CPU temperature warning : All models except EM 1002, Hull Unit not responding : EM 1002"],[128,"Attitude velocity data not valid for this ping : EM 122 EM 302 EM 710 EM 2040 EM 2040C"],];static BitBSPStatusA=[[1,"Error on R0 data received by BSP 1 (May be a bad high speed link) : EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[2,"Too much seabed image data on BSP1 : EM 3000, EM 3000D"],[4,"Invalid command received by BSP1 : EM 3000, EM 3000D"],[8,"Errors on BSP1 : EM 3002, EM 3002D"],[16,"Error on R0 data received by BSP 2 (May be a bad high speed link) : EM 3000D, EM 3002D"],[32,"Too much seabed image data on BSP2 : EM 3000D"],[64,"Invalid command received by BSP2 : EM 3000D"],[128,"Errors on BSP2 : EM 3002, EM 3002D"],];static BitBSPStatusB=[[1,"Sample number error in RX data received from SPRX"]];static BitBSPStatusC=[[1,"Sample number error in R0 data received from SPRX"],[2,"Missing R0 header data from SPRX"],[4,"Missing sample data from SPTX"],[8,"Missing second R0 header data from SPTX"],[16,"Bad sync TRU - PU - BSP"],[32,"Bad parameters received from PU"],[64,"Internal sync problem in BSP"],[128,"Checksum error in header from SPTX"],];static BitBSPStatusD=[[1,"Error on RX data received by BSP 1"],[2,"Error on RX data received by BSP 3"],[4,"Errors on BSP 3"],[8,"Errors on BSP 1"],[16,"Error on RX data received by BSP 2"],[32,"Error on RX data received by BSP 4"],[64,"Errors on BSP 4"],[128,"Errors on BSP2"],];static BitBSPStatusE=[[1,"Error on data from BSP 1 - master PU"],[2,"Error on data from BSP 2 - master PU"],[4,"Error on data from BSP 3 - master PU"],[8,"Error on data from BSP 4 - master PU"],[16,"Error on data from BSP 1 - slave PU"],[32,"Error on data from BSP 2 - slave PU"],[64,"Error on data from BSP 3 - slave PU"],[128,"Error on data from BSP 4 - slave PU"],];static BitCRMFStatus=[[1,"Error on data from CBMF 1 - master PU"],[2,"Error on data from CBMF 2 - master PU"],[4,"Error on data from CBMF 3 - slave PU"],[8,"Error on data from CBMF 4 - slave PU"],];static ModelBSPStatus=new Map([[2e3,[r.BitBSPStatusA]],[3e3,[r.BitBSPStatusA]],[3002,[r.BitBSPStatusA]],[1002,[r.BitBSPStatusB]],[102,[r.BitBSPStatusC]],[300,[r.BitBSPStatusC]],[122,[r.BitBSPStatusD]],[302,[r.BitBSPStatusD]],[710,[r.BitBSPStatusD]],[2040,[r.BitBSPStatusE]],]);static BitTransceiverStatusA=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Timeout error (SPRX waits for SPTX)"],[8,"Receive channel DC offset(s) out of range"],[16,"Illegal parameter received from PU"],[32,"Internal communication error (SPTX - SPRX sync)"],[64,"Timeout error (SPTX waits for SPRX)"],[128,"Defective fuse(s) in transmitter"],];static BitTransceiverStatusB=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Error on Transmitter"],[8,"Error on Receiver"],[16,"Not implemented"],[32,"Not implemented"],[64,"Not implemented"],[128,"Not implemented"],];static BitTransceiverStatusC=[[1,"Transmit voltage (HV) out of range"],[2,"Low voltage power out of range"],[4,"Transmit voltage (HV) to high"],[8,"Error in command from PU (Illegal parameter)"],[16,"Error in command from PU (Bad checksum)"],[32,"Error in command from PU (Bad datagram length)"],];static BitTransceiverStatusD=[[1,"Transmit power (HV) out of range"],[2,"Communication error with TX"],[4,"Communication error with RX 1 (port)"],[8,"Communication error with RX 2 (starboard)"],[16,"Communication error with IO2040 - master PU"],[32,"Communication error with IO2040 - slave PU"],[64,"Spare"],[128,"Spare"],];static BitSonarHeadStatusA=[[1,"Temperature to high on Sonar Head 1 EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[2,"Data link failure on Sonar Head 1 EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[4,"DC Supply Voltages in Sonar Head 1 is out of range EM 2000, EM 3000, EM 3000D, EM 3002, EM 3002D"],[8,"Spare"],[16,"Temperature to high on Sonar Head 2 EM 3000D, EM 3002D"],[32,"Data link failure on Sonar Head 2 EM 3000D, EM 3002D"],[64,"DC Supply Voltages in Sonar Head 2 is out of range EM 3000D, EM 3002D"],[128,"Spare"],];static BitSonarHeadStatusB=[[1,"Transmit power (HV) out of range SH1"],[2,"Communication error with TX SH1"],[4,"Communication error with RX SH1"],[8,"Temperature to high SH1"],[16,"Transmit power (HV) out of range SH2"],[32,"Communication error with TX SH2"],[64,"Communication error with RX SH2"],[128,"Temperature to high SH2"],];static ModelSHTStatus=new Map([[102,[r.BitTransceiverStatusA]],[300,[r.BitTransceiverStatusA]],[122,[r.BitTransceiverStatusB]],[302,[r.BitTransceiverStatusB]],[710,[r.BitTransceiverStatusB]],[1002,[r.BitTransceiverStatusC]],[2e3,[r.BitSonarHeadStatusA]],[3e3,[r.BitSonarHeadStatusA]],[3002,[r.BitSonarHeadStatusA]],[2040,[r.BitTransceiverStatusD,r.BitSonarHeadStatusB]],]);static BitEqualPingModeA=[[15,0,"Nearfield (4\xba)"],[15,1,"Normal (1.5\xba)"],[15,2,"Target detect"],];static BitEqualPingModeB=[[15,0,"Wide Tx beamwidth (4\xb0)"],[15,1,"Normal Tx beamwidth (1.5\xb0)"],];static BitEqualPingModeC=[[15,0,"Very Shallow"],[15,1,"Shallow"],[15,2,"Medium"],[15,3,"Deep"],[15,4,"Very deep"],[15,5,"Extra deep"],];static BitEqualPingModeD=[[15,0,"200 kHz"],[15,1,"300 kHz"],[15,2,"400 kHz"],];static BitEqualTXPulseFormA=[[48,0,"CW"],[48,16,"Mixed"],[48,32,"FM"],];static BitEqualFrequency=[[31,0,"180 kHz"],[31,1,"190 kHz"],[31,22,"400 kHz"],];static BitEqualTXPulseFormB=[[32,0,"CW"],[32,32,"FM"],];static BitEqualDualSwathMode=[[192,0,"Dual swath = Off"],[192,64,"Dual swath = Fixed"],[192,128,"Dual swath = Dynamic"],];static ModelMode=new Map([[3e3,[r.BitEqualPingModeA]],[3002,[r.BitEqualPingModeB]],[2e3,[r.BitEqualPingModeC]],[710,[r.BitEqualPingModeC,r.BitEqualTXPulseFormA,r.BitEqualDualSwathMode]],[1002,[r.BitEqualPingModeC]],[300,[r.BitEqualPingModeC]],[302,[r.BitEqualPingModeC,r.BitEqualTXPulseFormA,r.BitEqualDualSwathMode]],[120,[r.BitEqualPingModeC]],[122,[r.BitEqualPingModeC,r.BitEqualTXPulseFormA,r.BitEqualDualSwathMode]],[2040,[r.BitEqualPingModeD,r.BitEqualTXPulseFormA,r.BitEqualFrequency,r.BitEqualTXPulseFormB,r.BitEqualDualSwathMode]],]);static BitEqualFilterID=[[3,0,"Spike filter set to Off"],[3,1,"Spike filter is set to Weak"],[3,2,"Spike filter is set to Medium"],[3,3,"Spike filter is set to Strong"],[4,4,"Slope filter is on"],[8,8,"Sector tracking or Robust Bottom Detection (EM 3000) is on"],[144,0,"Range gates have Normal size"],[144,16,"Range gates are Large"],[144,128,"Range gates are Small"],[32,32,"Aeration filter is on"],[64,64,"Interference filter is on"],];static BitEqualFilterID2=[[3,0,"Penetration filter = Off"],[3,1,"Penetration filter = Weak"],[3,2,"Penetration filter = Medium"],[3,3,"Penetration filter = Strong"],[12,0,"Detect mode: Normal"],[12,4,"Detect mode: Waterway"],[12,8,"Detect mode: Tracking"],[12,12,"Detected mode: Minimum depth"],[48,0,"Short phase ramp"],[48,16,"Normal phase ramp"],[48,32,"Long phase ramp"],[64,0,"Normal TVG"],[64,64,"Special TVG"],[128,0,"Normal amp detect"],[128,128,"Special amp detect or soft sediments (EM 3002)"],];static BitEqualSoundSpeed=[[3,0,"From real time sensor"],[3,1,"Manually entered by operator"],[3,2,"Interpolated from currently used sound speed profile"],[3,3,"Calculated by ME70BO TRU"],[16,16,"Extra detections enabled"],[32,32,"Sonar mode enabled"],[64,64,"Passive mode enabled"],[128,128,"3D scanning enabled"],];static BitEqualBeamspacing=[[3,0,"Determined by beamwidth (FFT beamformer of EM 3000)"],[3,1,"Equidistant (Inbetween for EM 122 and EM 302)"],[3,2,"Equiangle"],[3,3,"High density equidistant (In between for EM 2000, EM 120, EM 300, EM 1002)"],];static BitEqualBeamspacing3002Only=[[128,0,"Only one sonar head is connected. If two heads are connected, both have the same beam spacing."],[128,128,"Two sonar heads are connected. Individual beam spacing is possible."],[112,0,"No head 2"],[112,16,"h2 equidistant"],[112,32,"h2 equiangle"],[112,48,"h2 high density"],[15,1,"h1 equidistant"],[15,2,"h1 equiangle"],[15,3,"h1 high density"],];static BitEqualYawPitchStable=[[3,0,"No yaw stabilization"],[3,1,"Yaw stabilization to survey line heading (Not used)"],[3,2,"Yaw stabilization to mean vessel heading"],[3,3,"Yaw stabilization to manually entered heading"],[12,0,"Heading filter, hard"],[12,4,"Heading filter, medium"],[12,8,"Heading filter, weak"],[128,128,"Pitch stabilization is on."]];static BitEqualRXFixedGain20040Only=[[3,0,"Off (RX inactive)"],[3,1,"port active"],[3,2,"starboard active"],[3,3,"Both active"],[12,0,"Short CW"],[12,4,"Medium CW"],[12,8,"Long CW"],[12,12,"FM"],[112,0,"Very Short CW"],[112,16,"Short CW"],[112,32,"Medium CW"],[112,48,"Long CW"],[112,64,"Very Long CW"],[112,80,"Extra Long CW"],[112,96,"Short FM"],[112,112,"Long FM"],];static ParseOperatorStationStatus(e){return[]}static ParsePUStatus(t){return e.ParseBit(r.BitPUStatus,t)}static ParseBSPStatus(t,$){let a=r.ModelBSPStatus.get($);return a?e.ParseBit(a,t):[[t,`No model found for ${$}`]]}static ParseSHTStatus(t,$){let a=r.ModelSHTStatus.get($);return a?[].concat(...a.map($=>e.ParseBit($,t))):[[t,`No model found for ${$}`]]}static ParseMode(t,$){let a=r.ModelMode.get($);return a?[].concat(...a.map($=>e.ParseBitEqual($,t))):[[t,`No model found for ${$}`]]}static ParseFilterID(t){return e.ParseBitEqual(r.BitEqualFilterID,t)}static ParseFilterID2(t){return e.ParseBitEqual(r.BitEqualFilterID2,t)}static ParseSrcSS(t){return e.ParseBitEqual(r.BitEqualSoundSpeed,t)}static ParseBeamSpacing(t,$){return 3002===$?e.ParseBitEqual(r.BitEqualBeamspacing3002Only,t):e.ParseBitEqual(r.BitEqualBeamspacing,t)}static ParseYawPitchStable(t){return e.ParseBitEqual(r.BitEqualYawPitchStable,t)}static ParseRXGain(t,$){return 2040!==$?[[0,0,t]]:e.ParseBitEqual(r.BitEqualRXFixedGain20040Only,t)}}class n{static TYPES=[80];static IsMyType(e){return -1<n.TYPES.findIndex(t=>t===e)}static STRUCT_POSITION=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["positionCounter","U2"],["serial","U2"],["lat","I4"],["lng","I4"],["measurePosFixQ","U2"],["speed","U2"],["course","U2"],["heading","U2"],["posSysDesc","U1"],["numInput","U1"]]);static ReadPosition=e.CreateReader(n.STRUCT_POSITION);static ParseLatDegree=e=>e/2e7;static ParseLngDegree=e=>e/1e7;static ParseSpeedMpS=e=>e/100;static ParseCourseDegree=e=>e/100;static ParseHeadingDegree=e=>e/100;static ParseSection(e,t,$){let a={},s={},r=n;r.ReadPosition._toObject(e,t,["date","time","lat","lng","speed","course","heading"],s,$);let o=T(s.date,s.time);return a.dt=o,a.lat=r.ParseLatDegree(s.lat),a.lng=r.ParseLngDegree(s.lng),a.speed=r.ParseSpeedMpS(s.speed),a.course=r.ParseCourseDegree(s.course),a.heading=r.ParseHeadingDegree(s.heading),a}static ParseSectionMinimum(e,t,$){let a=n,s=[a.ReadPosition.date(e,t,$),a.ReadPosition.time(e,t,$),n.ParseLatDegree(a.ReadPosition.lat(e,t,$)),n.ParseLngDegree(a.ReadPosition.lng(e,t,$)),n.ParseHeadingDegree(a.ReadPosition.heading(e,t,$)),];return s}static ParseSectionDescribe(t,$,a){let s=new Map;n.ReadPosition._toDescribeMap(t,$,s,a);let r=n.ReadPosition._size,o=$+r,l=s.get("numInput").v,c=o+l,_=e.ParseAscii(t,o,c);return s.set("input",e.Describe(_,"A"+l,l)),b(t,c,s,a),s}}class o{static TYPES=[68];static IsMyType(e){return -1<o.TYPES.findIndex(t=>t===e)}static STRUCT_DD_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["heading","U2"],["ss","U2"],["txTRDepth","U2"],["maxNumBeams","U1"],["numValid","U1"],["zRes","U1"],["xyRes","U1"],["freq","U2"]]);static STRUCT_DD_BODY=new Map([["z","U2"],["y","I2"],["x","I2"],["beamDeprAng","I2"],["beamAzimAng","U2"],["range","U2"],["QFac","U1"],["len","U1"],["reflectivity","I1"],["beamNum","U1"]]);static STRUCT_DD_BODY_SIGN=new Map([["z","I2"],["y","I2"],["x","I2"],["beamDeprAng","I2"],["beamAzimAng","U2"],["range","U2"],["QFac","U1"],["len","U1"],["reflectivity","I1"],["beamNum","U1"]]);static STRUCT_DD_TAIL=new Map([["depthOffsetM","I1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(o.STRUCT_DD_HEAD);static ReadBody=e.CreateReader(o.STRUCT_DD_BODY);static ReadBodySign=e.CreateReader(o.STRUCT_DD_BODY_SIGN);static ReadTail=e.CreateReader(o.STRUCT_DD_TAIL);static ParseSectionMinimum(e,t,$){let a=o.ReadHead.model(e,t,$),s=[o.ReadHead.date(e,t,$),o.ReadHead.time(e,t,$),o.ReadHead.numValid(e,t,$),o.ReadHead.txTRDepth(e,t,$)/100,],r=o.ReadHead._size+t,n=[],l=o.ReadBody;(120===a||300===a)&&(l=o.ReadBodySign);for(let c=0;c<s[2];c++){let _=r+c*l._size,d=l.x(e,_,$),u=l.y(e,_,$),p=l.z(e,_,$);n.push([d/100,u/100,p/100])}return s.push(n),s}static ParseSectionDescribe(e,t,$){let a=new Map;o.ReadHead._toDescribeMap(e,t,a,$);let s=a.get("model").v,r=a.get("numValid").v,n=o.ReadHead._size,l=o.ReadBody;(120===s||300===s)&&(l=o.ReadBodySign);for(let c=0;c<r;c++){let _=n+l._size*c,d=new Map;for(let[u,p]of(l._toDescribeMap(e,_,d,$),d.entries()))a.set(`e${c+1}_`+u,p)}return n+=l._size*r,o.ReadTail._toDescribeMap(e,n,a,$),a}}class l{static TYPES=[85];static IsMyType(e){return -1<l.TYPES.findIndex(t=>t===e)}static STRUCT_SS_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["date2","U4"],["time2","U4"],["numEntries","U2"],["depthRes","U2"]]);static STRUCT_SS_ENTRY=new Map([["depth","U4"],["ss","U4"]]);static STRUCT_SS_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(l.STRUCT_SS_HEAD);static ReadEntry=e.CreateReader(l.STRUCT_SS_ENTRY);static ReadTail=e.CreateReader(l.STRUCT_SS_TAIL);static ParseSectionDescribe(t,$,a){let s=new Map,r=!1!==a;l.ReadHead._toDescribeMap(t,$,s,a);let n=s.get("numEntries").v,o=$+l.ReadHead._size;for(let c=0;c<n;c++){let _=o+8*c,d=l.ReadEntry.depth(t,_,r),u=l.ReadEntry.ss(t,_+4,r);s.set(`depth_${c+1}`,e.Describe(d,"U4",4)),s.set(`ss_${c+1}`,e.Describe(u,"U4",4))}return o+=8*n,l.ReadTail._toDescribeMap(t,o,s,a),s}}class c{static TYPES=[48];static IsMyType(e){return -1<c.TYPES.findIndex(t=>t===e)}static STRUCT_PU_ID=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["byteOrder","U2"],["serial","U2"],["UDP1","U2"],["UDP2","U2"],["UDP3","U2"],["UDP4","U2"],["sysDesc","U4"],["PUVer","A16"],["BSPVer","A16"],["sonarHead1Ver","A16"],["sonarHead2Ver","A16"],["IPAddr","U4"],["txOpenAng","U1"],["rxOpenAng","U1"],["spare1","U4"],["spare2","U2"],["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadPUID=e.CreateReader(c.STRUCT_PU_ID);static ParseSectionDescribe(e,t,$){let a=new Map;return c.ReadPUID._toDescribeMap(e,t,a,$),a}}class _{static TYPES=[49];static IsMyType(e){return -1<_.TYPES.findIndex(t=>t===e)}static STRUCT_PU_STATUS=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["statusCounter","U2"],["serial","U2"],["pingRate","U2"],["pingCounter","U2"],["distSwath10","U4"],["UDP2","U4"],["serial1","U4"],["serial2","U4"],["serial3","U4"],["serial4","U4"],["pps","I1"],["posStat","I1"],["attStat","I1"],["clockStat","I1"],["headingStat","I1"],["puStat","U1"],["lastHeading","U2"],["lastRoll","I2"],["lastPitch","I2"],["lastHeave","U2"],["ssTrans","U2"],["lastDepth","U4"],["velocity","I2"],["attVelocity","U1"],["mammalRamp","U1"],["backObliqueAngle","I1"],["backIncidence","I1"],["fixedGain","I1"],["depthIncidence","U1"],["rangeIncidence","U2"],["portCoverage","U1"],["stbdCoverage","U1"],["ssTransProfile","U2"],["yawStabAngle","I2"],["portCoverage2","I2"],["stbdCoverage2","I2"],["tempCPU","I1"],["etx","U1"],["checksum","U2"],]);static ReadPUStatus=e.CreateReader(_.STRUCT_PU_STATUS);static ParseSectionDescribe(e,t,$){let a=new Map;return _.ReadPUStatus._toDescribeMap(e,t,a,$),a}}class d{static TYPES=[110];static IsMyType(e){return -1<d.TYPES.findIndex(t=>t===e)}static STRUCT_NATTV=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["netAttCounter","U2"],["serial","U2"],["numEntries","U2"],["senSysDesc","I1"],["spare1","U1"],]);static STRUCT_NATTV_ENTRY=new Map([["time","U2"],["roll","I2"],["pitch","I2"],["heave","I2"],["heading","U2"],["numBytes","U1"]]);static ReadHead=e.CreateReader(d.STRUCT_NATTV);static ReadEntry=e.CreateReader(d.STRUCT_NATTV_ENTRY);static ParseSectionDescribe(t,$,a){let s=new Map;d.ReadHead._toDescribeMap(t,$,s,a);let r=s.get("numEntries").v,n=$+d.ReadHead._size;for(let o=0;o<r;o++){let l=new Map;d.ReadEntry._toDescribeMap(t,n,l,a),n+=d.ReadEntry._size;let c=l.get("numBytes").v,_=e.ParseAscii(t,n,n+c);for(let[u,p]of(n+=c,l.set("inputs",e.Describe(_,"A"+c,c)),l.entries()))s.set(`e${o+1}_`+u,p)}return b(t,n,s,a),s}}class u{static TYPES=[67];static IsMyType(e){return -1<u.TYPES.findIndex(t=>t===e)}static STRUCT_CLOCK=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["clockCounter","U2"],["serial","U2"],["date2","U4"],["time2","U4"],["ppsUsed","U1"],["etx","U1"],["checksum","U2"]]);static ReadClock=e.CreateReader(u.STRUCT_CLOCK);static ParseSectionDescribe(e,t,$){let a=new Map;return u.ReadClock._toDescribeMap(e,t,a,$),a}}class p{static TYPES=[65];static IsMyType(e){return -1<p.TYPES.findIndex(t=>t===e)}static STRUCT_ATT_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["attCounter","U2"],["serial","U2"],["numEntries","U2"]]);static STRUCT_ATT_ENTRY=new Map([["time","U2"],["senStatus","U2"],["roll","I2"],["pitch","I2"],["heave","I2"],["heading","U2"]]);static STRUCT_ATT_TAIL=new Map([["senSysDesc","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(p.STRUCT_ATT_HEAD);static ReadEntry=e.CreateReader(p.STRUCT_ATT_ENTRY);static ReadTail=e.CreateReader(p.STRUCT_ATT_TAIL);static ParseSectionDescribe(e,t,$){let a=new Map;p.ReadHead._toDescribeMap(e,t,a,$);let s=a.get("numEntries").v,r=t+p.ReadHead._size;for(let n=0;n<s;n++){let o=new Map;for(let[l,c]of(p.ReadEntry._toDescribeMap(e,r,o,$),r+=p.ReadEntry._size,o.entries()))a.set(`e${n+1}_`+l,c)}return p.ReadTail._toDescribeMap(e,r,a,$),a}}class h{static TYPES=[83];static IsMyType(e){return -1<h.TYPES.findIndex(t=>t===e)}static STRUCT_SEABED_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["meanAbsorpCoeff","U2"],["pulseLen","U2"],["rangeIncience","U2"],["startTVG","U2"],["stoptTVG","U2"],["BSN","I1"],["BSO","I1"],["txBeamWidth","U2"],["tvgLaw","U1"],["numValidBeams","U1"]]);static STRUCT_SEABED_ENTRY=new Map([["idx","U1"],["direction","I1"],["Ns","U2"],["centreSampleNum","U2"]]);static ReadHead=e.CreateReader(h.STRUCT_SEABED_HEAD);static ReadEntry=e.CreateReader(h.STRUCT_SEABED_ENTRY);static ParseSectionDescribe(e,t,$){let a=new Map;h.ReadHead._toDescribeMap(e,t,a,$);let s=a.get("numValidBeams").v,r=t+h.ReadHead._size;for(let n=0;n<s;n++){let o=new Map;for(let[l,c]of(h.ReadEntry._toDescribeMap(e,r,o,$),r+=h.ReadEntry._size,o.entries()))a.set(`e${n+1}_`+l,c)}return a}}class U{static TYPES=[89,137];static IsMyType(e){return -1<U.TYPES.findIndex(t=>t===e)}static STRUCT_SEABED89_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["sampleFreq","F4"],["rangeIncience","U2"],["BSN","I2"],["BSO","I2"],["txBeamWidth","U2"],["tvgLaw","U2"],["numValidBeams","U2"]]);static STRUCT_SEABED89_ENTRY=new Map([["direction","I1"],["dInfo","U1"],["Ns","U2"],["centreSampleNum","U2"]]);static STRUCT_SEABED89_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(U.STRUCT_SEABED89_HEAD);static ReadEntry=e.CreateReader(U.STRUCT_SEABED89_ENTRY);static ReadTail=e.CreateReader(U.STRUCT_SEABED89_TAIL);static ParseSectionDescribe(t,$,a){let s=new Map,r=!1!==a;U.ReadHead._toDescribeMap(t,$,s,a);let n=s.get("numValidBeams").v,o=$+U.ReadHead._size,l=0;for(let c=0;c<n;c++){let _=new Map;U.ReadEntry._toDescribeMap(t,o,_,a),o+=U.ReadEntry._size;let d=_.get("Ns").v;for(let[u,p]of(l+=d,_.entries()))s.set(`e${c+1}_`+u,p)}for(let h=0;h<l;h++){let x=o+2*h,m=t.getInt16(x,r);s.set(`amplitudes${h+1}`,e.Describe(m,"I2",2))}return o+=2*l,U.ReadTail._toDescribeMap(t,o,s,a),s}}class x{static TYPES=[78,120];static IsMyType(e){return -1<x.TYPES.findIndex(t=>t===e)}static STRUCT_RAW78_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["ssTrans","U2"],["Ntx","U2"],["Nrx","U2"],["numValidDetect","U2"],["sampleFreq","F4"],["dScale","U4"]]);static STRUCT_RAW78_ENTRY_NTX=new Map([["tiltAngle","I2"],["focusRange","U2"],["sigLen","F4"],["secTransDelay","F4"],["centreFreq","F4"],["meanAbsorpCoeff","U2"],["sigId","U1"],["transSecNum","U1"],["sigBandwidth","F4"]]);static STRUCT_RAW78_ENTRY_RTX=new Map([["beamAngle","I2"],["transSecNum","U1"],["dInfo","U1"],["windowLen","U2"],["qFac","U1"],["dCorr","I1"],["twoTT","F4"],["BS","I2"],["cInfo","I1"],["spare","U1"],]);static STRUCT_RAW78_TAIL=new Map([["spareEOS","U1"],["etx","U1"],["checksum","U2"]]);static ReadHead=e.CreateReader(x.STRUCT_RAW78_HEAD);static ReadEntryTX=e.CreateReader(x.STRUCT_RAW78_ENTRY_NTX);static ReadEntryRX=e.CreateReader(x.STRUCT_RAW78_ENTRY_RTX);static ReadTail=e.CreateReader(x.STRUCT_RAW78_TAIL);static ParseSectionDescribe(e,t,$){let a=new Map;x.ReadHead._toDescribeMap(e,t,a,$);let s=a.get("Ntx").v,r=t+x.ReadHead._size;for(let n=0;n<s;n++){let o=new Map;for(let[l,c]of(x.ReadEntryTX._toDescribeMap(e,r,o,$),r+=x.ReadEntryTX._size,o.entries()))a.set(`ntx${n+1}_`+l,c)}let _=a.get("Nrx").v;for(let d=0;d<_;d++){let u=new Map;for(let[p,h]of(x.ReadEntryRX._toDescribeMap(e,r,u,$),r+=x.ReadEntryRX._size,u.entries()))a.set(`nrx${d+1}_`+p,h)}return x.ReadTail._toDescribeMap(e,r,a,$),a}}class m{static TYPES=[51];static IsMyType(e){return -1<m.TYPES.findIndex(t=>t===e)}static STRUCT_EXTRA_HEAD=new Map([["length","U4"],["stx","U1"],["type","U1"],["model","U2"],["date","U4"],["time","U4"],["pingCounter","U2"],["serial","U2"],["contentID","U2"]]);static ReadHead=e.CreateReader(m.STRUCT_EXTRA_HEAD);static ReadContentID6=(t,$,a,s)=>{let r=!1!==s,n=t.getUint16($,r);a.set("Nc",e.Describe(n,"U2",2));let o=e.ParseAscii(t,$+2,$+2+n);return a.set("content",e.Describe(o,"A"+n,n)),a};static ParseSectionDescribe(e,t,$){let a=new Map;m.ReadHead._toDescribeMap(e,t,a,$);let s=m.ReadHead._size,r=a.get("contentID").v;return 6===r&&(m.ReadContentID6(e,t+s,a,$),s=2+s+a.get("Nc").v),b(e,s,a,$),a}}function T(e,t){let $=parseInt(e/1e4),a=parseInt(e/100%100),s=parseInt(e%100),r=parseInt(t/1e3),n=parseInt(r/60/60),o=parseInt(r/60%60),l=parseInt(t/1e3%60),c=parseInt(t%1e3),_=`${$}-${a}-${s} ${n}:${o}:${l}.${c}`;return new Date(_)}function b(t,$,a,s){let r=$,n=!1!==s,o=t.getUint8(r,n);0===o&&(r++,a.set("spareEOS",e.Describe(0,"U1",1)));let l=t.getUint8(r++,n);a.set("etx",e.Describe(l,"U1",1));let c=t.getUint16(r++,n);a.set("checksum",e.Describe(c,"U2",2))}let f=(()=>{let e=new Map,t=[a,n,o,r,s,l,c,d,u,p,h,U,_,x,m,];return t.forEach(t=>{t.TYPES.forEach($=>{e.set($,t)})}),t=>e.get(t)})();function S(e,t){let a=new DataView(t.buffer,e.offset,e.len+$.BYTE_LENGTH);return a}class g{constructor(){this.mb=void 0,this.sections=void 0,this.isLE=!0,this.positions=void 0,this.xyz=void 0,this.lines=void 0}load(e,t,$){this.mb=e,this.sections=t,this.isLE=$,this.typeXYZ=this.judgeXYZ(),this.bytes=this.mb.byteLength}judgeXYZ(){return -1<this.sections.findIndex(e=>88===e.type)?88:-1<this.sections.findIndex(e=>68===e.type)?68:void 0}parsePosition(){let e=[],t=f(80);for(let $=0;$<this.sections.length;$++){let a=this.sections[$];if(80===a.type){let s=t.ParseSectionMinimum(this.mb,a.offset,a.length);e.push(s)}}this.positions=e}parseXYZ(){let e=[],t=this.typeXYZ,$=f(t);for(let a=0;a<this.sections.length;a++){let s=this.sections[a];if(68===s.type){let r=$.ParseSectionMinimum(this.mb,s.offset,s.length);e.push(r)}else if(88===s.type){let n=$.ParseSectionMinimum(this.mb,s.offset,s.length);e.push(n)}}this.xyz=e}calcPositionWithXYZ(){let e=Array(this.xyz.length);for(let t=0;t<this.xyz.length;t++){let $=this.xyz[t],a=this.findNearestPosition($[0],$[1]),s=$[4],r=[],n=s.map(e=>e[0]),o=g.destVincentyArray(a[2],a[3],a[4],n);for(let l=0;l<s.length;l++){let c=s[l],_=g.destVincenty(o[l][0],o[l][1],a[4]+90,c[1]);r.push([_[0],_[1],$[3]+c[2]])}e[t]=r}this.lines=e}_debugcalcPositionWithXYZ(){let e=[];for(let t=0;t<this.xyz.length;t++){let $=this.xyz[t],a=this.findNearestPosition($[0],$[1]),s=$[4],r=[];for(let n=0;n<s.length;n++){let o=s[n],l=g.destVincenty(a[2],a[3],a[4],o[0]),c=g.destVincenty(l.lat,l.lng,a[4]+90,o[1]);r.push([c.lat,c.lng,$[3]+o[2]])}e.push(r)}this.lines2=e}_testFindNearest(){for(let e=0;e<this.xyz.length;e++){let t=this.xyz[e],$=this.findNearestPosition(t[0],t[1]),a=this.findNearestPositionLinear(t[0],t[1]);if($!==a){console.log(`is diff ${t[0]} ${t[1]} at [${e}]`),console.log($,a);let s=[$[0]-t[0],$[1]-t[1]],r=[a[0]-t[0],a[1]-t[1]];console.log(s,r);break}}}_debugFindNearest(e){let t=this.xyz[e],$=this.findNearestPosition(t[0],t[1]),a=this.findNearestPositionLinear(t[0],t[1]);if($!==a){console.log(`is diff ${t[0]} ${t[1]} at [${e}]`),console.log($,a);let s=[$[0]-t[0],$[1]-t[1]],r=[a[0]-t[0],a[1]-t[1]];console.log(s,r)}}findNearestPosition(e,t){let $,a=0,s=this.positions.length-1;for(;s-a>1;)$=Math.floor((a+s)/2),this.positions[$][0]<e?a=$:this.positions[$][0]===e&&this.positions[$][1]<t?a=$:s=$;if(s===a)return this.positions[a];let r=this.positions[a],n=this.positions[s],o=[Math.abs(e-r[0]),Math.abs(t-r[1])],l=[Math.abs(e-n[0]),Math.abs(t-n[1])];return o[0]>l[0]?n:o[0]<l[0]?r:o[1]>l[1]?n:r}findNearestPositionLinear(e,t){return this.positions.reduce(($,a)=>{let s=[Math.abs(e-$[0]),Math.abs(t-$[1])],r=[Math.abs(e-a[0]),Math.abs(t-a[1])];return s[0]>r[0]?a:s[0]<r[0]?$:s[1]>r[1]?a:$})}clearMemory(){this.positions=[],this.xyz=[],this.sections=[],this.mb=void 0}static destVincentyArray(e,t,$,a){let s=[],r=1/298.257223563,n=$*Math.PI/180,o=Math.sin(n),l=Math.cos(n),c=(1-r)*Math.tan(e*Math.PI/180),_=1/Math.sqrt(1+c*c),d=c*_,u=Math.atan2(c,l),p=_*o,h=1-p*p,U=h*(40680631590769-40408299984087.055)/40408299984087.055,x=1+U/16384*(4096+U*(-768+U*(320-175*U))),m=U/1024*(256+U*(-128+U*(74-47*U)));for(let T=0;T<a.length;T++){let b=a[T],f=b,S=f/(6356752.3142*x),g=2*Math.PI;for(;Math.abs(S-g)>1e-12;){var E=Math.cos(2*u+S),D=Math.sin(S),C=Math.cos(S),P=m*D*(E+m/4*(C*(-1+2*E*E)-m/6*E*(-3+4*D*D)*(-3+4*E*E)));g=S,S=f/(6356752.3142*x)+P}var R=d*D-_*C*l,A=Math.atan2(d*C+_*D*l,(1-r)*Math.sqrt(p*p+R*R)),y=r/16*h*(4+r*(4-3*h)),M=Math.atan2(D*o,_*C-d*D*l)-(1-y)*r*p*(S+y*D*(E+y*C*(-1+2*E*E)));s.push([180*A/Math.PI,t+180*M/Math.PI])}return s}static destVincenty(e,t,$,a){for(var s=1/298.257223563,r=a,n=$*Math.PI/180,o=Math.sin(n),l=Math.cos(n),c=(1-s)*Math.tan(e*Math.PI/180),_=1/Math.sqrt(1+c*c),d=c*_,u=Math.atan2(c,l),p=_*o,h=1-p*p,U=h*(40680631590769-40408299984087.055)/40408299984087.055,x=1+U/16384*(4096+U*(-768+U*(320-175*U))),m=U/1024*(256+U*(-128+U*(74-47*U))),T=r/(6356752.3142*x),b=2*Math.PI;Math.abs(T-b)>1e-12;){var f=Math.cos(2*u+T),S=Math.sin(T),g=Math.cos(T),E=m*S*(f+m/4*(g*(-1+2*f*f)-m/6*f*(-3+4*S*S)*(-3+4*f*f)));b=T,T=r/(6356752.3142*x)+E}var D=d*S-_*g*l,C=s/16*h*(4+s*(4-3*h));return[180*Math.atan2(d*g+_*S*l,(1-s)*Math.sqrt(p*p+D*D))/Math.PI,t+180*(Math.atan2(S*o,_*g-d*S*l)-(1-C)*s*p*(T+C*S*(f+C*g*(-1+2*f*f))))/Math.PI]}static CreateInstanceFrom(e){let t=new g;return t.mb=e.mb,t.sections=e.sections,t.isLE=e.isLE,t.positions=e.positions,t.xyz=e.xyz,t.lines=e.lines,t}parseMeta(){let e={},t=this.parseMetaPosition();e.ts=t[0].ts,e.ms=t[0].ts.getTime(),e.lat=t[0].lat,e.lng=t[0].lng,e.ts2=t[1].ts,e.ms2=t[1].ts.getTime(),e.lat2=t[1].lat,e.lng2=t[1].lng;let $=this.parseMetaFirstRuntime();return e.eq=$.eq,e.eqid=$.eqid,e.count=this.parseMetaDepthSectionCount(),e.bytes=this.bytes,this.meta=e,e}parseMetaDepthSectionCount(){return this.sections.filter(e=>a.IsMyType(e.type)||o.IsMyType(e.type)).length}parseMetaPosition(){let e=n,t=this.sections.filter(t=>e.IsMyType(t.type)),$=[t[0],t.at(-1)].map(t=>e.ParseSectionMinimum(this.mb,t.offset,this.isLE)),a=$.map(e=>{let t={ts:T(e[0],e[1]),lat:e[2],lng:e[3]};return t});return a}parseMetaFirstRuntime(){let e=r,t=this.sections.find(t=>e.IsMyType(t.type)),$=e.ReadRuntime.model(this.mb,t.offset,this.isLE),a=e.ReadRuntime.serial(this.mb,t.offset,this.isLE);return{eq:"EM"+$,eqid:String(a)}}getMeta(){return this.meta}static GetMetaDesc(){return{eq:"EM + runtime[0].model",eqid:"runtime[0].serial",ts:"position[0].ts",ts2:"position.at(-1).ts",ms:"ts.getTime()",ms2:"ts2.getTime()",lat:"position[0].lat",lng:"position[0].lng",lat2:"position[1].lat",lng2:"position[1].lng",count:"number of xyz88 or depth datagram",bytes:"context.bytes from dataView.byteLength"}}}class E{static LoadArrayBuffer(e){let $=!0,a=new DataView(e),s=a.getUint32(0,!0),r=a.getUint32(0,!1);s>r&&($=!1);let n=E.ParseSectionTable(e,$),o=n.sectionTable;return o.forEach((e,$)=>e.title=t.EMAll.DescType(e.type)),n}static ParseSectionTable(e,t){let a=new $(e);a.littleEndian=t;let s=a.parseBrief();return{dataView:a,sectionTable:s,littleEndian:t}}static ParseMeta(e){let t=E.LoadArrayBuffer(e),$=new g;return $.load(t.dataView,t.sectionTable,t.littleEndian),$.parseMeta(),$.getMeta()}}return{EMAll:$,EMXYZ88:a,EMParamInstall:s,EMRuntimeParam:r,EMPosition:n,EMDepthDatagra:o,EMSoundSpeedProfile:l,EMPUID:c,EMNetworkAttitudeVelocity:d,EMClock:u,EMAttitude:p,EMSeabedImage:h,EMSeabedImage89:U,EMPUStatusOutput:_,EMRawRangeAngle78:x,EMExtra:m,GetParser:f,SliceToSection:S,ParseDateTime:T,ParserContext:g,ParserTest:E,ParseMeta:E.ParseMeta}})(),$=(()=>{class t{static TYPES=[1];static IsMyType(e){return -1<t.TYPES.findIndex(t=>t===e)}static TITLE="BinHeader";static STRUCT_BINARY_HEADER3200=new Map([["jobIDNum","U4"],["lineNum","U4"],["reelNum","U4"],["tracesPEns","U2"],["auxTracesPEns","U2"],["interval","U2"],["intervalOrg","U2"],["numSamplePTrace","U2"],["numSamplePTraceOrg","U2"],["code","U2"],["ensFold","U2"],["traceSortingCode","U2"],["vertSumCode","U2"],["sweepFreqStart","U2"],["sweepFreqEnd","U2"],["sweepLen","U2"],["sweepTypeCode","U2"],["traceNumSweepChannel","U2"],["sweepTTLenStart","U2"],["sweepTTLenEnd","U2"],["taperType","U2"],["corelTrace","U2"],["binGainRec","U2"],["ampRecM","U2"],["measureSystem","U2"],["impulseSigPol","U2"],["vibPolCode","U2"],["extNumTracePEns","U4"],["extNumAuxTracePEns","U4"],["extNumSample","U4"],["extInterval","F8"],["extIntervalOrG","F8"],["extNumSamplePTraceOrg","U4"],["extEnsFold","U4"],["constant1234","U4"]]);static STRUCT_BINARY_HEADER3500=new Map([["majorRev","U1"],["minorRev","U1"],["fixedLenTrace","U2"],["numExtTextHDR","U2"],["numAddTraceHDR","U4"],["timeCode","U2"],["numTraceInFile","U8"],["offsetTrace","U8"],["numTrailerStanza","I4"]]);static SAMPLE_FORMAT_CODE=[[1,"4-byte IBM floating-point",4,"F"],[2,"4-byte, two's complement integer",4,"I"],[3,"2-byte, two's complement integer",2,"I"],[4,"4-byte fixed-point with gain (obsolete)",4,"I"],[5,"4-byte IEEE floating-point",4,"F"],[6,"8-byte IEEE floating-point",8,"F"],[7,"3-byte two's complement integer",3,"I"],[8,"1-byte, two's complement integer",1,"I"],[9,"8-byte, two's complement integer",8,"I"],[10,"4-byte, unsigned integer",4,"I"],[11,"2-byte, unsigned integer",2,"I"],[12,"8-byte, unsigned integer",8,"I"],[15,"3-byte, unsigned integer",3,"I"],[16,"1-byte, unsigned integer",1,"I"],];static FindSampleFormatCode(e){let $=t.SAMPLE_FORMAT_CODE.find(t=>e===t[0]);return $}static DATE_TIME_CODE={1:"Local",2:"GMT",3:"Other",4:"UTC",5:"GPS"};static ReadBinaryHeader3200=e.CreateReader(t.STRUCT_BINARY_HEADER3200);static ReadBinaryHeader3500=e.CreateReader(t.STRUCT_BINARY_HEADER3500);static ParseSectionDescribe($,a,s){let r=new Map;t.ReadBinaryHeader3200._toDescribeMap($,a,r,s);let n=300-t.ReadBinaryHeader3200._size;for(let o=0;o<n/4;o++)r.set(`un_${o+1}`,e.Describe(0,"U",4));return t.ReadBinaryHeader3500._toDescribeMap($,a+300,r,s),r}static SOA2Degree(e){return e/3600}parseDetail(){this.setLittleEndian(!1);let e=this.parse(SegY.STRUCT_BINARY_HEADER3200,3200),t=this.parse(SegY.STRUCT_BINARY_HEADER3500,3500);Object.keys(t).forEach((t,$)=>e[t]=$),this.saveBrief(e),this.setParseOffset(3600);let $=[];if(SegY.SAMPLE_FORMAT_CODE.IBM_FP_4!==e.code&&SegY.SAMPLE_FORMAT_CODE.IEEE_FP_4!==e.code)alert("Only 32bit floating point implemented, please report");else{for(this.setLittleEndian(!1);this.parseOffset<this.byteLength;){let a=this.parseTraceOne();$.push(a)}return{binHeader:e,traces:$}}}parseTraceOne(){let e=this.parse(SegY.STRUCT_TRACE_HEADER),t={},$=new Date;if($.setUTCFullYear(e.year),$.setUTCMonth(0),$.setUTCDate(e.day),$.setUTCHours(e.hour),$.setUTCMinutes(e.minute),$.setUTCSeconds(e.second),$.setUTCMilliseconds(0),t.date=$,t.dateBase=SegY.DATE_TIME_CODE[e.timeCode],2===e.coordUnit){let a=e.srcCoordX/36e5,s=e.srcCoordY/36e5;t.srcPos=[s,a]}this.addParseOffset(10);let r=[];for(let n=0;n<e.numSample;n++){let o=this.getFloat32(this.parseOffset);r.push(o),this.parseOffset=this.parseOffset+4}return{header:e,parsedHeader:t,data:r}}getPrettyPrintBinHeader(){let e=this.getBrief();if(!e)return"Not yet parsed, or invalid";let t=[`Major: ${e.majorRev}, Minor: ${e.minorRev}`,`Data format code: ${e.code} - ${this.getCodeStr(e.code)}`,`Sample per trace: ${e.numSamplePTrace}`,`Interval: ${e.interval}us`,];return t.join("\n")}getCodeStr(e){let t="";return Object.keys(SegY.SAMPLE_FORMAT_CODE).forEach($=>{let a=SegY.SAMPLE_FORMAT_CODE[$];a===e&&(t=$)}),t}}class ${static TYPES=[2];static IsMyType(e){return -1<$.TYPES.findIndex(t=>t===e)}static TITLE="Trace";static STRUCT_TRACE_HEADER=new Map([["traceSeqLine","U4"],["traceSeqFile","U4"],["orgFieldRecNum","U4"],["traceNumOrg","U4"],["energySrc","U4"],["ensNum","U4"],["traceNumEns","U4"],["traceIDCode","U2"],["numVertSum","U2"],["numHoriSum","U2"],["dataUse","U2"],["distCent","U4"],["elevRecv","U4"],["surfElev","U4"],["srcDepth","U4"],["seisDatumRecv","U4"],["seisDatumSrc","U4"],["watColHeiSrc","U4"],["watColHeiRecv","U4"],["scalarElev","I2"],["scalarCoord","I2"],["srcCoordX","I4"],["srcCoordY","I4"],["grpCoordX","I4"],["grpCoordY","I4"],["coordUnit","U2"],["weatherVel","U2"],["subWeatherVel","U2"],["upSrcMS","U2"],["upGrpMS","U2"],["srcCorrMS","U2"],["grpCorrMS","U2"],["totMS","U2"],["lagAMS","U2"],["lagBMS","U2"],["delayRecMS","U2"],["muiteStartMS","U2"],["muiteEndMS","U2"],["numSample","U2"],["intervalSample","U2"],["gainType","U2"],["instGain","U2"],["instInitGain","U2"],["correlated","U2"],["sweepFreqS","U2"],["sweepFreqE","U2"],["sweepLen","U2"],["sweepType","U2"],["sweepTraceLenS","U2"],["sweepTraceLenE","U2"],["taperType","U2"],["aliasFFreq","U2"],["aliasFSlope","U2"],["notchFFreq","U2"],["notchFSlope","U2"],["lcFreq","U2"],["hcFreq","U2"],["lcSlope","U2"],["hcSlope","U2"],["year","U2"],["day","U2"],["hour","U2"],["minute","U2"],["second","U2"],["timeCode","U2"],["traceWeiFac","U2"],["geoGNRoll","U2"],["geoGNTrace","U2"],["geoGNLTrace","U2"],["gapSize","U2"],["overTravel","U2"],["XcoordEns","U4"],["YcoordEns","U4"],["PSinline","U4"],["PScrossline","U4"],["shotpoint","U4"],["scalarShot","U2"],["traceUnit","I2"],["transC","U8"],["transUnit","I2"],["id","U2"],["scalarTimes","U2"],["srcType","I2"],["srcEnergyDir","U2"],["sourceM1","U4"],["sourceM2","U2"],["srcUnit","I2"],["useless1","U4"],["useless2","U4"],["useless3","U2"]]);static ReadTraceHeader=e.CreateReader($.STRUCT_TRACE_HEADER);static ParseSectionDescribe4F(t,a,s){let r=new Map;$.ReadTraceHeader._toDescribeMap(t,a,r,s);let n=r.get("numSample").v;for(let o=0;o<n;o++){let l=a+$.ReadTraceHeader._size+4*o,c=t.getFloat32(l,s);r.set("dataF4_"+o,e.Describe(c,"F4",4))}return r}static ParseSection(e,t,a){let s=$.ReadTraceHeader.traceSeqLine(e,t,a),r=$.ReadTraceHeader.numSample(e,t,a),n=$.ReadTraceHeader.intervalSample(e,t,a),o=$.ReadTraceHeader.year(e,t,a),l=$.ReadTraceHeader.day(e,t,a),c=$.ReadTraceHeader.hour(e,t,a),_=$.ReadTraceHeader.minute(e,t,a),d=$.ReadTraceHeader.second(e,t,a),u=$.ReadTraceHeader.timeCode(e,t,a),p=new Date;p.setUTCFullYear(o),p.setUTCMonth(0),p.setUTCDate(l),p.setUTCHours(c),p.setUTCMinutes(_),p.setUTCSeconds(d),p.setUTCMilliseconds(0);let h=$.ReadTraceHeader.coordUnit(e,t,a),U=0,x=0;return 2===h&&(x=$.ReadTraceHeader.srcCoordX(e,t,a)/36e5,U=$.ReadTraceHeader.srcCoordY(e,t,a)/36e5),[s,r,n,p,u,U,x]}static ParseSectionData4F(e,t,a){let s=$.ReadTraceHeader.numSample(e,t,a),r=[];for(let n=0;n<s;n++){let o=t+$.ReadTraceHeader._size+4*n,l=e.getFloat32(o,a);r.push(l)}return r}static ParseSectionData(e,a,s,r){let n=t.SAMPLE_FORMAT_CODE.find(e=>e[0]===r);if(n&&4===n[2]&&"F"===n[3])return $.ParseSectionData4F(e,a,s)}}class a{static TYPES=[3];static IsMyType(e){return -1<a.TYPES.findIndex(t=>t===e)}static TITLE="Text";static SIZE_TEXT_HEADER=3200;static MapEBCDIC={0:0,1:1,2:2,3:3,4:26,5:9,6:26,7:127,8:26,9:26,10:26,11:11,12:12,13:13,14:14,15:15,16:16,17:17,18:18,19:19,20:26,21:26,22:8,23:26,24:24,25:25,26:26,27:26,28:28,29:29,30:30,31:31,32:26,33:26,34:26,35:26,36:26,37:10,38:23,39:27,40:26,41:26,42:26,43:26,44:26,45:5,46:6,47:7,48:26,49:26,50:22,51:26,52:26,53:26,54:26,55:4,56:26,57:26,58:26,59:26,60:20,61:21,62:26,63:26,64:32,65:26,66:26,67:26,68:26,69:26,70:26,71:26,72:26,73:26,74:91,75:46,76:60,77:40,78:43,79:33,80:38,81:26,82:26,83:26,84:26,85:26,86:26,87:26,88:26,89:26,90:93,91:36,92:42,93:41,94:59,95:94,96:45,97:47,98:26,99:26,100:26,101:26,102:26,103:26,104:26,105:26,106:124,107:44,108:37,109:95,110:62,111:63,112:26,113:26,114:26,115:26,116:26,117:26,118:26,119:26,120:26,121:96,122:58,123:35,124:64,125:39,126:61,127:34,128:26,129:97,130:98,131:99,132:100,133:101,134:102,135:103,136:104,137:105,138:26,139:26,140:26,141:26,142:26,143:26,144:26,145:106,146:107,147:108,148:109,149:110,150:111,151:112,152:113,153:114,154:26,155:26,156:26,157:26,158:26,159:26,160:26,161:126,162:115,163:116,164:117,165:118,166:119,167:120,168:121,169:122,170:26,171:26,172:26,173:26,174:26,175:26,176:26,177:26,178:26,179:26,180:26,181:26,182:26,183:26,184:26,185:26,186:26,187:26,188:26,189:26,190:26,191:26,192:123,193:65,194:66,195:67,196:68,197:69,198:70,199:71,200:72,201:73,202:26,203:26,204:26,205:26,206:26,207:26,208:125,209:74,210:75,211:76,212:77,213:78,214:79,215:80,216:81,217:82,218:26,219:26,220:26,221:26,222:26,223:26,224:92,225:26,226:83,227:84,228:85,229:86,230:87,231:88,232:89,233:90,234:26,235:26,236:26,237:26,238:26,239:26,240:48,241:49,242:50,243:51,244:52,245:53,246:54,247:55,248:56,249:57,250:26,251:26,252:26,253:26,254:26,255:26};static ParseTextHeader0(e,t,$){let s=e.buffer.slice(t,t+a.SIZE_TEXT_HEADER),r=new DataView(s),n=r.getUint8(0),o;67===n?o="ASCII":195===n&&(o="EBCDIC");let l;if("EBCDIC"===o){let c=new Uint8Array(a.SIZE_TEXT_HEADER);for(let _=0;_<a.SIZE_TEXT_HEADER;_++){let d=a.MapEBCDIC[r.getUint8(_)];d?c[_]=d:c[_]=32}l=String.fromCharCode.apply(null,c)}else"ASCII"===o&&(l=String.fromCharCode.apply(null,new Uint8Array(s)));let u={text:l,lines:void 0,type:o};if(l){let p=l.match(/.{80}/g);u.lines=p}return u}static ParseSectionDescribe(t,$,s){let r=new Map,n=a.ParseTextHeader0(t,$,s),o=n.text||"";return r.set("text",e.Describe(o,"A"+a.SIZE_TEXT_HEADER,a.SIZE_TEXT_HEADER)),r}}class s{static LoadArrayBuffer(e){let t,$=new DataView(e),a=$.getUint32(3204,!0),r=$.getUint32(3204,!1),n=$.getUint16(3212,!0),o=$.getUint16(3212,!1),l=$.getUint16(3224,!0),c=$.getUint16(3224,!1),_=[[a,r],[n,o],[l,c]];for(let d=0;d<_.length;d++){let u=_[d],p=u[0],h=u[1];if(p>h){t=!1;break}if(p<h){t=!0;break}}!0!==t&&!1!==t&&(t=!0,console.info("Could not judge endianness!!, proceed as little endian"));let U=s.ParseSectionTable(e,t);return U}static ParseSectionTable(e,s){let r={dataView:void 0,sections:void 0,isLE:s,bin:void 0},n=[],o=new DataView(e),l=a.ParseTextHeader0(o,0,s),c=t.ParseSectionDescribe(o,3200,s);r.dataView=o,r.bin=c,r.text=l;let _={type:a.TYPES[0],title:a.TITLE,offset:0,len:3200},d={type:t.TYPES[0],title:t.TITLE,offset:3200,len:400};n.push(_),n.push(d);let u=c.get("offsetTrace").v,p=3600+parseInt(u),h=t.SAMPLE_FORMAT_CODE[4],U=c.get("code").v,x=t.SAMPLE_FORMAT_CODE.find(e=>U===e[0]);void 0===x?(console.error("Critical error, sample format code is Mandatory for all data but its empty"),console.info(`Sample code is ${U}`),console.info("Just proceed with 4 byte floating point")):h=x;let m=h[2],T=$.ReadTraceHeader._size,b=p;for(;b<o.byteLength;){let f=$.ReadTraceHeader.numSample(o,b,s),S=T+f*m,g={type:$.TYPES[0],title:$.TITLE,offset:b,len:S};n.push(g),b+=S}return r.sections=n,r}static ParseMeta(e){let t=new r;return t.load(e),t.parseMeta(),t.getMeta()}}class r{constructor(){this.dataView=void 0,this.sections=void 0,this.isLE=!0,this.binHeader=void 0,this.sampleCode=0,this.sampleCodeFound=void 0,this.traces=[]}load(e){let $=s.LoadArrayBuffer(e);this.dataView=$.dataView,this.sections=$.sections,this.isLE=$.isLE,this.binHeader=$.bin,this.sampleCode=this.binHeader.get("code").v,0<this.sampleCode&&(this.sampleCodeFound=t.FindSampleFormatCode(this.sampleCode))}parseTraces(){let e=this.isLE,t=this.sections.filter(e=>$.IsMyType(e.type)),a=t.map(t=>$.ParseSectionData(this.dataView,t.offset,e,this.sampleCode));return this.traces=a,this.traces}clearMemory(){this.dataView=void 0,this.sections=[],this.traces=[]}parseMeta(){let e={},t=this.sections.filter(e=>$.IsMyType(e.type)),a=[t[0],t.at(-1)],s=a.map(e=>$.ParseSection(this.dataView,e.offset,this.isLE,this.sampleCode));return e.ts=s[0][3],e.ms=e.ts.getTime(),e.lat=s[0][5],e.lng=s[0][6],e.ts2=s[1][3],e.ms2=e.ts2.getTime(),e.lat2=s[1][5],e.lng2=s[1][6],e.desc=`interval : ${s[0][2]}, number samples : ${s[0][1]}`,e.count=t.length,e.bytes=this.dataView.byteLength,this.meta=e,this.meta}getMeta(){return this.meta}static GetMetaDesc(){return{ts:"trace[0].ts",ms:"trace[0].ts.getTime()",lat:"trace[0].lat",lng:"trace[0].lng",ts2:"trace[-1].ts",ms2:"trace[-1].ts.getTime()",lat2:"trace[-1].lat",lng2:"trace[-1].lng",desc:"trace[0].interval, trace[0].numSample",count:"trace.length",bytes:"arrayBuffer.byteLength"}}}let n=(()=>{let e=new Map,a=[t,$,];return a.forEach(t=>{t.TYPES.forEach($=>{e.set($,t)})}),t=>e.get(t)})();function o(e,t){let $=new DataView(t.buffer,e.offset,e.len);return $}return{SEGY:t,SEGYTrace:$,SEGYText:a,GetParser:n,SliceToSection:o,ParserContext:r,ParserTest:s,ParseMeta:s.ParseMeta}})(),a=(()=>{function e(e,t){let $=t.match(/([^\.\[]*)/g),a=[];if($.forEach(e=>{0!==e.length&&(e.match(/(\d+)\]$/)?a.push(parseInt(e)):a.push(e))}),0===a.length){console.log(`getValueFromObject Invalid expression ${e}, '${t}'`);return}let s=e;return a.forEach(e=>s=s[e]),s}class t{constructor(){this.listFiles=[],this.listURLs=[],this.mapGroup={}}addFile(e){let a=t.MatchFileName(e.name);a&&!0===a.found&&(this.listFiles.push(e),this.mapGroup.hasOwnProperty(a.filenameLower)||(this.mapGroup[a.filenameLower]=new $),this.mapGroup[a.filenameLower].addFile(e))}addURL(e){let a=t.MatchFileName(e);a&&!0===a.found&&(this.listURLs.push(e),this.mapGroup.hasOwnProperty(a.filenameLower)||(this.mapGroup[a.filenameLower]=new $),this.mapGroup[a.filenameLower].addURL(e))}getGroup(e){if(this.mapGroup.hasOwnProperty(e))return this.mapGroup[e]}getNames(){return Object.keys(this.mapGroup)}getGroups(){return Object.values(this.mapGroup)}static MatchFileName(e){let t=e.match(/([^/]*)\.([^.]*)$/i);if(t){let $=t[1],a=$.toLowerCase(),s=t[2],r=s.toLowerCase(),n=["hex","bl","hdr","xmlcon"].findIndex(e=>r===e);return{filename:$,filenameLower:a,ext:s,extLower:r,found:-1!==n}}}}class ${constructor(){this.files={bl:void 0,hdr:void 0,hex:void 0,xmlcon:void 0},this.urls={bl:void 0,hdr:void 0,hex:void 0,xmlcon:void 0},this.instance={bl:void 0,hdr:void 0,hex:void 0,xmlcon:void 0},this.name=void 0}addFile(e){let $=t.MatchFileName(e.name);$&&!0===$.found&&(this.files[$.extLower]=e,this.name=$.filename)}addURL(e){let $=t.MatchFileName(e);$&&!0===$.found&&(this.urls[$.extLower]=e,this.name=$.filename)}getName(){return this.name}async parse(){if(this.files.hex){let e=new n;this.instance.hex=e,e.setParent(this),await e.setFile(this.files.hex)}if(this.files.xmlcon){let t=new o;this.instance.xmlcon=t,t.setParent(this),await t.setFile(this.files.xmlcon)}if(this.files.hdr){let $=new s;this.instance.hdr=$,$.setParent(this),await $.setFile(this.files.hdr)}if(this.files.bl){let a=new r;this.instance.bl=a,a.setParent(this),await a.setFile(this.files.bl)}}async parseChunk(){if(this.files.hex){let e=new n;this.instance.hex=e,e.setParent(this),await e.setFileChunk(this.files.hex)}if(this.files.xmlcon){let t=new o;this.instance.xmlcon=t,t.setParent(this),await t.setFile(this.files.xmlcon)}}async parseURLs(){if(this.urls.hex){let e=new n;this.instance.hex=e,e.setParent(this),await e.setFileURL(this.urls.hex)}if(this.urls.xmlcon){let t=new o;this.instance.xmlcon=t,t.setParent(this),await t.setFileURL(this.urls.xmlcon)}if(this.urls.hdr){let $=new s;this.instance.hdr=$,$.setParent(this),await $.setFileURL(this.urls.hdr)}if(this.urls.bl){let a=new r;this.instance.bl=a,a.setParent(this),await a.setFileURL(this.urls.bl)}}async parseURLsChunk(){if(this.urls.hex){let e=new n;this.instance.hex=e,e.setParent(this),await e.setFileURLChunk(this.urls.hex)}if(this.urls.xmlcon){let t=new o;this.instance.xmlcon=t,t.setParent(this),await t.setFileURL(this.urls.xmlcon)}}unload(){}getHex(){return this.instance.hex}getXmlcon(){return this.instance.xmlcon}getHdr(){return this.instance.hdr}getBl(){return this.instance.bl}parseMeta(){let e={},t={},$=this.getHex(),a=this.getHdr(),r=this.getXmlcon();if($){let l=$.parseMeta(),c=n.GetMetaDesc();["lat","lng","ts","ms","count","desc","bytes"].forEach($=>{e[$]=l[$],t[$]=c[$]})}else if(a){let _=a.parseMeta(),d=s.GetMetaDesc();["lat","lng","ts","ms","bytes"].forEach($=>{e[$]=_[$],t[$]=d[$]})}if(r){let u=r.parseMeta(),p=o.GetMetaDesc();["eq","eqid"].forEach($=>{e[$]=u[$],t[$]=p[$]})}return this.meta=e,this.metaDesc=t,e}getMeta(){return this.meta}static GetMetaDesc(){return{lat:"HEX, HDR string NMEA Latitude = lat",lng:"HEX, HDR string NMEA Longitude = lng",ts:"HEX, HDR string NMEA UTC (Time) = ts",ms:"HEX, HDR string NMEA UTC (Time) = ts to ms",count:"HEX length of line",desc:"HEX getParsingDescription()",bytes:"HEX, HDR content-length or file.size"}}}class a{constructor(){this.parent=void 0}setParent(e){this.parent=e}getHex(){if(this.parent)return this.parent.getHex()}getXmlcon(){if(this.parent)return this.parent.getXmlcon()}getBl(){if(this.parent)return this.parent.getBl()}getHdr(){if(this.parent)return this.parent.getHdr()}}class s extends a{constructor(){super(),this.file=void 0,this.parsedHDR=void 0}static parseHDR(e){let t=e.match(/Number of Bytes Per Scan = (.*)$/m),$=e.match(/NMEA Latitude = (.*)$/m),a=e.match(/NMEA Longitude = (.*)$/m),s=e.match(/NMEA UTC \(Time\) = (.*)$/m),r=e.match(/System UTC = (.*)$/m),n=e.match(/Number of Scans Averaged by the Deck Unit = (.*)$/m),o={bytes:t,lat:$,lng:a,utc:s,utcSystem:r,scanAvg:n};if(o.bytes&&(o.bytes=parseInt(o.bytes[1])),o.lat){o.nmeaLat=o.lat[1];let l=o.lat[1].match(/(\d*) ([\d\.]*) (N|S)/);if(l){let c=parseInt(l[1]),_=parseFloat(l[2])/60;o.lat=c+_,"S"===l[3]&&(o.lat=-1*o.lat)}}if(o.lng){o.nmeaLng=o.lng[1];let d=o.lng[1].match(/(\d*) ([\d\.]*) (E|W)/);if(d){let u=parseInt(d[1]),p=parseFloat(d[2])/60;o.lng=u+p,"W"===d[3]&&(o.lng=-1*o.lng)}}if(o.utc){let h=o.utc[1],U=new Date(h);U=new Date(U.getTime()+-6e4*U.getTimezoneOffset()),o.nmeaUTC=h,o.utc=U}if(o.utcSystem){let x=o.utcSystem[1],m=new Date(x);m=new Date(m.getTime()+-6e4*m.getTimezoneOffset()),o.systemUTC=x,o.utc=m}return o.scanAvg&&(o.scanAvg=parseInt(o.scanAvg[1])),o}async setFile(e){let t=await e.text();this.setDataSource(t),this.bytes=e.size}async setFileURL(e){let t=await fetch(e),$=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt($)}setDataSource(e){this.dataSource=e;let t=s.parseHDR(this.dataSource);this.parsedHDR=t}getParsedHDR(){return this.parsedHDR}parseMeta(){if(!this.parsedHDR){console.error("hdr should parsed before");return}let e={};return e.lat=this.parsedHDR.lat,e.lng=this.parsedHDR.lng,e.ts=this.parsedHDR.utc,e.ms=e.ts?.getTime(),e.bytes=this.bytes,this.meta=e,e}getMeta(){return this.meta}static GetMetaDesc(){return{lat:"HDR string NMEA Latitude = lat",lng:"HDR string NMEA Longitude = lng",ts:"HDR string NMEA UTC (Time) = ts",ms:"HDR string NMEA UTC (Time) = ts to ms",bytes:"HDR content-length header or file.size"}}}class r extends a{constructor(){super(),this.file=void 0,this.dataSource=void 0}static parseBL(e){let t={},$=0,a=e.split("\n");a.forEach(e=>{let a=r.parseBLLine(e);a&&($++,t[a.fired]=a)});let s={countFired:$,fired:t};return s}static parseBLLine(e){let t=e.split(",");if(5!==t.length)return!1;let $={fired:parseInt(t[1]),dateStr:t[2],rawLineS:parseInt(t[3]),rawLineE:parseInt(t[4])};return $}static parseBLHEX(e,t){e.fired&&t&&Object.keys(e.fired).forEach($=>{let a=e.fired[$],s=t.parseValue(a.rawLineS),r=s.value.altimeter,n=s.value.f2depth,o=s.value.f0,l=s.value.f1psu;r&&(a.altimeter=s.value.altimeter),a.depth=n,a.t=o,a.s=l})}async setFile(e){let t=await e.text();this.setDataSource(t),this.bytes=e.size}async setFileURL(e){let t=await fetch(e),$=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt($)}setDataSource(e){this.dataSource=e;let t=r.parseBL(this.dataSource);if(!this.getHex()){console.error("CTDBL.setDataSource : got no hex, can not proceed"),console.log(t);return}r.parseBLHEX(t,this.getHex()),this.parsedBL=t}getParsedBL(){return this.parsedBL}}class n extends a{static TIME_BASE_MS=9466848e5;static CHUNK_SIZE=10240;constructor(){super(),this.file=void 0,this.dataSource=void 0,this.parsingDesc={countFreq:3,countAD:0,countADWords:0,surfacePar:!1,nmeaPosition:!1,nmeaDepth:!1,nmeaTime:!1,scanTime:!1,scanAvg:-99}}async setFileChunk(e){let t=e.slice(0,n.CHUNK_SIZE-1),$=await t.text();this.setDataSource($),this.bytes=e.size}async setFile(e){let t=await e.text();this.setDataSource(t),this.bytes=e.size}async setFileURLChunk(e){let t=await fetch(e,{headers:{range:`bytes=0-${n.CHUNK_SIZE-1}`}}),$=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt($)}async setFileURL(e){let t=await fetch(e),$=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt($)}setDataSource(e){this.updateParsingDescription();let t=n.SplitEdge(e);this.header=t.header,this.body=t.body,this.bodyLength=t.bodyLength,this.lineLength=t.lineLength,this.EOLLength=t.EOLLength,this.parseHeader()}static SplitEdge(e){let t=e.slice(0,2048),$;for(let a=0;a<t.length-1;a++){let s=t.charCodeAt(a);if(10===s){let r=t.charCodeAt(a+1);if(42!==r){$=a;break}}}if(!$)return;let n=t.slice(0,$),o=e.slice($+1),l=-1,c=-1,_=1;for(let d=0;d<1024;d++)if(10===o.charCodeAt(d)){c=d+1,l=Math.floor(o.length/c);break}13===o.charCodeAt(c-2)&&(_=2);let u=e=>{if(e>=l)return;let t=c*e,$=t+c,a=o.slice(t,$-_);return a};return{header:n,body:o,bodyLength:l,lineLength:c,EOLLength:_,getLine:u}}static Ascii2ta(e){let t=new Uint8Array(e.length/2),$=0;for(let a=0;a<e.length;a+=2){let s=(parseInt(e[a],16)<<4)+parseInt(e[a+1],16);t[$++]=s}return t}parseHeader(){let e=s.parseHDR(this.header);if(this.parsedHDR=e,1===this.parsedHDR.scanAvg){let t=parseInt(this.getLength()/24);this.parsedHDR.scanDuration=t}else this.parsedHDR.scanDuration=-99}getParsedHDR(){return this.parsedHDR}getRaw(e){if(e>=this.bodyLength)return;let t=this.lineLength*e,$=t+this.lineLength,a=this.body.slice(t,$-this.EOLLength);return n.Ascii2ta(a)}parseValue(e){let t=this.getXmlcon();if(!t)return console.error("CTDHex.getValue : No xmlcon given"),!1;let $=t.getParsedMap(),a=t.findSensorKeyByType("Altimeter"),s=this.parseRaw(e),r=s.psT*$.f2.coef.AD590M+$.f2.coef.AD590B,n=$.f0.getValue(s.f0).DegreeC,o=$.f2.getValue(s.f2,r).psi,c=l.PSI2Decibar(o),_=l.DECIBAR2Depth(c,s.lat),d=$.f1.getValue(s.f1,n,c).SPerM,u=l.COND2PSU(d,n,c);if(s.value={f0:n,f1:d,f1psu:u,f2:o,f2decibar:c,f2depth:_},a){let p=s[a],h=$[a].getValue(p).meter;s.value.altimeter=h}return s}parseRaw(e){let t=this.getRaw(e),$=this._parseBasic(t);return $}parseDepthOnly(e){let t=this.getRaw(e),$=this._parseDepthOnly(t);return $}_parseBasic(e){let t={},$=this.parsingDesc,a=0;for(let s=0;s<$.countFreq;s++)t["f"+s]=256*e[a++]+e[a++]+e[a++]/256;let r=[];for(let o=0;o<$.countADWords;o++)r.push(e[a++]<<16|e[a++]<<8|e[a++]);let l=0;if(r.forEach(e=>{t["v"+l]=5*(1-(e>>>12)/4095),t["v"+ ++l]=5*(1-(4095&e)/4095),l++}),$.surfacePar){a++;let c=e[a++]<<8|e[a++];t.spV=(4095&c)/819}if($.nmeaPosition){let _=(65536*e[a++]+256*e[a++]+e[a++])/5e4,d=(65536*e[a++]+256*e[a++]+e[a++])/5e4,u=e[a++];1===u&128&&(_*=-1),1===u&64&&(d*=-1),t.lat=_,t.lng=d}if($.nmeaTime){let p=e[a++]|e[a++]<<8|e[a++]<<16|e[a++]<<24,h=n.TIME_BASE_MS+1e3*p;t.date=new Date(h),t.dateMS=h}let U=e[a++]<<8|e[a++];return t.psT=U>>>4,t.CTDStatus={pump:1==(1&U),bot:2==(2&U),ws:4==(4&U),cr:8==(8&U),s:(15&U).toString(2).padStart(4,"0")},t.moduloCount=e[a++],t}_parseDepthOnly(e){let t={},$=this.parsingDesc,a=0;if(a=6,t.f2=256*e[a++]+e[a++]+e[a++]/256,a=3*$.countFreq,a+=3*$.countADWords,$.surfacePar&&(a+=3),$.nmeaPosition){let s=(65536*e[a++]+256*e[a++]+e[a++])/5e4,r=(65536*e[a++]+256*e[a++]+e[a++])/5e4,n=e[a++];1===n&128&&(s*=-1),1===n&64&&(r*=-1),t.lat=s,t.lng=r}$.nmeaTime&&(a+=4);let o=e[a++]<<8|e[a++];return t.psT=o>>>4,t}updateParsingDescription(){let e=this.getXmlcon();if(!e)return;let t=e.getInstrument(),$=5-t.freqSuppress,a=8-t.voltSuppress,s=1===t.surfacePar,r=1===t.nmeaPosition,n=1===t.nmeaDepth,o=1===t.nmeaTime,l=1===t.scanTime;this.parsingDesc={countFreq:$,countAD:a,countADWords:a/2,surfacePar:s,nmeaPosition:r,nmeaDepth:n,nmeaTime:o,scanTime:l,scanAvg:t.scanAvg}}getLength(){return this.bodyLength}getParsingDescription(){return this.parsingDesc}getParsedHDR(){return this.parsedHDR}unload(){this.body=void 0}parseMeta(){if(!this.parsedHDR){console.error("hdr should parsed before");return}let e=this.getParsingDescription(),t=Object.keys(e).map(t=>`${t}: ${e[t]}`).join(", "),$={};return $.lat=this.parsedHDR.lat,$.lng=this.parsedHDR.lng,$.ts=this.parsedHDR.utc,$.ms=$.ts?.getTime(),$.count=this.getLength(),$.desc=t,$.bytes=this.bytes,this.meta=$,$}getMeta(){return this.meta}static GetMetaDesc(){return{lat:"HEX HDR string NMEA Latitude = lat",lng:"HEX HDR string NMEA Longitude = lng",ts:"HEX HDR string NMEA UTC (Time) = ts",ms:"HEX HDR string NMEA UTC (Time) = ts to ms",count:"HEX getLength()",desc:"HEX getParsingDescription()",bytes:"HEX content-length header or file.size"}}}class o extends a{static SENSOR_MAP=[{sensorID:3,attribute:"ConductivitySensor",title:"Conductivity",coef:{CPcor:"Coefficients[1].CPcor",CTcor:"Coefficients[1].CTcor",G:"Coefficients[1].G",H:"Coefficients[1].H",I:"Coefficients[1].I",J:"Coefficients[1].J",WBOTC:"Coefficients[1].WBOTC"},getValue(e,t,$,a){let s=t/1e3,r=e.G+e.H*Math.pow(s,2)+e.I*Math.pow(s,3)+e.J*Math.pow(s,4),n=1+e.CTcor*$+e.CPcor*a;return{SPerM:r/10*n}}},{sensorID:55,attribute:"TemperatureSensor",title:"Temperature",coef:["F0","G","H","I","J","Offset","Slope","UseG_J"],getValue(e,t){let $=e.F0/t,a=Math.log($);return{DegreeC:1/(e.G+e.H*a+e.I*Math.pow(a,2)+e.J*Math.pow(a,3))-273.15}}},{sensorID:45,attribute:"PressureSensor",title:"Pressure",coef:["AD590B","AD590M","C1","C2","C3","D1","D2","Offset","Slope","T1","T2","T3","T4","T5"],getValue(e,t,$){let a=e.C1+e.C2*$+e.C3*Math.pow($,2),s=e.D1+e.D2*$,r=e.T1+e.T2*$+e.T3*Math.pow($,2)+e.T4*Math.pow($,3)+e.T5*Math.pow($,4),n=1/t*1e6,o=a*(1-Math.pow(r,2)/Math.pow(n,2))*(1-s*(1-Math.pow(r,2)/Math.pow(n,2)));return{psia:o,psi:o-14.7}}},{sensorID:38,attribute:"OxygenSensor",title:"Oxygen",coef:{A:"CalibrationCoefficients[1].A",B:"CalibrationCoefficients[1].B",C:"CalibrationCoefficients[1].C",D0:"CalibrationCoefficients[1].D0",D1:"CalibrationCoefficients[1].D1",D2:"CalibrationCoefficients[1].D2",E:"CalibrationCoefficients[1].E",H1:"CalibrationCoefficients[1].H1",H2:"CalibrationCoefficients[1].H2",H3:"CalibrationCoefficients[1].H3",Soc:"CalibrationCoefficients[1].Soc",Tau20:"CalibrationCoefficients[1].Tau20",offset:"CalibrationCoefficients[1].offset"}},{sensorID:71,attribute:"WET_LabsCStar",title:"Transmissometer",coef:["B","M","PathLength"]},{sensorID:20,attribute:"FluoroWetlabECO_AFL_FL_Sensor",title:"Fluorometer",coef:["ScaleFactor","Vblank"]},{sensorID:42,attribute:"PAR_BiosphericalLicorChelseaSensor",title:"PAR_Biospherical",coef:["B","M","Multiplier","Offset"]},{sensorID:0,attribute:"AltimeterSensor",title:"Altimeter",coef:["ScaleFactor","Offset"],getValue:(e,t)=>({meter:300*t/e.ScaleFactor+e.Offset})},{sensorID:27,attribute:"NotInUse",title:"NotInUse"}];constructor(){super(),this.file=void 0,this.dataSource=void 0,this.parsedMap={f0:void 0,f1:void 0,f2:void 0,f3:void 0,f4:void 0,v0:void 0,v1:void 0,v2:void 0,v3:void 0,v4:void 0,v5:void 0,v6:void 0,v7:void 0}}static parseXml(e){var t=null;if(window.DOMParser)try{t=new DOMParser().parseFromString(e,"text/xml")}catch($){t=null}return t}static xmlToJson(e){var t={};if(1==e.nodeType){if(e.attributes.length>0){t["@attributes"]={};for(var $=0;$<e.attributes.length;$++){var a=e.attributes.item($);t["@attributes"][a.nodeName]=a.nodeValue}}}else 3==e.nodeType&&(t=e.nodeValue);if(e.hasChildNodes())for(var s=0;s<e.childNodes.length;s++){var r=e.childNodes.item(s),n=r.nodeName;if(void 0===t[n])t[n]=o.xmlToJson(r);else{if(void 0===t[n].push){var l=t[n];t[n]=[],t[n].push(l)}t[n].push(o.xmlToJson(r))}}return t}static parseCTDXMLConfig(e){let t=[];try{e.SBE_InstrumentConfiguration.Instrument.SensorArray.Sensor.forEach((e,$)=>{let a=o.parseSensor(e);a&&(a.key=$,t.push(a))})}catch($){console.log($)}return t}static parseSensor(t){let $=t["@attributes"].SensorID,a=o.SENSOR_MAP.find(e=>e.sensorID==$);if(!a)return console.warn(`CTDXMLCON.parseSensor sensor ID not found ${$}`),!1;let s=t[a.attribute],r=s.SerialNumber["#text"],n=s.CalibrationDate["#text"];n||(n="");let l;a.coef&&("function"==typeof a.coef?l=a.coef(s):"object"==typeof a.coef&&(l={},Array.isArray(a.coef)?a.coef.forEach(t=>{let $=e(s,t);$&&$.hasOwnProperty("#text")?l[t]=parseFloat($["#text"]):(console.error("CTDXMLCON.parseSensor Invalid Coef"),console.error(t))}):Object.keys(a.coef).forEach(t=>{let $=a.coef[t],r=e(s,$);r&&r.hasOwnProperty("#text")?l[t]=parseFloat(r["#text"]):(console.error("CTDXMLCON.parseSensor Invalid Coef"),console.error(t))})));let c;return a.getValue&&"function"==typeof a.getValue&&(c=(...e)=>a.getValue(l,...e)),{id:$,type:a.title,serial:r,calibration:n,coef:l,getValue:c}}async setFile(e){let t=await e.text();this.setDataSource(t),this.bytes=e.size}async setFileURL(e){let t=await fetch(e),$=t.headers.get("content-length"),a=await t.text();this.setDataSource(a),this.bytes=parseInt($)}setDataSource(e){let t=o.parseXml(e),$=o.xmlToJson(t);this.dataSource=$,this.parsed=o.parseCTDXMLConfig($);let a=$.SBE_InstrumentConfiguration.Instrument;this.instrument={freqSuppress:parseInt(a.FrequencyChannelsSuppressed["#text"]),voltSuppress:parseInt(a.VoltageWordsSuppressed["#text"]),nmeaDepth:parseInt(a.NmeaDepthDataAdded["#text"]),nmeaPosition:parseInt(a.NmeaPositionDataAdded["#text"]),nmeaTime:parseInt(a.NmeaTimeAdded["#text"]),scanTime:parseInt(a.ScanTimeAdded["#text"]),surfacePar:parseInt(a.SurfaceParVoltageAdded["#text"]),scanAvg:parseInt(a.ScansToAverage["#text"])},["f0","f1","f2","f3","f4","v0","v1","v2","v3","v4","v5","v6","v7"].forEach((e,t)=>{let $=this.getSensorAt(t);$&&"NotInUse"!==$.type&&(this.parsedMap[e]=$)});let s=this.getHex();s&&s.updateParsingDescription()}parseMeta(){if(!this.dataSource)return console.error("Required dataSource json from xml"),!1;let e={},t=this.dataSource.SBE_InstrumentConfiguration.Instrument;e.eq=t.Name["#text"];let $=t.SensorArray.Sensor.find(e=>"45"===e["@attributes"].SensorID);return e.eqid=$.PressureSensor.SerialNumber["#text"],e.bytes=this.bytes,this.meta=e,this.meta}getMeta(){return this.meta}static GetMetaDesc(){return{eq:"XMLCON.Instrument.Name",eqid:"XMLCON.Instrument.SensorArray.Sensor.SensorID == 45 serial",bytes:"XMLCON content-length header or file.size"}}getInstrument(){return this.instrument}getSensorAt(e){if(!this.parsed){console.error(`CTDXMLCON.getSensorAt Not yet parsed ${e}`);return}if(e<this.parsed.length)return this.parsed[e]}getParsedMap(){return this.parsedMap}findSensorKeyByType(e){let t=this.getParsedMap();if(!t)return console.log("CTDXmlcon.findSensorType : no xml parsed"),!1;let $;return Object.keys(t).forEach(a=>{let s=t[a];s&&e===s.type&&($=a)}),$}}class l{static D="&deg;";static DC="&deg;C";static SpM="S/m";static PSU="PSU";static M="m";static MpS="m/s";static PSI2Decibar(e){return .689476*e}static DECIBAR2Depth(e,t){let $,a,s;return $=Math.sin(t/57.29578),$*=$,s=9.780318*(1+(.0052788+236e-7*$)*$)+1092e-9*e,a=(((-.00000000000000182*e+2279e-13)*e-22512e-9)*e+9.72659)*e,s&&(a/=s),a}static COND2PSU(e,t,$){let a=[.008,-.1692,25.3851,14.0941,-7.0261,2.7081],s=[5e-4,-.0056,-.0066,-.0375,.0636,-.0144],r,n,o,l,c,_,d,u,p;if(e<=0)return 0;for(e*=10,(u=1+.03426*t+4464e-7*t*t+.4215*(r=e/42.914)+-.003107*r*t)&&(o=1+$*(207e-7+$*(-.000000000637+3989e-18*$))/u),(u=o*(.6766097+t*(.0200564+t*(1104259e-10+t*(-.00000069698+10031e-13*t)))))&&(n=r/u),n<=0&&(n=1e-6),c=_=0,p=0;p<6;p++)l=Math.pow(n,p/2),c+=a[p]*l,_+=s[p]*l;return(u=1+.0162*(t-15))?c+_*(t-15)/u:-99}static SVChenMillero(e,t,$){let a,s,r,n,o,l,c,_,d,u,p,h,U,x,m,T,b;return x=$/10,e<0&&(e=0),m=Math.sqrt(e),T=.001727-79836e-10*x,_=73637e-9+17945e-11*t,l=(c=-.01922-442e-7*t)+_*x,o=(-.0000000000003389*t+6649e-15)*t+11e-11,n=((7988e-15*t-16002e-14)*t+91041e-13)*t-39064e-11,a=((o*x+n)*x+(r=(((-.00000000020122*t+10507e-12)*t-64885e-12)*t-1258e-8)*t+94742e-9))*x+(s=(((-.0000000321*t+2006e-9)*t+7164e-8)*t-.01262)*t+1.389),U=(-.0000000000023643*t+38504e-14)*t-97729e-13,h=(((10405e-16*t-25335e-14)*t+25974e-12)*t-17107e-10)*t+3126e-8,b=(d=((U*x+h)*x+(p=(((-.00000000061185*t+13621e-11)*t-81788e-10)*t+68982e-8)*t+.153563))*x+(u=((((31464e-13*t-1478e-9)*t+3342e-7)*t-.0580852)*t+5.03711)*t+1402.388))+(a+l*m+T*e)*e}static PrettyDepth(e,t=1,$,a){return l.PrettyPrint(e,l.M,t,$,a)}static PrettyTemp(e,t,$,a){return l.PrettyPrint(e,l.DC,t,$,a)}static PrettySal(e,t,$,a){return l.PrettyPrint(e,l.PSU,t,$,a)}static PrettyPrint(e,t,$=4,a=!0,s=!0){let r=l.Round(e,$),n="";return n=a?r.toFixed($):String(r),s&&(n+=" "),t&&(n+=t),n}static PrettySensor(e,t=3){return 0===t?e.type+" "+e.serial:e.type.slice(0,t)+" "+e.serial}static Round(e,t){return+(Math.round(e+"e+"+t)+"e-"+t)}}class c{constructor(){this.group=void 0,this.hex=void 0,this.xmlcon=void 0,this.sensors=void 0}setGroup(e){this.group=e,this.setHex(e.getHex()),this.setXmlcon(e.getXmlcon())}setHex(e){this.hex=e}setXmlcon(e){this.xmlcon=e,this.sensors=e.getParsedMap()}parseDownUp(e){if(!this.hex||!this.xmlcon)return console.error("SeaParser.parseBrief no hex or no xmlcon"),!1;let t=this.hex.getLength();e||(e=parseInt(t/10));let $=e,a=0,s=t,r=0,n=null,o=0;for(;e===$;){r=(r=parseInt((s-a)/e))<1?1:r;let l=Math.floor((n=this._loopInF2(a,s,r))-e/2),c=Math.ceil(n+e/2);if(a=l<a?a:l,e>(s=c>s?s:c)-a&&(e=s-a),++o>100){console.error("Invalid condition, program in infinite loop");break}}let _={d:[0,n],u:[n+1,t-1]};return _}_loopInF2(e,t,$){let a=-999,s=-1;for(let r=e;r<=t;r+=$){let n=this.hex.parseDepthOnly(r);a<n.f2&&(a=n.f2,s=r)}return i}parseDepthTest(){let e=this.hex.getLength(),t=-1,$=-1,a,s,r=new Date().getTime();for(let n=0;n<e;n++){let o=this.hex.parseRaw(n);t<o.f2&&(t=o.f2,a=o)}let l=new Date().getTime()-r,c=new Date().getTime();for(let _=0;_<e;_++){let d=this.hex.parseDepthOnly(_);$<d.f2&&($=d.f2,s=d)}let u=new Date().getTime()-c;console.log(`count: ${e}, rawMS: ${l}, depthMS: ${u}`),console.log(`maxRaw ${t}, maxDepth ${$}`),console.log(a,s)}parseTest(){this.parseDownUp(),this.parseDepthTest()}}return{CTDFileList:t,CTDGroup:$,CTDChild:a,CTDHex:n,CTDXMLCON:o,SeaConvert:l,SeaParser:c}})(),s=(()=>{class t extends DataView{static TYPES=[0];static IsMyType(e){return -1<t.TYPES.findIndex(t=>t===e)}static STRUCT_HEADER=new Map([["hID","U2"],["noBytesEns","U2"],["spare01","U1"],["noDataTypes","U1"]]);static STRUCT_DATA_TYPES=new Map([["addr","U2"]]);static ReadHeader=e.CreateReader(t.STRUCT_HEADER);static ReadDataTypes=e.CreateReader(t.STRUCT_DATA_TYPES);static ParseSection(e,$=0,a=!0){let s={};t.ReadHeader._toObject(e,$,["hID","noBytesEns","noDataTypes"],s,a);let r=t.ReadHeader._size,n=$+r,o=[];for(let l=0;l<s.noDataTypes;l++){let c=n+2*l,_=e.getUint16(c,a);o.push(_)}return s.offsets=o,s}static ParseSectionDescribe($,a,s){let r=new Map;t.ReadHeader._toDescribeMap($,a,r,s);let n=r.get("noDataTypes").v,o=t.ReadHeader._size;for(let l=0;l<n;l++){let c=o+2*l,_=a+c,d=$.getUint16(_,s),u=e.Describe(d,"U2",2);r.set(`addr_${l}`,u)}return r}}class ${static TYPES=[0];static IsMyType(e){return -1<$.TYPES.findIndex(t=>t===e)}static FIXED_LEADER=new Map([["hID","U2"],["fwVer","U1"],["fwRev","U1"],["sysCfg","U2"],["flagSim","U1"],["lagLen","U1"],["noBeams","U1"],["noCells","U1"],["pingsPEns","U2"],["dptCellLen","U2"],["blankTrans","U2"],["profMode","U1"],["lowCorrThresh","U1"],["noCodeReps","U1"],["PGMin","U1"],["EVMax","U2"],["TPPm","U1"],["TPPs","U1"],["TPPHund","U1"],["coordTransf","U1"],["hdtAli","U2"],["hdtBias","U2"],["sensorSrc","U1"],["sensorsAvail","U1"],["bin1Dist","U2"],["xmitPulseLen","U2"],["WPRefAvg","U2"],["falseTgtThresh","U1"],["spare02","U1"],["transLagDist","U2"],["cpuSerial","U8"],["sysBandwidth","U2"],["sysPwr","U1"],["spare03","U1"],["insSerial","U4"],["beamAngle","U1"]]);static SYSTEM=[[0,"75kHz"],[1,"150kHz"],[2,"300kHz"],[3,"600kHz"],[4,"1200kHz"],[5,"2400kHz"],[6,"38kHz"]];static COORD=[[0,"No transformation"],[8,"Instrument coordinates"],[16,"Ship coordinates"],[24,"Earth coordinate"],];static SENSOR_SRC=[[64,"Calculates EC (Speed of sound) from ED, ES, ET"],[32,"Uses ED from depth sensor"],[16,"Uses EH from transducer heading sensor"],[8,"Uses EP from transducer pitch sensor"],[4,"Uses ER from transducer roll sensor"],[2,"Uses ES (Salinity) from transducer conductivity sensor"],[1,"Uses ET from transducer temperature sensor"],];static ParseCoordTransform(e){let t=24&e,a=$.COORD.find(e=>e[0]===t),s=a?a[1]:h.UNHANDLED_STR+` value : ${t}`,r=0<(4&e),n=0<(2&e),o=0<(1&e);return{type:t,typeStr:s,tilt:r,tiltStr:r?"Tilt pitch roll used":"Tilt pitch roll not used",beam3:n,beam3Str:n?"3-Beam solution used":"3-Beam solution not used",binMapping:o,binMappingStr:o?"Bin mapping used":"Bin mapping not used"}}static ParseSysConfig(e){let t=255&e,a=(65280&e)>>8,s=7&t,r=48&t,n=$.SYSTEM.find(e=>e[0]===s),o=n?n[1]:h.UNHANDLED_STR+` value : ${s.toString(2)}`,l=h.UNHANDLED_STR;0===r?l="Sensor Config 1":16===r?l="Sensor Config 2":32===r&&(l="Sensor Config 3");let c=3&a,_=240&a,d=h.UNHANDLED_STR+` value : ${c.toString(2)}`,u=h.UNHANDLED_STR+` value : ${_.toString(2)}`;0===c?d="15E Beam Angle":1===c?d="20E Beam Angle":2===c?d="30E Beam Angle":3===c&&(d="Other Beam Angle"),64===_?u="4-Beam JANUS Config":80===_?u="5-Beam JANUS Config DEMOD":240===_&&(u="5-Beam JANUS Config 2 DEMOD");let p={systemStr:o,conBeamStr:0<(8&t)?"CONVEX BEAM PAT":"CONCAVE BEAM PAT",sensorCfgStr:l,xdcrStr:0<(64&t)?"XDCR HD Attached":"XDCR HD Not Attached",beamFaceStr:0<(128&t)?"Up Facing beam":"Down Facing beam",beamAngleStr:d,janusStr:u};return p}static ParseSensorSrc(e){let t=[];return $.SENSOR_SRC.forEach($=>{0<($[0]&e)&&t.push($[1])}),t}static ReadFixedLeader=e.CreateReader($.FIXED_LEADER);static ParseSysCfg(e,t,a){let s=$.ReadFixedLeader.sysCfg(e,t,a),r=$.ParseSysConfig(s);return r}static ParseCoord(e,t,a){let s=$.ReadFixedLeader.coordTransf(e,t,a),r=$.ParseCoordTransform(s);return r}static ParseSectionDescribe(e,t,a){let s=new Map;return $.ReadFixedLeader._toDescribeMap(e,t,s,a),s}}class a{static TYPES=[128];static IsMyType(e){return -1<a.TYPES.findIndex(t=>t===e)}static VARIABLE_LEADER=new Map([["hID","U2"],["noEns","U2"],["tsYear","U1"],["tsMonth","U1"],["tsDay","U1"],["tsHour","U1"],["tsMin","U1"],["tsSec","U1"],["tsHundredths","U1"],["ensMSB","U1"],["bitResult","U2"],["soundSpeed","U2"],["dptTrans","U2"],["hdt","U2"],["pitch","I2"],["roll","I2"],["salinity","U2"],["temp","I2"],["mptMin","U1"],["mptSec","U1"],["mptHundredths","U1"],["stdHdt","U1"],["stdPitch","U1"],["stdRoll","U1"],["adc0","U1"],["adc1","U1"],["adc2","U1"],["adc3","U1"],["adc4","U1"],["adc5","U1"],["adc6","U1"],["adc7","U1"],["errStatus","U4"],["spare01","U2"],["pressure","U4"],["pressureVar","U4"],["spare02","U1"],["rtcCentury","U1"],["rtcYear","U1"]]);static BIT_RESULT_HI=[[16,"DEMOD 1 Error"],[8,"DEMOD 0 Error"],[2,"Timing card Error"],];static ERROR_STATUS1=[[1,"Bus error exception"],[2,"Address error exception"],[4,"Illegal Instruction exception"],[8,"Zero Divide exception"],[16,"Emulator exception"],[32,"Unassigned exception"],[64,"Watchdog restart occured"],[128,"Batter saver power"],];static ERROR_STATUS2=[[1,"Pinging"],[64,"Cold wakeup occurred"],[128,"Unknown wakeup occurred"],];static ERROR_STATUS3=[[1,"Clock read error occurred"],[2,"Unexpected alarm"],[4,"Clock jump forward"],[8,"Clock jump backward"],];static ERROR_STATUS4=[[8,"Power fail - unrecorded"],[16,"spurious level 4 intr - DSP"],[32,"spurious level 5 intr - UART"],[64,"spurious level 6 intr - CLOCK"],[128,"Level 7 interrupt occurred"],];static ParseBitResult(e){let t=e>>8,$=[];return a.BIT_RESULT_HI.forEach(e=>{0<(e[0]&t)&&$.push(e[1])}),$}static ParseErrorStatus(e){let t=255&e,$=(65280&e)>>8,s=(16711680&e)>>16,r=(4278190080&e)>>24,n=[];return a.ERROR_STATUS1.forEach(e=>{0<(e[0]&t)&&n.push(e[1])}),a.ERROR_STATUS2.forEach(e=>{0<(e[0]&$)&&n.push(e[1])}),a.ERROR_STATUS3.forEach(e=>{0<(e[0]&s)&&n.push(e[1])}),a.ERROR_STATUS4.forEach(e=>{0<(e[0]&r)&&n.push(e[1])}),n}static ParseDate(e,t,$,a,s,r,n){return e>80?e+=1900:e+=2e3,t-=1,new Date(Date.UTC(e,t,$,a,s,r,10*n))}static ReadVariableLeader=e.CreateReader(a.VARIABLE_LEADER);static ParseSectionDescribe(e,t,$){let s=new Map;return a.ReadVariableLeader._toDescribeMap(e,t,s,$),s}static ParseTimeStamp(e,t,$){let s={};a.ReadVariableLeader._toObject(e,t,["tsYear","tsMonth","tsDay","tsHour","tsMin","tsSec","tsHundredths"],s,$);let r=a.ParseDate(s.tsYear,s.tsMonth,s.tsDay,s.tsHour,s.tsMin,s.tsSec,s.tsHundredths);return r}}class s{static TYPES=[256];static IsMyType(e){return -1<s.TYPES.findIndex(t=>t===e)}static SIZE_VELOCITY=8;static DEPTH_CELL=new Map([["v1","I2"],["v2","I2"],["v3","I2"],["v4","I2"]]);static ParseVelocity2D(e,t){return $.COORD[0][0]!==e&&$.COORD[3][0]===e&&s.ParseVelocity2DEarth(t)}static ParseVelocity2DEarth(e){let t=s.XYMagDir(e[0],e[1]);return{magnitude:t[0],direction:t[1],e:e[0],n:e[1],sur:e[2],err:e[3]}}static XYMagDir(e,t){return[Math.sqrt(e*e+t*t),(360-Math.atan2(t,e)*(180/Math.PI)+90)%360]}static TrueWind(e,t,$,a){let s=Math.sqrt($*$+e*e-2*$*e*Math.cos(t*Math.PI/180));return[s,a+Math.acos((e*e-s*s-$*$)/(2*s*$))*(180/Math.PI)]}static DegreeToRange(e){if(isNaN(e=Number(e)))return 0;for(;e<0;)e=360+e;return e%360}static ReadDepthCell=e.CreateReader(s.DEPTH_CELL);static ParseSection(e,t=0,$=!0){let a=e.getUint16(t,$),r=(e.byteLength-2)/s.ReadDepthCell._size;return[a,r]}static ParseCell(e,t=2,$=!0){let a=[s.ReadDepthCell.v1(e,t,$),s.ReadDepthCell.v2(e,t,$),s.ReadDepthCell.v3(e,t,$),s.ReadDepthCell.v4(e,t,$),];return a}static ParseCellAt(e,t,$=!0){let a=2+t*s.ReadDepthCell._size;return s.ParseCell(e,a,$)}static ParseSectionDescribe(t,$=0,a=!0){let r=new Map,n=t.getUint16($,a);r.set("hID",e.Describe(n,"U2",2));let o=$+2,l=(t.byteLength-2)/s.ReadDepthCell._size;for(let c=0;c<l;c++){let _=new Map;for(let[d,u]of(s.ReadDepthCell._toDescribeMap(t,o,_,a),o+=s.ReadDepthCell._size,_.entries()))r.set(`dc${c+1}_`+d,u)}return r}}class r{static TYPES=[512];static IsMyType(e){return -1<r.TYPES.findIndex(t=>t===e)}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static SIZE_CORR=4;static ReadDepthCell=e.CreateReader(r.DEPTH_CELL);static ParseSectionDescribe(t,$=0,a=!0){let s=new Map,n=t.getUint16($,a);s.set("hID",e.Describe(n,"U2",2));let o=$+2,l=(t.byteLength-2)/r.ReadDepthCell._size;for(let c=0;c<l;c++){let _=new Map;for(let[d,u]of(r.ReadDepthCell._toDescribeMap(t,o,_,a),o+=r.ReadDepthCell._size,_.entries()))s.set(`dc${c+1}_`+d,u)}return s}}class n{static TYPES=[768];static IsMyType(e){return -1<n.TYPES.findIndex(t=>t===e)}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static ReadDepthCell=e.CreateReader(n.DEPTH_CELL);static ParseSectionDescribe(t,$=0,a=!0){let s=new Map,r=t.getUint16($,a);s.set("hID",e.Describe(r,"U2",2));let o=$+2,l=(t.byteLength-2)/n.ReadDepthCell._size;for(let c=0;c<l;c++){let _=new Map;for(let[d,u]of(n.ReadDepthCell._toDescribeMap(t,o,_,a),o+=n.ReadDepthCell._size,_.entries()))s.set(`dc${c+1}_`+d,u)}return s}}class o{static TYPES=[1024];static IsMyType(e){return -1<o.TYPES.findIndex(t=>t===e)}static DEPTH_CELL=new Map([["f1","U1"],["f2","U1"],["f3","U1"],["f4","U1"]]);static ReadDepthCell=e.CreateReader(o.DEPTH_CELL);static ParseSectionDescribe(t,$=0,a=!0){let s=new Map,r=t.getUint16($,a);s.set("hID",e.Describe(r,"U2",2));let n=$+2,l=(t.byteLength-2)/o.ReadDepthCell._size;for(let c=0;c<l;c++){let _=new Map;for(let[d,u]of(o.ReadDepthCell._toDescribeMap(t,n,_,a),n+=o.ReadDepthCell._size,_.entries()))s.set(`dc${c+1}_`+d,u)}return s}}class l{static TYPES=[1280];static IsMyType(e){return -1<l.TYPES.findIndex(t=>t===e)}static DEPTH_CELL=new Map([["b1","U1"],["b2","U1"],["b3","U1"],["b4","U1"]]);static ReadDepthCell=e.CreateReader(l.DEPTH_CELL);static ParseSectionDescribe(t,$=0,a=!0){let s=new Map,r=t.getUint16($,a);s.set("hID",e.Describe(r,"U2",2));let n=$+2,o=(t.byteLength-2)/l.ReadDepthCell._size;for(let c=0;c<o;c++){let _=new Map;for(let[d,u]of(l.ReadDepthCell._toDescribeMap(t,n,_,a),n+=l.ReadDepthCell._size,_.entries()))s.set(`dc${c+1}_`+d,u)}}}class c{static TYPES=[1536];static IsMyType(e){return -1<c.TYPES.findIndex(t=>t===e)}static BT_DATA=new Map([["hID","U2"],["pingsPEns","U2"],["delayReacq","U2"],["corrMagMin","U1"],["evalAmpMin","U1"],["pgMin","U1"],["mode","U1"],["errVelMax","U2"],["reserved","U4"],["range1","U2"],["range2","U2"],["range3","U2"],["range4","U2"],["vel1","U2"],["vel2","U2"],["vel3","U2"],["vel4","U2"],["corr1","U1"],["corr2","U1"],["corr3","U1"],["corr4","U1"],["evalAmp1","U1"],["evalAmp2","U1"],["evalAmp3","U1"],["evalAmp4","U1"],["pg1","U1"],["pg2","U1"],["pg3","U1"],["pg4","U1"],["rl1","U2"],["rl2","U2"],["rl3","U2"],["rlVel1","U2"],["rlVel2","U2"],["rlVel3","U2"],["rlVel4","U2"],["rlcm1","U1"],["rlcm2","U1"],["rlcm3","U1"],["rlcm4","U1"],["rlei1","U1"],["rlei2","U1"],["rlei3","U1"],["rlei4","U1"],["rlpg1","U1"],["rlpg2","U1"],["rlpg3","U1"],["rlpg4","U1"],["maxDepth","U2"],["rssiAmp1","U1"],["rssiAmp2","U1"],["rssiAmp3","U1"],["rssiAmp4","U1"],["gain","U1"],["rangeMSB1","U1"],["rangeMSB2","U1"],["rangeMSB3","U1"],["rangeMSB4","U1"],]);static BT_LAYER_WORD=new Map([["min","U2"],["near","U2"],["far","U2"],]);static ReadBottomTrack=e.CreateReader(c.BT_DATA);static ParseSectionDescribe(e,t=0,$=!0){let a=new Map;return c.ReadBottomTrack._toDescribeMap(e,t,a,$),a}}class _{}class d{static NAV_DATA=new Map([["hID","U2"],["utcDay","U1"],["utcMonth","U1"],["utcYear","U2"],["utcTimeFF","I4"],["pcClockOffset","I4"],["firstLat","U4"],["firstLng","U4"],["utcTimeLF","U4"],["lastLat","U4"],["lastLng","U4"],["avgSpd","I2"],["avgTrackTrue","U2"],["avgTrackMag","U2"],["SMG","U2"],["DMG","U2"],["reserved1","U2"],["flags","U2"],["reserved2","U2"],["noEns","U4"],["ensYear","U2"],["ensDay","U1"],["ensMonth","U1"],["ensTime","U4"],["pitch","I2"],["roll","I2"],["hdt","U2"],["numSpeedAvg","U2"],["numTTAvg","U2"],["numMTAvg","U2"],["numHdtAvg","U2"],["numPRAvg","U2"]]);static BAM(e,t){return 180*e/Math.pow(2,t-1)}static parseNavFlags(e){let t=[],$=[];return 0==(1&e)&&t.push("Data not updated"),0==(2&e)&&t.push("PSN Invalid"),0==(4&e)&&t.push("Speed Invalid"),0==(8&e)&&t.push("Mag Track Invalid"),0==(16&e)&&t.push("True Track Invalid"),0==(32&e)&&t.push("Date/Time Invalid"),0==(64&e)&&t.push("SMG/DMG Invalid"),0==(128&e)&&t.push("Pitch/Roll Invalid"),0==(256&e)&&t.push("Heading Invalid"),0==(512&e)&&t.push("ADCP Time Invalid"),0==(1024&e)&&t.push("Clock offset Time Invalid"),0!=(1&e)&&$.push("Data updated"),0!=(2&e)&&$.push("PSN Valid"),0!=(4&e)&&$.push("Speed Valid"),0!=(8&e)&&$.push("Mag Track Valid"),0!=(16&e)&&$.push("True Track Valid"),0!=(32&e)&&$.push("Date/Time Valid"),0!=(64&e)&&$.push("SMG/DMG Valid"),0!=(128&e)&&$.push("Pitch/Roll Valid"),0!=(256&e)&&$.push("Heading Valid"),0!=(512&e)&&$.push("ADCP Time Valid"),0!=(1024&e)&&$.push("Clock offset Time Valid"),{invalid:t,valid:$}}static ReadNavigation=e.CreateReader(d.NAV_DATA);static ParseSMGDMG(e,t=0,$=!0){let a=d.ReadNavigation.SMG(e,t,$),s=d.ReadNavigation.DMG(e,t,$);return[a,s]}static ParsePositionFirst(e,t=0,$=!0){let a=d.ReadNavigation.firstLat(e,t,$),s=d.ReadNavigation.firstLng(e,t,$);return[a,s]}static ParsePositionLast(e,t=0,$=!0){let a=d.ReadNavigation.lastLat(e,t,$),s=d.ReadNavigation.lastLng(e,t,$);return[a,s]}static ParseSectionDescribe(e,t=0,$=!0){let a=new Map;return d.ReadNavigation._toDescribeMap(e,t,a,$),a}}class u{static BINFIXED_ATTITUDE_DATA=new Map([["EF","U1"],["EH","U2"],["EI","U2"],["EJ","U2"],["EP","U4"],["EU","U1"],["EV","U2"],["EZ","U8"]])}class p{}class h{static HEADER_HID=32639;static HID={HEADER:{code:h.HEADER_HID,title:"Header",cls:t},FIXED:{code:0,title:"Fixed Leader",cls:$},VARIABLE:{code:128,title:"Variable Leader",cls:a},VELOCITY:{code:256,title:"Veolocity Data",cls:s},CORR:{code:512,title:"Correlation magnitude Data",cls:r},INTENSITY:{code:768,title:"Echo intensity Data",cls:n},PG:{code:1024,title:"Percent good Data",cls:o},STATUS:{code:1280,title:"Status Data",cls:l},BT:{code:1536,title:"Bottom Track Data",cls:c},ASP:{code:524,title:"Ambient Sound Profile",cls:_},MICROCAT:{code:2048,title:"MicroCAT Data"},NAV:{code:8192,title:"Binary Navigation Data",cls:d},BINFIXED_ATTITUDE:{code:12288,title:"Binary Fixed Attitude Data",cls:u},BINVAR_ATTITUDE:{code:12352,title:"Binary Variable Attitude data",cls:p},UNKNOWN30E8:{code:12520,title:"Unknown type 0x30E8"},UNKNOWN30D8:{code:12504,title:"Unknown type 0x03D8"}};static SplitEnsemble(e,$,a=!0){let s=e.getUint16($,a);if(h.HEADER_HID!==s)return!1;let r=t.ParseSection(e,$,a);return r}static DescType(e){for(let[t,$]of Object.entries(h.HID))if($.code===e)return $}static GetTitle(e){for(let[t,$]of Object.entries(h.HID))if($.code===e)return $.title}static GetParser(e){for(let[t,$]of Object.entries(h.HID))if($.code===e)return $.cls?.ParseSectionDescribe}}class U{constructor(e=!0){this.littleEndian=e}parse(e,t){this.dataView=e,void 0===t&&(t=h.SplitEnsemble(e,0,this.littleEndian)),this.offsets=t.ensemble.offsets,this.sections=U.DivideOffsets(this.offsets,t.len,0),this.sections.forEach($=>{let a=e.getUint16($.offset,this.littleEndian);$.hID=a,$.dataView=new DataView(e.buffer,t.offset+$.offset,$.len)});let $=new Map;for(let[a,s]of Object.entries(h.HID)){let r=this.sections.find(e=>e.hID===s.code);r&&$.set(a,r)}this.sectionMap=$,this.parseEssential()}parseEssential(){let e=this.fixed?.dataView,t=this.nav?.dataView;if(!e||!t)return;let a=$.ParseSysCfg(e,0,this.littleEndian);this.sysCfg=a;let s=$.ParseCoord(e,0,this.littleEndian);this.coord=s;let r=d.ParseSMGDMG(t,0,this.littleEndian);this.smg=r[0],this.dmg=d.BAM(r[1],16)}get header(){return this.sectionMap?.get("HEADER")}get fixed(){return this.sectionMap?.get("FIXED")}get variable(){return this.sectionMap?.get("VARIABLE")}get velocity(){return this.sectionMap?.get("VELOCITY")}get corr(){return this.sectionMap?.get("CORR")}get intensity(){return this.sectionMap?.get("INTENSITY")}get pg(){return this.sectionMap?.get("PG")}get status(){return this.sectionMap?.get("STATUS")}get nav(){return this.sectionMap?.get("NAV")}parseVelocity2D(e=-1,t=1){if($.COORD[3][0]!==this.coord.type){console.error("EnsembleContext.parseVelocity2D only supports Earth coordination type"),console.log(this.coord);return}let a=this.velocity?.dataView;if(!a){console.error("EnsembleContext.parseVelocity2D has no velocity section");return}let r=s.ParseSection(a,0,this.littleEndian),n=r[1];if(isNaN(n)||0>n||500<n||n!==parseInt(n)){console.error(`EnsembleContext.parseVelocity2D invalid cellCount ${n}`);return}let o=e;(o<0||o>n||isNaN(o))&&(o=n);let l=[],c=[];for(let _=0;_<o;_+=t){let d=s.ParseCellAt(a,_,this.littleEndian),u=s.ParseVelocity2DEarth(d);(-32768===u.n||-32768===u.e)&&(u.magnitude=-32768,u.direction=-32768),l.push(d),c.push(u)}return this.velocityCells=l,this.velocityMD=c,!0}parseMDNav(){let e=this.smg,t=this.dmg,$=[];this.velocityMD.forEach(a=>{if(-32768===a.magnitude||-32768===a.direction){$.push([-32768,-32768]);return}if(0===e){$.push(a);return}let r=s.DegreeToRange(a.direction+180-t),n=s.TrueWind(a.magnitude,r,e,t);n[1]=(n[1]+180)%360,$.push(n)}),this.velocityMDNav=$}parsePosition(){let e=this.nav?.dataView;if(!e)return console.error("EnsembleContext.parsePosition has no navigation section"),!1;let t=d.ParsePositionFirst(e,0,this.littleEndian),$=d.ParsePositionLast(e,0,this.littleEndian);return t=[d.BAM(t[0],32),d.BAM(t[1],32)],$=[d.BAM($[0],32),d.BAM($[1],32)],this.posFirst=t,this.posLast=$,!0}parseTimeStamp(){let e=this.variable?.dataView;if(!e)return console.error("EnsembleContext.parseTimeStamp has no variable section"),!1;let t=a.ParseTimeStamp(e,0,this.littleEndian);this.ts=t}parseMeta(){return this.posFirst||this.parsePosition(),this.ts||this.parseTimeStamp(),this.meta={eq:"ADCP_"+this.sysCfg.systemStr,eqid:"ADCP_"+this.sysCfg.systemStr+"_0000",ts:this.ts,ms:this.ts.getTime(),lat:this.posFirst[0],lng:this.posFirst[1],lat2:this.posLast[0],lng2:this.posLast[1]},this.meta}getMeta(){return this.meta}static GetMetaDesc(){return{ts:"Variable tsYear, tsMonth, tsDay, tsHour, tsMin, tsSec, tsHundredths - parseTimestamp",ts2:"no ts2 since ensemble has one varialbe",ms:"ts.getTime()",eq:"ADCP_ + sysCfg.systemStr - ADCP_38kHz",eqid:"no serial in file, eq +_0000, just use any name",lat:"Navigation positionFirst[0] from parsePosition",lng:"Navigation positionFirst[1] from parsePosition",lat2:"Navigation positionLast[0] from parsePosition",lng2:"Navigation positionLast[1] from parsePosition"}}static DivideOffsets(e,t,$=0,a=!0){let s=[];if(!t){console.error("EnsembleContext.OffsetDivide should have totalBytes");return}let r=e.map(e=>e);!0===a&&0!==r[0]&&r.unshift(0),r.push(t);for(let n=0;n<r.length-1;n++){let o=r[n],l=r[n+1],c=l-o;s.push({offset:$+o,len:c})}return s}}class x{constructor(){this.dataView=void 0,this.ensembles=void 0,this.littleEndian=!0}load(e,t,$){this.dataView=e,this.ensembles=t,this.littleEndian=$}}class m{static ParseEnsembles(e,t=!0){let $=new DataView(e),a=[],s=0;for(;s<$.byteLength;){let r=h.SplitEnsemble($,s,t);if(!r)break;let n={offset:s,len:r.noBytesEns+2,title:"Ensemble",ensemble:r};a.push(n),s=s+r.noBytesEns+2}let o=new x;return o.load($,a,t),o}static ParseEnsemblesContext(e){e.ensembles.forEach(t=>{m.ParseEnsembleContext(e,t)})}static ParseEnsembleContext(e,t){let $=new U,a=new DataView(e.dataView.buffer,t.offset,t.len);$.parse(a,t),t.context=$}static ParseMeta(e,t=!0){let $=m.ParseEnsembles(e,t),a=[$.ensembles.at(0),$.ensembles.at(-1)],s=a.map(e=>(m.ParseEnsembleContext($,e),e.context.parseMeta(),e.context.getMeta())),r={eq:s[0].eq,eqid:s[0].eqid,lat:s[0].lat,lng:s[0].lng,lat2:s[1].lat2,lng2:s[1].lng2,ts:s[0].ts,ms:s[0].ms,ts2:s[1].ts,ms2:s[1].ms,count:$.ensembles.length,bytes:e.byteLength};return r}static GetMetaDesc(){return{ts:"Variable tsYear, tsMonth, tsDay, tsHour, tsMin, tsSec, tsHundredths - parseTimestamp",ts2:"no ts2 since ensemble has one varialbe",ms:"ts.getTime()",eq:"ADCP_ + sysCfg.systemStr - ADCP_38kHz",eqid:"no serial in file, eq +_0000, just use any name",lat:"Navigation positionFirst[0] from parsePosition",lng:"Navigation positionFirst[1] from parsePosition",lat2:"Navigation positionLast[0] from parsePosition",lng2:"Navigation positionLast[1] from parsePosition",count:"number of ensembles",desc:"parse meta from arrayBuffer, first and last ensemble only, ensemble context parsed with ParserEntryPD0",bytes:"arrayBuffer.byteLength"}}}return{PD0:h,PD0Header:t,PD0Fixed:$,PD0Variable:a,PD0Navigation:d,PD0Velocity:s,ParserContext:x,Ensemble:U,ParserTest:m,GetTitle:h.GetTitle,GetParser:h.GetParser,DescType:h.DescType,ParseEnsembles:m.ParseEnsembles,ParseMeta:m.ParseMeta,GetMetaDesc:m.GetMetaDesc,INVALID_VALUE:-32768}})(),r=(()=>{class t{static STRUCT_TECHNICAL_N1=new Map([["type","U1"],["gi_cycleno","U2"],["gi_irisesno","U1"],["gi_ffchk","U2"],["gi_fserialno","U2"],["er_day","U1"],["er_month","U1"],["er_year","U1"],["er_rday","U1"],["er_cyclestart","U2"],["er_hyd1surf","U2"],["er_nosimplevalvesurf","U1"],["er_groundsurf","U1"],["pdd_descstart","U2"],["pdd_fstabletime","U2"],["pdd_descend","U2"],["pdd_novalve","U1"],["pdd_nopump","U1"],["pdd_fstablepres","U2"],["pdd_maxpres","U2"],["pdp_driftabsday","U1"],["pdp_noent","U1"],["pdp_norepos","U1"],["pdp_minpres","U2"],["pdp_maxpres","U2"],["pdp_novalve","U1"],["pdp_nopump","U1"],["dpd_descstart","U2"],["dpd_descend","U2"],["dpd_novalve","U1"],["dpd_nopum","U1"],["dpd_maxpres","U2"],["dppp_noent","U1"],["dppp_norepos","U1"],["dppp_novalve","U1"],["dppp_nopump","U1"],["dppp_minpres","U2"],["dppp_maxpres","U2"],["ap_ascstart","U2"],["ap_ascend","U2"],["ap_nopump","U1"],["gi_ftime1","U1"],["gi_ftime2","U1"],["gi_ftime3","U1"],["gi_fdate1","U1"],["gi_fdate2","U1"],["gi_fdate3","U1"],["gi_pressensoroffset","U1"],["gi_intpres","U1"],["gi_battvoltdrop","U1"],["gi_rtcstate","U1"],["gi_problemcounter","U1"],["gi_oxysensorstatus","U1"],["gps_latdeg","U1"],["gps_latmin","U1"],["gps_latminfrac","U2"],["gps_latns","U1"],["gps_lngdeg","U1"],["gps_lngmin","U1"],["gps_lngfrac","U2"],["gps_lngew","U1"],["gps_validfix","U1"],["gps_sesduration","U2"],["gps_retries","U1"],["gps_pumpduration","U2"],["gps_antennastatus","U1"],["eoli_detflag","U1"],["eoli_starthour1","U1"],["eoli_starthour2","U1"],["eoli_starthour3","U1"],["eoli_startdate1","U1"],["eoli_startdate2","U1"],["eoli_startdate3","U1"],["eoli_notused1","U1"],["eoli_notused2","U1"],["eoli_notused3","U1"],]);static ReadTechnicaln1=e.CreateReader(t.STRUCT_TECHNICAL_N1);static ParseSectionDescribe(e,$,a){let s=new Map;return t.ReadTechnicaln1._toDescribeMap(e,$,s,a),s}}class ${static STRUCT_PROFILE_CTD_HEADER=new Map([["type","U1"],["gi_cycleno","U2"],]);static STRUCT_PROFILE_CTD_SAMPLE_DATE=new Map([["hour","U2"],["min","U1"],["sec","U1"],]);static STRUCT_PROFILE_CTD_SAMPLE=new Map([["pres","U2"],["temp","U2"],["sal","U2"],]);static ReadProfileCTDHeader=e.CreateReader($.STRUCT_PROFILE_CTD_HEADER);static ReadProfileCTDSampleDate=e.CreateReader($.STRUCT_PROFILE_CTD_SAMPLE_DATE);static ReadProfileCTDSample=e.CreateReader($.STRUCT_PROFILE_CTD_SAMPLE);static ParseSectionDescribe(e,t,a){let s=new Map,r=0;$.ReadProfileCTDHeader._toDescribeMap(e,t+r,s,a),r+=$.ReadProfileCTDHeader._size,$.ReadProfileCTDSampleDate._toDescribeMap(e,t+r,s,a),r+=$.ReadProfileCTDSampleDate._size;for(let n=0;n<15;++n){let o=new Map;if($.ReadProfileCTDSample._toDescribeMap(e,t+r,o,a),r+=$.ReadProfileCTDSample._size,0!==o.get("pres").v||0!==o.get("temp").v||0!==o.get("sal").v)for(let[l,c]of o.entries())s.set(`${l}${n+1}`,c)}return s}static ParseCTDPressure(e){return{v:e/10,unit:"dBar"}}static ParseCTDTemperature(e){return{v:e/1e3,unit:"degreeCelsius"}}static ParseCTDSalinity(e){return{v:(e+1e4)/1e3,unit:"PSU"}}}class a{static littleEndian=!1;static TYPE_LENGTH=1;static SECTION_LENGTH=100;static PACKET_TYPES={0:{title:"Technical packet n1",cls:t},1:{title:"Descent CTD packet",cls:$},2:{title:"Drift CTD packet",cls:$},3:{title:"Ascent CTD packet",cls:$},4:{title:"Technical packet n2",cls:void 0},5:{title:"Float parameter packet",cls:void 0},6:{title:"Hydraulic packet",cls:void 0}};static DescType(e){return a.PACKET_TYPES[e]?.title??void 0}static GetType(e){return a.PACKET_TYPES[e]}static CreateInvalidSection(e,t){let $=new Map;return $.set("type",{v:t,type:"U1",size:1}),$}static ParseDescribe(e,t=0,$=a.littleEndian){let s=e.byteLength,r=s%a.SECTION_LENGTH;0!==r&&console.info(`dataView expected to be multiple of 100 but its ${s} bytes, remain section will be ignored`);let n=[];for(let o=0;o<s;o+=100){let l=o+t,c=e.getUint8(l),_=a.GetType(c);if(_){if(_.cls){let d=_.cls.ParseSectionDescribe(e,l,$);n.push(d)}else n.push(a.CreateInvalidSection("Valid section but no cls implemented",c))}else n.push(a.CreateInvalidSection("Invalid section",c))}return n}}return{ArgoSBD:a,ArgoSBD0:t}})();return{ParserA:e,ParserEM:t,ParserSEGY:$,ParserCTD:a,ParserPD0:s,ParserSBD:r}})();